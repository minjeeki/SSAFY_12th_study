# 9주차. DP1 문제 풀이

## 문제 리스트

- [X] [[BOJ] 11726 / 2×n 타일링](https://www.acmicpc.net/problem/11726)
- [ ] [[BOJ] 11048 / 이동하기](https://www.acmicpc.net/problem/11048)
- [ ] [[BOJ] 1149 / RGB 거리](https://www.acmicpc.net/problem/1149)
- [ ] [[BOJ] 11053 / 가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
- [ ] [[BOJ] 12865 / 평범한 배낭](https://www.acmicpc.net/problem/12865)

## 후기

어쩌면 이제 DP 풀 수 있을지도? 다음에는 바텀업과 탑다운 두개로 풀어보고 싶다!

## 학습 내용 - 다이나믹 프로그래밍 (동적 계획법)

### 다이나믹 프로그래밍을 사용할 수 있는 조건

1. 큰 문제를 작은 문제로 나눌 수 있다.

2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다

### 다이나믹 프로그래밍을 구현하는 방법

1. 탑 다운 방식 (= 메모이제이션 / 캐싱)

    : 한번 구한 정보를 리스트에 저장 -> 재귀적 수행하다가 이미 구한 정답을 그대로 리스트에 가져오면 됨 (재귀를 이용해 큰 문제를 해결하기 위해 작은 문제를 호출한다.)

    * 메모이제이션 : 이전에 계산된 결과를 일시적으로 기록해놓은 넓은 개념 (결과를 어딘가에 담아 놓기만 하고 DP를 위해 활용하지 않을 수 있다.)

        * 때에 따라 사전 자료형을 이용할 수도 있다.

    => 같은 문제라면 한번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법

3. 바텀 업 방식

    : 반복문을 이용해 작은 문제부터 순차적으로 답을 도출한다.

    * DP 테이블 : 보텀업 방식에서 사용되는 결과 저장용 리스트

### 분할 정복과 다이나믹 프로그래밍의 차이점

- 다이나믹 프로그래밍은 작은 문제들이 서로 영향을 미치고 있다

### 다이나믹 프로그래밍 유형임을 파악하는 방법

- 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸린다면, DP로 적용할 수 있는지 해결하고자 하는 부분 문제들의 중복 여부를 확인해본다.

- 단순 재귀함수로 비효율적인 프로그램 작성 뒤 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있다면 (메모이제이션) 코드를 개선하는 방법도 좋다.

### DP 문제 풀이 연습 권장

- 가능하다면 재귀 함수를 이용하는 탑 다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다 (재귀 함수의 스택 크기가 한정되어 있을 수 있기 때문)

    * sys.setrecursionlimit() 함수를 호출해 재귀 제한을 완화할 수 있긴 하다
