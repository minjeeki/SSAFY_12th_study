# 순환 (재귀, recursion)

## 순환 (재귀)

: 어떤 알고리즘이/함수를 (1)자기 자신을 호출하여 문제를 (2)단계별로 나누어 해결하는 기법

- 복잡한 문제를 간단한 하위 문제로 나누고, 그 하위 문제를 해결함으로써 원래 문제를 해결하는 방법을 사용
- 본질적으로 순환적인 문제나 순환적인 자료구조를 다루는 프로그램에 적합함

### 재귀의 기본 구성 요소

> 재귀 알고리즘은 ‘자기 자신을 순환적으로 호출하는 부분 (재귀 호출)’과 ‘순환 호출을 멈추는 부분(기저 조건)’으로 구성되어 있다.
> 
1. 기저 조건 (Base Case)
    
    : 재귀 함수가 더 이상 자기 자신을 호출하지 않고 종료될 수 있는 조건
    
    - 기저 조건이 없으면 함수가 무한히 호출되어 스택 오버플로우가 발생할 수 있음
    - 기저 조건에는 재귀적인 호출이 존재하지 않음
    
    > 무한 루프를 방지하기 위해 기저 조건을 명확하게 설정해야 한다
    > 
2. 재귀 호출 (Recursive Call)
    
    : 함수가 자기 자신을 호출하는 부분
    
    - 문제를 더 작게 만들어 재귀 호출을 통해 해결
    - 재귀 호출 변수는 점차 기저 조건의 값에 접근하는 방향으로 설계되어야 한다
    - 중복 계산이 많은 경우 메모이제이션 등을 활용해 효율성을 높일 수 있다
    
    [재귀 호출의 내부적인 구현은 ‘스택’이다](https://www.notion.so/d4dc1806a2c248dcbeb6a3f4065e6a36?pvs=21)
    

### 재귀 알고리즘의 장단점

- 장점
    - 문제를 간단하고 자연스럽게 표현할 수 있음
    - 복잡한 문제를 재귀적으로 나누어 작은 단위로 바라봐 쉽게 해결 가능
- 단점
    - 호출 스택을 많이 사용해 메모리를 많이 소모할 수 있음
    - 기저 조건이 잘못 설정될 경우 무한 루프에 빠질 수 있음

### 재귀 알고리즘 사용 예시

- 정수의 팩토리얼
    
    $n! = n * (n - 1) * (n - 2) * … * 1$
    
    - 기저 조건 : (n = 0) 0! = 1
    - 재귀 관계 : (n ≥ 1) n! = n * (n-1)!

![재귀 호출의 트리 구조](%E1%84%89%E1%85%AE%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20(%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1,%20recursion)%20756f63f5d2f54e1fbe84f34d7fdcd220/Untitled.png)

재귀 호출의 트리 구조

```python
def factorial(n):
	if (n <= 1):
		return 1
	else:
		return (n * factorial(n-1));
```

- 피보나치 수열 : 각 숫자가 앞의 두 숫자의 합이 되는 수열
    - 기저 조건 : (n ≤ 1) F(n) = n
        
        (n = 0) F(0) = 0
        
        (n = 1) F(1) = 1
        
    - 재귀 호출 : (n ≥ 2) F(n) = F(n-1) + F(n-2)
    - 피보나치 수열의 경우 많은 중복 계산이 발생할 수 있다.
        
        ⇒ 메모이제이션이나 동적 프로그래밍을 사용해 중복 계산을 피할 수 있다.
        
        [DP (메모이제이션, 타뷸레이션)](https://www.notion.so/DP-fd6312716802481db16e39ea2f86fddc?pvs=21) 
        

![피보나치 수열 재귀 호출 트리](%E1%84%89%E1%85%AE%E1%86%AB%E1%84%92%E1%85%AA%E1%86%AB%20(%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1,%20recursion)%20756f63f5d2f54e1fbe84f34d7fdcd220/Untitled%201.png)

피보나치 수열 재귀 호출 트리

```python
def fibonacci(n):
	if n <= 1:
		return n
	else:
		return fibonacci(n-1) + fibonacci(n-2)
```