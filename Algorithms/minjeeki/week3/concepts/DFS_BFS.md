# DFS / BFS

## 그래프의 탐색

: 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한번씩 방문하는 것

- 많은 문제들이 단순히 그래프의 노드를 탐색하는 것으로 해결됨 ⇒ 가장 기본적인 연산 중 하나
    - 특정 정점에서 다른 정점으로 갈 수 있는지, 없는지에 대해서
    ([S/W 문제해결 기본] 4일차 - 길찾기 / 문제 링크 : https://swexpertacademy.com/main/talk/solvingClub/problemView.do?solveclubId=AZC_xVEKy0cDFAQW&contestProbId=AV14geLqABQCFAYD&probBoxId=AZEqhUy6xEkDFAVs&type=PROBLEM&problemBoxTitle=0807+Stack+1_2&problemBoxCnt=5)
- `‘그래프 표현 방식’`과 `‘그래프 탐색 방법'`, 각각의 `'탐색 방법의 동작 방식’`을 이해해야 한다

### 그래프 이해 & 구현

- 그래프 탐색 시 준비해야 할 자료 구조 (데이터를 담는 공간), 변수 등
    - 모든 정점에 대한 방문 표시 (리스트 / `visited = [False] * 정점_개수`)
    - 그래프 자료 구조 (인접 리스트, 인접 배열)
    - 각 탐색 방법에 대한 처리 (DFS 중 스택 활용 시 or BFS - 큐)
- 그래프 표현 방식에는 2가지 방법이 있다.
    - 인접 배열로 구현
        
        : 하나의 정점에 대해서 존재하는 나머지 모든 정점과의 연결 관계 표현
        
        ⇒ 정점 개수 n이라고 할 때, n * n의 2차원 배열로 표현함
        
    - 인접 리스트로 구현
        
        : 하나의 정점에 대해서 연결된 정점만을 리스트로 담아 연결 관계 표현
        
        ⇒ 정점 개수 n의 1차원 포인터 배열, 각 포인터는 연결 관계를 갖는 리스트 구조임 
        
        > 파이썬의 경우에는 동적 배열을 사용하기 때문에 상관없지만
        다른 언어의 경우에는 연결 리스트를 구조체(C언어) 등을 이용해서 노드 생성 후 연결
        > 

### 그래프의 탐색 방법

- 깊이 우선 탐색 (DFS: depth first search)
    
    : 시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면, 가장 가까운 갈림길로 돌아와서 다른 방향으로 탐색 진행
    
- 너비 우선 탐색 (BFS : breath first search)
    
    : 시장 정점으로부터 가까운 정점을 먼저 방문하고, 멀리 떨어져 있는 정점을 나중에 방문
    

## 깊이 우선 탐색 (DFS)

: 시작 정점에서 한 방향으로 계속 가다가 더 이상 갈 수 없게 되면, 가장 가까운 갈림길로 돌아와서 다른 방향으로 탐색 진행

⇒ 나아갈 수 있는 정점까지 계속 재귀호출을 진행 or 스택의 top에 대해서 진행 가능 여부 확인

### DFS 논리적으로 이해하기

- DFS의 논리적 순서 이해하기
    
    > 깊이 우선 탐색 역시 자기 자신을 다시 호출하는 순환 알고리즘의 형태를 갖고 있음
    > 
    1. 정점 설정 & 방문 처리 : 시작 정점 v 설정 + v에 대한 방문 처리
    2. 인접 정점 찾기 : v에 인접한 정점들 중에서 방문하지 않은 정점 u 찾기
        - 방문하지 않은 정점이 있을 경우 : 1의 과정 다시 반복
        - 방문하지 않은 정점이 없을 경우 : 종료
- DFS를 구현 방식 이해하기
    - 순환 호출 (재귀 함수)를 이용하는 방법
        
        ⇒ 재귀 함수의 메모리에서의 동작 방식이 스택을 이용하는 것이기 때문
        
        - 기저 조건 (base) :
        - 순환 호출 :
            - 함수 호출 (input으로 정점 받아, output으로 다음 탐색할 정점 설정)
            ⇒ 메모리 스택 영역 push
            - 함수 코드 블록 전체 실행 완료
            ⇒ 메모리 스택 영역 pop
        
        ```scss
        방문 처리를 위한 배열 필요
        
        DFS(v):
        	v에 대한 방문 처리;
        	for 반복 - v의 모든 인접 정점(u) 하나씩 확인 do
        		if u가 아직 방문되지 않았으면
        			then DFS(u)
        ```
        
    - 명시적인 스택을 사용해서 인접 정점을 스택에 저장했다가 다시 꺼내어 작업하는 것
        
        ⇒ 반복문을 통해 스택 작업을 직접 하는 것이기에 push, pop 상황 구분에 유의해야 한다
        
        - 기저 조건 (반복문 종료 조건) : stack의 모든 요소가 빠졌을 때
        (탐색 시작 시 시작 정점을 넣는 작업 필요)
        - 스택 push : 정점 설정 (최상위 노드 탐색)
        - 스택 pop : 인접 노드가 모두 방문처리가 될 경우 pop
        (다음 최상위 노드 탐색)
        
        ```scss
        방문 처리를 위한 배열 필요
        
        # 형태 1
        DFS(그래프 G, 시작 정점 v):
        	스택 S 생성
        	S.push(v) : 스택에 시작 정점 v 담고 시작 (재귀에서는 함수 호출이 스택 영역에 push한 것)
        	while (not is_empty(S))
        		v = S.pop()
        		if (v가 방문되지 않았으면)
        			v를 방문되었다고 표시
        		for 반복 - v의 모든 인접 정점(u)를 하나씩 확인 do
        			if u가 아직 방문되지 않았으면
        				S.push(u)
        				break
        
        # 형태 2
        DFS(그래프 G, 시작 정점 v):
        	스택 S 생성
        	top = v
        	S.push(top)
        	top에 대한 방문 처리;
        	while (not is_empty(S))
        		for 반복 - v의 모든 인접 정점 u를 하나씩 확인
        			if u가 아직 방문되지 않았으면
        				v = u
        				v에 대한 방문 처리;
        				break;
        		else (for-else문) : 모든 인접 정점을 순회했으나 인접 정점이 모두 방문
        			S.pop()
        		S.push(v)
        ```
        

### DFS 코드로 구현하기

- 인접 리스트 + 스택
- 인접 배열 + 스택
- 인접 리스트 + 재귀
- 인접 배열 + 재귀

### DFS 분석 (시간 복잡도 계산하기)

> C언어 책 기준 정리한 내용이기 때문에 추가 학습 필요
> 
- 정점 개수 n / 간선 수 e인 그래프의 경우
    - 인접 리스트로 표현 : 시간 복잡도  $O(n + e)$
    - 인접 행렬로 표현 : 시간 복잡도  $O(n^2)$
    
    ⇒ 희소 그래프의 경우 DFS 탐색 시 인접 리스트의 사용이 인접 행렬보다 시간적으로 유리함
    

### DFS 응용 - 백트래킹

: DFS에서 필요한 곳만 탐색하도록 하는 기법

> 백트래킹 = DFS + (정답이 될 수 있는 곳만 가도록, 조건을 달아)가지치기 ⇒ 시간 감소
> 
- DFS와 백트래킹은 목적 자체가 다르다
    - DFS 목적 : 완전 탐색
    - 백트래킹 목적 : 정답이 될 수 있는 곳만 탐색 (모든 후보를 검사하지 않는다)

## 너비 우선 탐색 (BFS)

: 시작 정점에서 가까운 정점을 먼저 방문하고, 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법

⇒ 가까운 거리에 있는 정점들을 차례로 저장한 후 꺼낼 수 있는 자료구조 ‘큐(queue)’를 사용함

### BFS 논리적으로 이해하기

### BFS 코드로 구현하기

- 인접 리스트 + 큐
- 인접 배열 + 큐

### BFS 분석

- 정점 개수 n / 간선 수 e인 그래프의 경우
    - 인접 리스트로 표현 : 시간 복잡도  $O(n + e)$
    - 인접 행렬로 표현 : 시간 복잡도  $O(n^2)$
    
    ⇒ 희소 그래프의 경우 BFS 탐색 시 인접 리스트의 사용이 인접 행렬보다 시간적으로 유리함
    (DFS와 동일)