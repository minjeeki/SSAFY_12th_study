# 트리

## 트리 (Tree)

- 계층적 관계를 표현하는 (가지를 늘려가며 뻗어나가는 형태의) 자료구조
- 트리는 기본적으로 데이터의 저장과 삭제보다는 '표현'에 초점이 맞춰져 있는 도구다.
"트리 구조로 이루어진 무엇인가를 표현하기에 적절히 정의되어 있는가"

### 트리 관련 용어

- 노드 (node) : 트리의 가장 기본적인 구성 요소
    - 루트 노드 (root node) : 트리 구조에서 최상위에 존재하는 노드
    - 단말 노드 (terminal node, leaf node) : 하위에 다른 노드가 연결되어 있지 않은 노드
    - 내부 노드 (internal node, nonterminal node) : 단말 노드를 제외한 모든 노드 (루트 노드 포함)
    "노드 간에는 상대적으로 부모(parent), 자식(child), 형제(sibling) 관계가 성립된다."
        - 부모 - 자식 관계 : 한개의 간선으로 이뤄진 관계 중 루트 노드에 가까운 것이 부모 노드
        - 형제 관계 : 동일한 부모 노드를 갖는 자식 노드끼리의 관계
        - 조상 (후손) 관계 : 특정 노드 위에(아래에) 위치한 모든 노드
- 간선 (edge) : 노드와 노드를 연결하는 연결선
![[Pasted image 20231130174958.png]]
- 서브 트리 (Sub Tree)
: 큰 트리에 속하는 작은 트리 (특정 노드와 해당 노드의 자손으로 이루어진 트리)
    - 서브 트리 아래에는 더 작은 서브 트리가 존재할 수 있다.
    - 노드가 한개뿐인 트리 역시 서브 트리로 간주할 수 있다.
    (루트 노드인 동시에 해당 트리 전체를 나타내는 서브 트리이기 때문)
    ![[Pasted image 20231130174942.png]]
- 레벨 (level) : 트리에서 각 층별로 숫자를 매긴 값
    - 루트 노드는 항상 레벨이 0이다. (레벨은 0부터 시작하며 하위 관계로 내려갈수록 값이 증가)
- 높이 (height) : 트리의 최고 레벨값

## 이진 트리(Binary Tree)

모든 노드의 자식 노드 개수가 2개 이하인 트리

- 이진 트리가 만족해야 하는 조건
    1. 루트 노드를 중심으로 두개의 서브 트리로 나뉘어진다.
    2. 나뉘어진 두 서브 트리도 모두 이진 트리여야 한다.
- 이진 트리의 조건 자체가 재귀적이다 (재귀적인 특성을 지니고 있다)
- 노드가 위치할 수 있는 곳에 노드가 존재하지 않는다면 공집합 노드가 존재하는 것으로 간주한다.
=> 후손 노드가 1개 또는 없는 경우(리프 노드일 떄)에도 이진 트리라고 할 수 있는 이유
- 이진 트리는 반드시 대칭을 이룰 필요는 없다.
- 이진 트리는 노드의 채워진 정도에 따라 포화 이진 트리 / 완전 이진 트리 / 이진 트리로 분류한다.
    - 포화 이진 트리 (full binary tree) : 모든 레벨에 노드가 꽉 차 있어 노드 추가 시 높이 증가
    - 완전 이진 트리 (complete binary tree) : 자식 노드가 0개 또는 2개를 만족하는 트리
    (1개의 자신 관계를 갖는 노드가 없음)

### 이진 트리 구현

- 이진 트리는 재귀적인 특성을 갖고 있기 때문에 재귀 호출의 형태를 갖고 있다.
=> 한 노드의 생성
- 배열 또는 연결 리스트로 구현이 가능하다.
    - 트리 완성 이후 트리를 대상으로 빈번한 탐색이 이뤄지는 경우 => 배열 구현
    - 유연한 구조를 갖고 있어야 하는 경우 (지속적으로 추가, 삭제) => 연결 리스트 구현

### 1. 배열 기반 이진 트리

- 노드에 번호가 부여되어 있음 (노드에 고유 번호를 부여해야 함 -> 인덱스)
- 일반적으로 인덱스가 1인 배열의 요소를 루트 노드로 사용한다.
(인덱스가 0인 배열의 요소를 사용할 수 있긴 하나 구현 편의성 + 실수 확률 낮추기 위함)
- 완전 이진 트리 구조를 갖는 힙(heap) 자료구조의 경우 배열을 기반으로 구현한다.
- 트리의 크기가 큰 경우 메모리 사용 측면에서 배열로 구현하는 것이 비효율적일 수 있다.

### 2. 연결 리스트 기반 이진 트리

- 각 노드는 두개의 포인터 (자식 노드의 주소값)을 갖는다.
- 연결 리스트의 구성 형태가 트리와 일치하기 때문에 구현에 대한 이해도가 직관적이다.

### 이진 트리 순회 (Traversal)

- 이진 트리 순회는 루트 노드를 언제 방문하느냐에 따라 세가지로 나뉜다.
(실제 구현에서는 루트 노드 방문 관련 문장의 삽입 위치에 따라 달라진다.)
1. 전위 순회 (Preorder Traversal) : 루트 노드를 먼저 (루트 -> 자손1 -> 자손2)
2. 중위 순회 (Inorder Traversal) : 루트 노드를 중간에 (자손1 -> 루트 -> 자손2)
3. 후위 순회 (Postorder Traversal) : 루트 노드를 마지막에 (자손1 -> 자손2 -> 루트)
- 이진 트리의 순회 역시 재귀적이다
=> 서브 트리의 부모 노드를 기준으로 순회 방식에 맞춰 재귀적으로 돈다.
- 이진 트리의 방문 여부 확인은 각 노드의 방문 여부를 기록한 요소가 필요하다.
(구조체 멤버로 visited 추가 / 방문 여부를 담은 배열 또는 리스트 생성 후 값 저장)

## 이진 탐색 트리 (Binary Search Tree, BST)

- 이진 트리의 일종
- 노드의 왼쪽 서브 트리는 해당 노드보다 값이 작고, 오른쪽 서브 트리는 해당 노드보다 값이 크다.
=> 저장과 동시에 일정한 규칙에 따라 데이터를 저장한다.
- 탐색, 저장, 삭제 시간 복잡도 : O(logn) -> O(n)
    - worst case : 균형이 깨쳐 한쪽으로 치우쳐질 경우 연결 리스트와 유사한 형태가 된다.
    => AVL 트리나 Red-black Tree를 이용해서 트리의 균형이 잘 맞을 수 있도록 유지할 수 있다.

## 수식 트리 (Expression Tree)

- 이진 트리의 일종
- 컴파일러가 수식을 처리할 때 활용
(수식을 수식 트리로 표현할 경우 컴파일러의 수식 해석이 좋아짐)
- 루트 노드에는 연산자를, 레벨 1의 노드에는 수식 또는 서브 트리의 연산자를 둔다.