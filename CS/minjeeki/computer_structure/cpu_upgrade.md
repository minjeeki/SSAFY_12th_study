# CPU 성능(속도) 향상 기법

> CPU의 성능 향상 방법
> 
> 1. 클럭 속도를 높인다
> 2. CPU의 코어와 스레드 수를 늘린다
> 
> ---
> 
> 1. CPU가 놀지 않고 시간을 알뜰하게 쓰며 작동하게 한다

# 클럭, 코어, 스레드

## 클럭

: CPU 내부에서 동작을 동기화하는 전자기적 신호로, (1) 일정한 주기를 갖고, (2)반복적으로 발생

- 클럭 신호는 CPU 작업 처리 속도 (연산 속도)를 결정하는 중요한 요소이다.
    
    : CPU의 모든 연산과 명령어 처리는 클럭 신호에 맞춰서 이뤄지기 때문
    (클럭은 CPU가 동작을 수행하는 기본적인 타이밍을 제공한다)
    
- 클럭 발생기
    
    : 클럭 신호를 발생시키는 장치
    
    - 역할
        - 주기적인 신호 생성 → 기준 시간 제공
        : CPU와 시스템의 다른 부품들이 동일한 기준 시간에 맞춰 동작할 수 있도록 기준 신호를 제공
    - 클럭 발생기의 위치
        
        : 클럭 발생기는 물리적인 전기 신호를 생성하는 핵심 부품인 수정 발진기를 포함해 메인 보드(마더 보드)에 칩 형태로 장착되어 있음
        
        ⇒ 메인보드의 부품과 CPU에 클럭 신호를 생성하고 분배하는 역할
        

### 클럭의 특징

- 클럭의 시간적 지표
    - 클럭 속도 : CPU의 성능을 측정하는 주요 지표 중 하나
        - 클럭 속도가 높을 수록 CPU는 더 짧은 시간 안에 더 많은 작업을 수행할 수 있음
- 클럭의 물리적 지표
    - 클릭 주파수 : 1초당 클럭 신호가 발생하는 횟수
        - Hz 단위로 측정 (3GHz = 1초에 30억번의 클럭 신호 발생)
    - 클럭 사이클 : 클럭 신호가 한번 발생하는 시간 간격
        - CPU는 클럭 사이클 동안 기본 연산 등을 수행할 수 있음
    
    ⇒ 클럭 사이클이 짧을수록 (클럭 주파수가 높을수록) 더 많은 연산을 같은 시간 내 처리 가능
    

### 클럭의 역할

- 동기화 : 클럭 신호는 CPU 내부의 모든 연산과 명령어 처리를 동기화하는 역할을 함
    
    ⇒ CPU의 모든 부분이 동일한 속도로 작업을 수행할 수 있게 함
    
- 연산 속도 결정 : 클럭은 CPU가 명령어를 처리하는 속도를 결정함
    
    ⇒ 클럭 주파수가 높을수록 CPU는 더 많은 연산을 단위 시간 내에 수행할 수 있음
    

### 클럭 속도와 CPU 성능 사이 관계

- 일반적으로 클럭 속도가 높으면 CPU 성능이 향상됨
    
    ⇒ CPU가 더 빠르게 명령어를 처리하고 응답할 수 있기 때문
    
- CPU 연산 속도가 클럭 속도에 비례하진 않음
    - 높은 클럭 속도는 더 많은 열을 발생시키고 전력을 소비하게 하기 때문에 추가적인 관리가 수반됨
    - CPU 성능에는 클럭 속도 뿐만 아니라 아키텍처, 코어 수, 명령어 집합 효율성 등이 복합적으로 작용하기 때문

## 코어, 멀티 코어

: 명령어를 실행하는 ‘하드웨어 부품’

- 멀티 코어 프로세서 (멀티 코어 CPU) : 코어를 여러개 포함하고 있는 CPU
    - 듀얼 코어 (코어 2개) / 트리플 코어 (코어 3개) / 쿼드 코어 (코어 4개) / 헥사코어 (코어 6개) / 
    옥타 코어 (코어 8개) / 데카 코어 (코어 10개) / 도데카 코어 (코어 12개)
    - 싱글 코어 : 코어 1개

### 코어 개수와 CPU 성능 사이 관계

- 코어의 개수가 많을 수록 CPU 성능 향상
- CPU 연산 속도가 코어 수에 비례하진 않음
    - 코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례해 연산 속도가 증가하지 않음
    - 처리하는 작업량보다 코어 수가 지나치게 많은 경우에도 성능에는 크게 영향이 없음

⇒ “중요한 것은 코어마다 처리할 명령어들을 얼마나 적절히 분배하느냐”임

## 스레드, 멀티 스레드

: 실행 흐름의 단위

- 스레드 중에서는 하드웨어적 스레드와 소프트웨어적 스레드가 존재함
- 멀티 스레드 프로세서 (멀티 스레드 CPU)
    
    : 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
    
    ⇒ 이때의 스레드는 하드웨어적 스레드를 지칭함
    
    - cf. 하이퍼스레딩 : 인텔 사에서 멀티스레드 기술을 지칭하는 말

### 하드웨어적 스레드 (= 논리 프로세서)

(CPU에서 스레드를 다룰 때)

: 하나의 코어가 동시에 처리하는 명령어 단위 (명령어를 실행하는 단위)

- 여러개의 스레드를 지원하는 CPU의 경우 하나의 코어로도 여러개의 명령어 동시에 실행 가능

### (소프트웨어적) 스레드

(프로그래밍 언어나 운영체제에서 다루는 스레드)

: 하나의 프로그램에서 독립적으로 실행되는 단위

- 하나의 프로그램은 실행되는 과정에서 여러 부분이 동시에 실행될 수도 있다
    
    기능의 코드를 각각의 스레드로 만들면 동시에 실행 가능
    
    ⇒ 1코어 1스레드 CPU가 여러 스레드로 만들어진 프로그램을 실행할 수 있는 이유
    
- 프로그래밍 언어를 이용해 소프트웨어적 스레드를 만들 수 있음

### 멀티 스레드 CPU가 하드웨어적 스레드를 여러개 처리할 수 있는 이유

> 핵심은 레지스터
> 
- 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터 (프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터)를 여러개 갖고 있음

# 명령어 병렬 처리 기법

: 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 방법

- 명령어 병렬 처리 기법
    - 순차적 명령어 처리
        - 명령어 파이프 라이닝
        - 슈퍼 스칼라
    - 비순차적 명령어 처리

## 명령어 파이프 라이닝

: 명령어들은 명령어 파이프라인에 넣고 동시에 처리하는 기법

- 명령어 처리 과정 (클럭 단위로 구분)
    1. 명령어 인출
    2. 명령어 해석
    3. 명령어 실행
    4. 메모리 접근
    5. 결과 저장
    
    ⇒ 같은 단계가 겹치지만 않는다면 CPU는 각 단계를 동시에 실행할 수 있음 → CPU 성능 향상
    
- 파이프라이닝은 단일 파이프라인으로도 구현 가능

### 파이프라인 위험

: CPU 성능 향상에 실패하는 경우

- 데이터 위험
    
    : 명령어 간의 데이터 의존성 (명령어 중 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우)이 있어 동시에 실행할 경우 파이프라인이 제대로 작동하지 않는 경우
    
- 제어 위험
    
    : 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
    ⇒ 실행 흐름이 바뀔 경우 파이프라인에 미리 가지고 와서 처리 중이었던 명령어가 쓸모 없어짐
    
    - 프로그램 카운터 : 현재 실행 중인 명령어의 다음 주소로 갱신
    - 분기 예측
    : 제어 위험을 해결하기 위한 방안 / 프로그램이 어디로 분기할지 미리 예측한 후 주소 인출
- 구조적 위험 (자원 위험)
    
    : 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 ALU, 레지스터와 같은 CPU 부품을 사용하려고 할 때 발생
    

## 슈퍼스칼라

: CPU 내부에 여러개의 명령어 파이프라인을 포함한 구조

- 슈퍼스칼라 프로세서 (슈퍼스칼라 CPU)
    
    : 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
    
    - 매 클럭 주기 마다 동시에 여러 명령어 인출, 실행 가능
        
        ⇒ 멀티 스레드 프로세서는 슈퍼 스칼라 구조를 사용할 수 있음
        
- 슈퍼스칼라 프로세서는 이론적으로 파이프라인 개수에 비례해 프로그램 처리 속도가 빨라지지만, 파이프라인 위험 등의 문제가 있어 실제로는 비례하진 않음
    
    ⇒ 슈퍼스칼라 방식을 차용한 CPU는 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함
    (여러개의 파이프라인을 사용하기에 파이프라인 위험을 피하기에 더 까다로움)
    

## 비순차적 명령어 처리 (OoOE)

> 오늘날의 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법
> 

: 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법

⇒ 의존성이 없는 명령어의 실행 순서를 바꿔 전체 프로그램 실행 흐름에 영향주지 않고 효율적으로 동작하게 하는 방법

# ISA, CISC와 RISC

> 파이프라이닝 하기 쉬운(유리한) 명령어 설계
> 

## CPU마다 ISA는 다르다

- 명령어 집합 (명령어 집합 구조, ISA)
    
    : CPU가 이해할 수 있는 명령어들의 모음
    
- CPU마다 ISA(명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정방식)는 다를 수 있다
- 같은 소스 코드로 만들어진 프로그램이라도 ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어 달라짐 ⇒ ISA는 일종의 CPU 언어임

## CISC

: 복잡한 명령어 집합을 활용하는 컴퓨터, CPU

> CISC 기반 CPU는 성장에 한계가 있다
> 
- 특징
    - 가변 길이 명령어 (명령어의 형태와 크기가 다양함) 활용 :
        
        다양하고 강력한 기능의 명령어 집합을 활용하기 때문
        
        ⇒ 적은 수의 명령어로도 프로그램 실행 가능
        
    - 주소 지정 방식 (메모리 접근) 역시 다양함
- 장점 :
    
    적은 수의 명령어로도 프로그램 실행 가능 → 메모리 공간 절약 가능
    
    (실제로는 자주 사용되는 명령어만 쓰임)
    
- 단점
    - 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
    - 하나의 명령어를 실행하는데 여러 클럭 주기 필요
    
    ⇒ 명령어 파이프라인 구현에 걸림돌이 됨 (현대 CPU에서 치명적인 약점)
    

## RISC

: CISC에 비해 명령어의 종류가 적고, 짧고 규격화된 명령어(1클럭 내외 실행)를 지향

- 특징
    - 고정 길이 명령어 활용 ⇒ 파이프라이닝에 최적화
    - 메모리 접근 명령어 제한적 (load, store) → 주소 지정 방식의 종류가 적음
        
        ⇒ 메모리 접근 단순화, 최소화
        
        ⇒ 레지스터를 이용하는 연산이 많고, 범용 레지스터 개수도 많음
        
    - 명령어의 개수가 CISC보다 적기에 보다 많은 명령어를 이용해 프로그램 동작

# 질문

1. CPU 성능 향상시킬 수 있는 방법으로 클럭 속도를 높이는 방법이 있는데 해당 방법이 어떻게 CPU 성능을 향상시킬 수 있는지 설명하고 클럭 속도가 CPU 연산 속도에 비례하지 못하는 원인이 뭔지 설명하세요.
2. 멀티 스레드 CPU가 하드웨어적 스레드를 여러개 처리할 수 있는 이유에 대해서 설명하세요.
3. CISC과 RISC의 차이점에 대해서 설명하고, 이 중 명령어 파이프라이닝을 사용하기 어려운 방식이 어떤 것인지, 왜 어려운지 설명하세요.