# 10. 프로세스와 스레드

# 프로세스 (process)

> 프로세스 관련 개념
> 
> - 프로세스 종류
> - 프로세스 발생 시 커널 영역과 사용자 영역에서 일어나는 일
>     - 프로세스 제어 블록
>     - 프로세스 메모리 영역
> - 문맥 교환 (프로세스가 CPU에 번갈아가며 load될 때 일어나는 일)
> - 프로세스 상태 (PCB에 담기는 문맥 교환 판단 기준)
> - 프로세스 계층 구조
> (많은 프로세스는 프로세스가 프로세스를 낳는 계층 구조로 프로세스를 관리한다.)

## 프로세스

프로그램은 실행되기 전까지는 보조기억장치에 있는 데이터 덩어리
보조 기억 장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로그램 → 프로세스

- “프로세스를 생성한다” = 프로그램을 메모리에 적재하고 실행하는 과정

### 프로세스 확인 방법

- (윈도우) 작업 관리자 > ‘프로세스’ 탭에서 확인
- (유닉스 체계) `ps` 명령어 이용

### 프로세스의 종류

1. **포그라운드 프로세스 (foreground process)**
    
    : 사용자가 보는 앞에서(사용자가 볼 수 있는 공간에서) 실행되는 프로세스
    
2. **백그라운드 프로세스 (background process)**

: 사용자가 보지 못하는 뒤편에서 실행되는 프로세스

- 백그라운드 프로세스 중에서는 사용자와 직접 상호작용할 수 있는 것도 있지만, 상호작용 없이 정해진 일만 수행하는 프로세스도 존재함
    
    ⇒ 데몬(daemon in 유닉스 체계 운영체제) / 서비스 (service in 윈도우 운영체제)
    

## 프로세스 제어 블록 (PCB, Process Control Blcok)

> 프로세스들은 차례대로 돌아가며 한정된(정해진) 시간만큼만 CPU를 이용하고,
타이머 인터럽트가 발생하면 차례를 양보하고 대기한다.
> 
> - 타이머 인터럽트 (= 타임아웃 인터럽트)
>     
>     : 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트
>     
> 
> ⇒ 운영체제는PCB(프로세스 제어 블록)을 이용해 빠르게 번갈아 수행되는 프로세스의 실행 순서를 관리하고 프로세스에 CPU를 비롯한 자원을 배분한다.
> 

: 프로세스와 관련된 정보를 저장하는 구조

- 운영체제는 PCB로 특정 프로세스를 식별하고 해당 프로세스를 처리하는데 필요한 정보를 판단한다
- PCB 생성과 폐기
    - PCB 생성 : 프로세스 생성 시점에 메모리의 커널 영역에서 생성
    - PCB 폐기 : 프로세스의 실행이 끝나면 폐기
    
    > 프로세스를 생성했다 = 운영체제가 PCB를 생성했다.
    > 
    > 
    > 프로세스가 종료되었다 = 운영체제가 해당 PCB를 폐기했다
    > 

### PCB에 담긴 정보들

- `프로세스 ID (PID, Process ID)`
    
    : 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
    
    - 같은 프로그램이라 하더라도 두번 실행할 경우 PID가 다른 두개의 프로세스가 생성
- `레지스터 값`
    
    : 프로세스가 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값 담김
    
    - 프로세스는 자신의 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값을 모두 복원함
    (이전까지 진행했던 작업들을 그대로 이어 실행하기 위함)
- `프로세스 상태`
    
    : 프로세스의 현재 상태에 대한 기록이 있어야 함
    (입출력장치를 사용하기 위해 기다리는 중인지, CPU를 사용하기 위해 기다리는 중인지, CPU를 사용하고 있는지 등)
    
- `CPU 스케줄링 정보`
    
    : 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
    
- 메모리 관리 정보 (베이스 레지스터, 한계 레지스터 값, 페이지 테이블 정보)
    
    : 프로세스마다 메모리에 저장된 위치가 다르기에 프로세스의 저장 주소 정보 필요
    
- `사용한 파일과 입출력 장치 목록`
    
    : 프로세스 실행 과정에서 특정 입출력장치, 파일 사용 시 PCB에 명시됨
    (어떤 입출력장치가 프로세스에 할당되었는지, 어떤 파일을 열었는지 등)
    

## 문맥 교환

> 프로세스에서 다른 프로세스로 실행 순서가 넘어갈 때 일어나는 일
> 
> - 직전까지 실행되던 프로세스
>     
>     : 각종 레지스터 값, 메모리 정보, 열었던 파일 or 입출력 장치의 중간 정보 백업 필요
>     
> - 새로 실행될 프로세스
>     
>     : PCB에서 실행할 프로세스의 문맥을 운영체제에 복구
>     

### 문맥 (context)

: 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보

- 하나의 프로세스 문맥은 해당 프로세스의 PCB에 기록됨
(PCB 기록 정보 = 문맥)

### 문맥 교환 (context swithcing)

: 기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것

- 문맥 교환은 여러 프로세스가 끊임없이 빠르게 번갈아가며 실행되는 원리
- 문맥 교환과 프로세스의 동시 실행
    
    문맥 교환이 자주 일어나면 그만큼 빨리 번갈아 가며 수행되기에,
    프로세스가 동시에 실행되는 것처럼 보임
    
- 빈번한 문맥 교환과 오버헤드
    
    문맥 교환을 너무 자주 하면 오버헤드가 발생할 수 있기에 문맥 교환이 빨리 일어난다고 좋은 것은 아님
    
    - 오버헤드 :
        
        어떤 작업이나 프로세스를 수행할 때 기본적인 것 이외 추가적으로 발생하는 비용, 자원
        
        (메모리, 시간, 처리 능력 등의 형태로 나타남)
        
- 문맥 교환 흐름
    1. 프로세스 A 실행
    2. (문맥 교환) 프로세스 A의 문맥(실행 결과가 담긴 정보)를 PCB에 저장
    3. (문맥 교환) 프로세스 B의 PCB로부터 문맥 가져오기
    4. 프로세스 B 실행
    5. (문맥 교환) 프로세스 B의 문맥을 PCB에 저장
    6. (문맥 교환) 프로세스 A의 PCB로부터 문맥 가져오기
    7. 프로세스 A 실행

## 프로세스의 메모리 영역

> 메모리의 사용자 영역에서는 프로세스가 4구역에 나눠 저장된다.
> 
> - 정적 할당 영역 : 코드 영역, 데이터 영역
> - 동적 할당 영역 : 스택 영역, 힙 영역

[https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=https://t1.daumcdn.net/cfile/tistory/270AA94D54AA41A709](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=https://t1.daumcdn.net/cfile/tistory/270AA94D54AA41A709)

### 코드 영역 (code segment / text segment)

: 실행할 수 있는 코드(기계어, CPU가 실행하는 명령어)로 이루어진 명령어가 저장되는 영역

- 코드 영역에서는 쓰기가 금지되어 있음 (읽기 전용 공간)
- 크기가 변하지 않음 ⇒ 정적 할당 영역

### 데이터 영역 (data segment)

: 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간 ⇒ 전역 변수

- 크기가 변하지 않음 ⇒ 정적 할당 영역

### 힙 영역 (heap segment)

: 프로그램을 만드는 사용자(프로그래머)가 직접 할당할 수 있는 공간

- 힙 영역에 메모리 공간을 할당했다면 해당 공간을 반드시 반환해야 한다
(메모리 공간을 사용하지 않을 때 운영체제에 해당 공간을 사용 완료했음을 알려줌)
- 동적 할당 영역 (크기가 변함)
- 일반적으로 힙 영역은 메모리의 낮은 주소에서 높은 주소로 할당
    
    ⇒ 스택 영역에 데이터가 쌓이더라도 새롭게 할당되는 주소가 겹치지 않게 하기 위함
    
- 메모리 누수 (memory leak)
    
    : 힙 메모리 공간을 반환하지 않을 경우 할당한 공간이 메모리 내에 계속 남아 메모리 낭비를 초래하는 상황
    

### 스택 영역 (stack segment)

: 데이터를 일시적으로 저장하는 공간 ⇒ 함수의 실행이 끝나면 사라지는 매개변수, 지역 변수

- 스택 영역 PUSH : 함수 호출 등으로 인해 일시적으로 데이터를 메모리에 올림
    
    스택 영역 POP : 함수 실행 종료 등으로 더이상 매개변수, 지역 변수 등의 데이터가 필요하지 않음
    
- 일반적으로 스택 영역은 높은 주소에서 낮은 주소로 할당
    
    ⇒ 힙 영역에 데이터가 쌓이더라도 새롭게 할당되는 주소가 겹치지 않게 하기 위함
    

## 프로세스 상태

> 컴퓨터를 사용할 때 여러 프로세스들은 빠르게 번갈아 가며 실행되며, 그 과정에서 하나의 프로세스는 여러 상태를 거친다
> 
> 
> 운영체제는 프로세스의 상태를 PCB를 통해 인식하고 관리한다.
> 

### 프로세스 상태 다이어그램 (process state diagram)

- 프로세스는 생성, 준비, 실행, 대기 종료 상태를 거치며 실행된다.
- 운영체제는 프로세스의 상태를 PCB에 기록하며 프로세스를 관리한다

### 생성 상태 (new)

: 프로세스를 생성 중인 상태 (막 메모리에 적재되어 PCB 할당받은 상태)

### 준비 상태 (ready)

: CPU 할당 차례를 기다리고 있는 상태

### 실행 상태 (running)

: CPU를 할당 받아 실행 중인 상태

- 실행 상태의 프로세스는 할당된 일정 시간 동안만 CPU를 사용할 수 있음
    
    할당 시간 모두 소진 시 타이머 인터럽트 발생 → 준비 상태 or 대기 상태가 됨
    
- 디스패치 (dispatch) : 준비 상태인 프로세스가 실행 상태로 전환되는 것

### 대기 상태 (blocked)

: 입출력 작업을 요청한 이후 입출력 장치의 작업 완료 인터럽트를 받을 때까지 또는 특정 이벤트가 일어나는 것을 기다리는 상태

### 종료 상태 (terminated)

: 프로세스가 종료된 상태

- 프로세스가 종료 상태가 되면 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함

## 프로세스 계층 구조

> 많은 프로세스는 프로세스가 프로세스를 낳는 계층 구조로 프로세스를 관리한다.
> 

### 부모 프로세스와 자식 프로세스

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다.

- 부모 프로세스 : 새 프로세스를 생성한 프로세스
- 자식 프로세스 : 부모 프로세스에 의해 생성된 프로세스
- 부모 프로세스, 자식 프로세스와 PID
    - 부모 프로세스와 자식 프로세스는 엄연히 다른 프로세스 ⇒ 각기 다른 PID를 가짐
    - 일부 운영체제에서는 자식 프로세스의 PCB에 PPID (부모 프로세스의 PID)가 저장되기도

### 프로세스 계층 구조

: 프로세스는 트리 형태의 계층 구조를 갖는다

⇒ 최초의 프로세스가 자식 프로세스를, 자식 프로세스는 새로운 자식 프로세스를 낳는다

- 데몬(서비스) 또한 최초 프로세스의 자식 프로세스이다.
- 프로세스 계층 구조를 보여주는 명령어 : `pstree`

### 최초의 프로세스

: 모든 프로세스의 가장 위에 있는 프로세스

- 최초의 프로세스의 PID는 항상 1번이며, 모든 프로세스의 최상단에 있는 부모 프로세스이다
- (유닉스) init
    
    (리눅스) systemd
    
    (맥 OS) launchd
    

## 프로세스 생성 기법

> 부모 프로세스는 자식 프로세스를 어떻게 만들어내고, 자식 프로세스는 어떻게 실행될까?
> 
> 
> ⇒ 복제 & 옷 갈아입기 (fork & exec) 의 반복
> 

### fork와 exec

: 시스템 호출의 일종

- fork 시스템 호출
    
    : 자기 자신 프로세스의 복사본을 만드는 시스템 호출
    
    (부모 프로세스가 자신의 복사본을 자식 프로세스로 생성)
    
    - 자식 프로세스에는 부모 프로세스의 자원들 (메모리 정보, 열린 파일 목록 등)이 자식에 상속
    - PID와 저장 메모리 위치는 부모 프로세스와 자식 프로세스가 다름
- exec 시스템 호출
    
    : 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출
    
    (자식 프로세스가 자신의 메모리 공간을 다른 프로그램으로 교체 ⇒ 새 프로그램 내용으로 전환)
    
    - 자식 프로세스의 정적 할당 영역 (코드, 데이터 영역)이 새 프로그램의 내용으로 교체
    동적 할당 영역(스택, 힙 영역)은 초기화

### 참고 자료

- 파이썬으로 프로세스 작업하기 (https://github.com/kangtegong/self-learning-cs/blob/main/process/process_python.md)
- C, C++로 프로세스 작업하기 (https://github.com/kangtegong/self-learning-cs/blob/main/process/process_python.md)

# 스레드 (thread)

## 스레드

: 프로세스를 구성하는 실행의 흐름 단위 (동시에 몇개의 명령어를 처리할 수 있는가?)

- 하나의 프로세스는 여러개의 스레드를 가질 수 있음
    
    스레드를 이용하면 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있음
    (최근 많은 운영체체는 CPU에 처리할 작업을 전달할 때 스레드 단위로 전달함)
    
- 스레드마다 실행에 필요한 최소한의 정보를 유지한 채 프로세스 자원을 공유하며 실행된다

### 스레드의 구성

- 스레드 ID
    
    ⇒ 스레드를 구분하는 식별자
    
- 레지스터 값 (프로그램 카운터 값 등)
    
    ⇒ 스레드마다 코드 영역의 시작 위치를 갖고 있는 프로그램 카운터 값이 존재
    
- 스택
    
    ⇒ 스레드마다 호출하는 함수에 대한 스택 영역을 갖고 있음 (코드, 데이터, 힙 영역은 공유)
    

## 멀티 스레드와 멀티 프로세스

> 멀티 스레드와 멀티 프로세스는 스택 외 사용자 영역을 공유하는가의 차이
> 

### 멀티 프로세스

: 여러 프로세스를 동시에 실행하는 것

- 각각의 프로세스는 독립적으로 실행됨 ⇒ 특정 프로세스에 문제 생겨도 다른 프로세스 영향 적음

### 멀티 스레드

: 여러 스레드로 프로세스를 동시에 실행하는 것

- 스레드는 프로세스의 자원을 공유 ⇒ 메모리 효율적 & 협력과 통신에 유리함

### 참고. 프로세스 간 통신 (IPC)

> 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 프로세스끼리도 충분히 자원을 공유하고 데이터를 주고받을 수 있다 (스레드에 비해 다소 까다로울 뿐, 불가능한 것은 아님)
> 
- 통신 : 컴퓨터 내의 서로 다른 프로세스나 스레드끼리 데이터를 주고 받는 것 역시 포함
    - 파일 통한 프로세스 간 통신 : 하나의 파일에 대해 읽는 프로세스 & 쓰는 프로세스
    - 공유 메모리 : 공유하는 메모리 영역을 두어 데이터 교환 가능
    - 소켓
    - 파이프

## 문제

### 문제 1: **프로세스 제어 블록(PCB)에는 어떤 정보가 저장되나요?**

**모범 답안:**

PCB에는 프로세스의 관리에 필요한 다양한 정보가 저장됩니다. 주요 정보로는 프로세스 ID(PID), 레지스터 값(프로그램 카운터 포함), 프로세스 상태(준비 상태, 실행 상태, 대기 상태 등), CPU 스케줄링 정보(우선순위 등), 메모리 관리 정보(프로세스가 사용하는 메모리 주소 등), 사용 중인 파일과 입출력 장치 목록이 있습니다. PCB는 운영체제가 프로세스를 관리하고, 문맥 교환 시 필요한 정보를 저장하는 중요한 데이터 구조입니다.

### 문제 1 꼬리 질문

- PCB를 조작하거나 훼손하는 경우 시스템에 어떤 영향을 미칠 수 있을까요?
    
    PCB를 조작하거나 훼손하면 운영체제가 프로세스를 제대로 관리할 수 없게 됩니다. 예를 들어, 프로세스의 상태 정보가 손상되면 운영체제가 잘못된 프로세스를 실행하거나, 프로세스 간의 문맥 교환 시 오류가 발생할 수 있습니다. 이는 시스템 불안정, 프로세스의 비정상 종료, 심지어 시스템 크래시로 이어질 수 있습니다.
    
- PCB가 많아질 경우 시스템 성능에 미치는 영향은 무엇인가요?
    
    PCB(프로세스 제어 블록)가 많아지면 시스템 성능에 여러 가지 부정적인 영향을 미칠 수 있습니다. PCB는 각 프로세스의 정보를 저장하는 데이터 구조로, 운영체제는 이 PCB들을 관리하고 유지해야 합니다. PCB가 많아지면 다음과 같은 문제가 발생할 수 있습니다:
    
    1. **메모리 사용 증가:** PCB는 메모리의 커널 영역에 저장되기 때문에, 많은 PCB가 존재하면 커널 메모리 사용량이 증가합니다. 이로 인해 메모리 자원이 부족해져 전체 시스템 성능이 저하될 수 있습니다.
    2. **스케줄링 오버헤드 증가:** 운영체제는 각 프로세스의 PCB를 관리하며, CPU 스케줄링 시 PCB를 참고합니다. PCB의 수가 많아지면 스케줄링 작업이 복잡해지고, CPU가 어느 프로세스를 실행할지 결정하는 데 더 많은 시간이 소요됩니다. 이는 문맥 교환 시 오버헤드를 증가시키고, 시스템 응답 시간이 길어질 수 있습니다.
    3. **캐시 효율성 저하:** PCB의 수가 많아지면 자주 문맥 교환이 발생할 수 있으며, 이는 CPU 캐시의 효율성을 저하시킬 수 있습니다. 캐시 미스(cache miss)가 늘어나면 메모리 접근 시간이 증가하고, 전체적인 시스템 처리 속도가 느려질 수 있습니다.
    4. **복잡한 관리:** PCB가 많아지면 운영체제가 프로세스들을 관리하고 모니터링하는 데 더 많은 자원을 소비하게 됩니다. 이는 시스템 전반의 관리 복잡성을 증가시키고, 프로세스 간의 자원 경쟁이 심화될 수 있습니다.
    
    따라서, PCB의 수가 많아질 경우 시스템 성능에 부정적인 영향을 미칠 수 있으며, 이를 방지하기 위해서는 적절한 프로세스 관리와 효율적인 스케줄링이 필요합니다.
    

### 문제 2: **문맥 교환(context switching) 과정에서 어떤 일이 일어나나요?**

**모범 답안:**

문맥 교환은 CPU에서 실행 중인 프로세스가 다른 프로세스로 전환될 때 발생하는 과정입니다. 기존 프로세스의 문맥(레지스터 값, 프로그램 카운터, 메모리 정보 등)을 PCB에 저장하고, 새로 실행될 프로세스의 문맥을 PCB에서 복구하여 CPU에서 실행됩니다. 문맥 교환은 여러 프로세스가 빠르게 번갈아 가며 실행되는 환경에서 필수적이며, 이 과정이 너무 자주 발생하면 시스템 성능에 오버헤드가 생길 수 있습니다.

### 문제 2 꼬리 질문

- 문맥 교환 시 오버헤드를 최소화하기 위한 방법은 무엇인가요?
    
    문맥 교환 오버헤드를 최소화하기 위해서는 다음과 같은 방법들이 있습니다:
    
    1. **스케줄링 알고리즘 최적화:** 프로세스의 실행 시간을 최적화하여 문맥 교환 빈도를 줄일 수 있습니다. 예를 들어, CPU 집약적인 작업을 우선 배치하여 프로세스가 더 오랫동안 실행되도록 할 수 있습니다.
    2. **하드웨어 지원:** 최신 CPU는 문맥 교환을 더 빠르게 처리할 수 있도록 하드웨어 수준에서 지원합니다. 이를 활용하면 문맥 교환 시 발생하는 오버헤드를 줄일 수 있습니다.
    3. **스레드 사용:** 프로세스 간 문맥 교환 대신, 스레드 간 문맥 교환을 이용하면 오버헤드를 줄일 수 있습니다. 스레드는 같은 프로세스 내에서 자원을 공유하므로 문맥 교환이 상대적으로 가볍습니다.
- 문맥 교환이 너무 자주 일어날 경우 어떤 문제들이 발생할 수 있을까요?
    
    문맥 교환이 너무 자주 일어나면 시스템 성능에 부정적인 영향을 미칠 수 있습니다. 문맥 교환은 프로세스의 상태를 저장하고 새로운 프로세스의 상태를 복원하는 과정으로, 이 과정은 시간이 걸리며 CPU 자원을 소비합니다. 문맥 교환이 빈번하게 발생하면 실제로 유용한 작업을 수행하기보다는 문맥 교환 자체에 더 많은 시간이 소모되어, 전체적인 시스템 성능이 저하됩니다.
    
    이로 인해 프로세스들이 각자의 작업을 완료하는 데 더 오랜 시간이 걸리게 되고, 시스템의 응답성이 떨어질 수 있습니다. 또한, 자주 발생하는 문맥 교환은 캐시 메모리의 효율성을 감소시키고, 메모리 접근 시간 증가로 이어질 수 있습니다. 따라서, 문맥 교환의 빈도는 적절히 조정되어야 하며, 이를 위해 효율적인 스케줄링 알고리즘이 필요합니다.
    

### 문제 3. 멀티프로세스와 멀티스레딩의 장단점을 비교해보세요.

### 멀티프로세스의 장단점

**장점:**

1. **프로세스 간 독립성:** 각 프로세스는 별도의 메모리 공간을 사용하기 때문에, 한 프로세스에서 문제가 발생해도 다른 프로세스에 영향을 주지 않습니다. 이로 인해 안정성이 높아집니다.
2. **보안성:** 프로세스 간 메모리가 분리되어 있어, 프로세스 간의 데이터 접근이 제한됩니다. 이를 통해 보안이 강화됩니다.
3. **운영체제 지원:** 대부분의 운영체제에서 멀티프로세스를 기본적으로 지원하며, 다양한 IPC(프로세스 간 통신) 방법을 제공합니다.

**단점:**

1. **높은 자원 소비:** 각 프로세스는 독립적인 메모리 공간과 자원을 필요로 하므로, 메모리와 CPU 사용량이 증가합니다.
2. **문맥 교환 오버헤드:** 프로세스 간 문맥 교환이 발생할 때마다 오버헤드가 증가하여, 시스템 성능이 저하될 수 있습니다.
3. **IPC의 복잡성:** 프로세스 간 통신이 상대적으로 복잡하며, 데이터를 주고받기 위한 설정이 필요합니다.

### 멀티스레딩의 장단점

**장점:**

1. **효율적인 자원 사용:** 같은 프로세스 내에서 스레드들이 메모리와 자원을 공유하기 때문에 메모리 사용이 효율적이며, 자원 할당이 적게 필요합니다.
2. **빠른 문맥 교환:** 스레드는 동일한 메모리 공간을 공유하기 때문에 문맥 교환이 상대적으로 빠르며, CPU 스케줄링에 걸리는 시간이 적습니다.
3. **쉬운 통신:** 스레드 간 통신이 비교적 간단하며, 동일한 메모리 공간을 사용하기 때문에 데이터를 공유하는 것이 용이합니다.

**단점:**

1. **동기화 문제:** 스레드들이 같은 메모리 공간을 공유하기 때문에, 동기화 문제(예: Race Condition)가 발생할 가능성이 높습니다. 이를 해결하기 위해서는 추가적인 동기화 기법이 필요합니다.
2. **안정성 문제:** 하나의 스레드에서 문제가 발생하면 전체 프로세스에 영향을 줄 수 있습니다. 예를 들어, 특정 스레드에서의 오류가 전체 프로세스를 크래시 시킬 수 있습니다.
3. **디버깅 어려움:** 멀티스레딩 환경에서는 여러 스레드가 동시에 실행되기 때문에, 디버깅이 복잡하고 어려울 수 있습니다.

**결론:**

멀티프로세스는 안정성과 보안 측면에서 유리하지만, 자원 소비가 많고 통신이 복잡합니다. 반면, 멀티스레딩은 자원 사용이 효율적이고 빠른 성능을 제공하지만, 동기화 문제와 안정성에서 취약할 수 있습니다. 따라서, 시스템 요구사항에 따라 적절한 방식을 선택하는 것이 중요합니다.