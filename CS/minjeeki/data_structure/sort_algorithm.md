# 정렬 알고리즘

## 정렬

: 레코드(정렬 대상)를 필드(대상 특징) 중 하나를 키(기준)로 잡아 키값들의 순서로 레코드를 재배열하는 것

- 정렬 알고리즘에서 살펴봐야 하는 것들
    - 동작 원리 (핵심 개념)
    - 시간 복잡도
    - 장점과 단점(효율적인 상황)

### 안정 정렬과 불안정 정렬

- 안정 정렬 : 동일한 값이 있을 때 그 상대적인 순서가 정렬 이후에도 유지되는 정렬
    - 버블 정렬, 병합 정렬, 삽입 정렬
    - 안정 정렬이 필요한 상황 : 정렬 후에도 원래 순서가 중요한 경우
- 불안정 정렬 : 동일한 값이 있을 때 동일 값에 대한 상대적인 순서가 보장되지 않는 정렬
    - 선택 정렬, 퀵 정렬, 힙 정렬

### 분할 정복 기법 (Divide and Conquer)

: 문제를 작은 하위 문제들로 분할하고, 하위 문제를 독립적으로 해결한 후, 그 결과를 결합해 원래 문제를 해결하는 알고리즘 설계 기법

- 사용 이유 : 복잡한 문제를 보다 간단하게 해결하기 위함
- 분할 정복 기법의 단계
    - 분할 : 충분히 작아질 때까지 하위 문제로 반복적 분할
    - 정복 : 하위 문제들을 재귀적으로 해결 (충분히 작아졌을 경우 직접 해결 가능)
    - 결합 : 해결된 하위 문제들의 결과를 결합해 원래 문제의 해를 얻음
- 분할 정복 알고리즘
    - 정렬 : 퀵 정렬, 병합 정렬
    - 이진 탐색
    - 거듭 제곱

## 주요 정렬 알고리즘

### 선택 정렬

- 배열에서 최솟값을 찾아 현재 위치와 교환하는 방식
- 시간 복잡도
    - 평균 : O(n^2)
    - 최악 : O(n^2)

```python
def selection_sort(arr):
    n = len(arr)
    # 각 인덱스마다 최솟값을 찾아 배치해야 하기에 arr의 길이만큼 순회 진행
    for i in range(n):
        min_idx = i
        # i 인덱스 이후 인덱스 순회 => 최솟값 발견 시 인덱스 업데이트
        for j in range(i + 1, n):
            if arr[j] < arr[min_idx]:
                min_idx = j
        # i 인덱스 값과 최솟값의 자리 바꿈 (버블 정렬보다 교환 횟수가 더 적음)
        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
```

### 버블 정렬

- 인접한 두 원소를 비교하여, 필요할 경우 교환을 진행하는 알고리즘
- 시간 복잡도
    - 평균 : O(n^2)
    - 최악 : O(n^2)

```python
def bubble_sort(arr):
    n = len(arr)
    # 인접 원소의 값 비교, 두 원소 관계가 오름차순이 아닐 경우 자리 교환
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

### 삽입 정렬

- 현재 원소를 정렬된 부분에서 적절한 위치에 삽입하는 방식
- 시간 복잡도
    - 배열이 이미 정렬되어 있을 경우 : O(n)
    - 평균 : O(n^2)
    - 최악 : O(n^2)
- 삽입 정렬이 유리한 케이스 : 작은 배열에서는 다른 정렬 알고리즘보다 성능이 좋음

```python
def insertion_sort(arr):
    n = len(arr)
    # 첫번째 요소는 정렬된 상태 가정, 두번째 요소부터 순회
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        # 기준 위치의 앞 요소들과 비교하며 기준 요소보다 큰 요소는 뒤로 이동
        # 각 요소를 본인의 현재 위치에서 갈 수 있는 한 최대한 전진
        while j >= 0 and key < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr
```

### 합병 (병합) 정렬

- 배열을 반으로 나눠 각각 재귀적으로 정렬한 후 정렬된 배열을 병합하는 방식
- 시간 복잡도
    - O(n log n)
- 장점과 단점
    - 장점 : 큰 데이터를 다룰 때 성능이 좋음
    - 단점 : 추가적인 메모리 공간이 필요함

```python
def merge_sort(arr):
		# 배열 길이가 1인 경우는 이미 정렬된 형태이기에 그대로 반환
		# 배열 길이가 1 이상인 경우부터 작업 진행
    if len(arr) > 1:
	   # 쪼개기
		    # 배열의 크기 기반 중간 위치 찾기
        mid = len(arr) // 2
        # 배열을 중간 위치 기준 왼쪽 슬라이싱 배열, 오른쪽 슬라이싱 배열 생성
        L = arr[:mid]
        R = arr[mid:]
        # 각 슬라이싱 배열을 merge_sort에 재귀적으로 호출 : 가장 작은 단위로 쪼갬
        merge_sort(L)
        merge_sort(R)
		# 합치기
        i = j = k = 0
        # 슬라이싱 배열 중 하나가 끝날때까지 진행
        # 왼쪽 배열과 오른쪽 배열 중 작은 요소를 arr 원본에 추가
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
				# 요소가 남아있는 배열에 대한 작업 (어떤 배열이 남아있냐에 따라 while문 실행)
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1
    return arr
```

### 퀵 정렬

- ‘피벗’을 선택하고, 피벗 기준 작은 원소와 큰 원소로 나누는 방식
- 시간 복잡도
    - 평균 : O(n log n)
    - 최악 : O(n^2)
    ⇒ 피벗을 최악으로 선택될 경우
- 퀵 정렬은 피벗을 어떻게 선택하는가에 따라 시간 복잡도의 차이 존재

```python
def quick_sort(arr):
		# 배열 길이가 1 이하인 경우 이미 정렬된 상태이기에 반환
    if len(arr) <= 1:
        return arr
    # 피벗 설정 : 피벗 설정은 선택 방식에 따라 다름 (랜덤 설정, 중간값 설정 등)
    pivot = arr[len(arr) // 2]
    # 피벗보다 작을 경우 left 배열에, 같을 경우 middle 배열에, 클 경우 right 배열에 모음
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    # 피벗보다 작거나 큰 경우 퀵 정렬 재귀 호출
    # 정렬된 상태가 만들어질 경우 결합 연산자로 연결됨 (배열 병합)
    return quick_sort(left) + middle + quick_sort(right)
```

### 계수 정렬

- 원소의 범위가 제한적일 때, 각 원소의 출현 횟수를 세어 정렬
- 시간 복잡도
    - O(n + k)

```python
def counting_sort(arr):
		# 가장 큰 요소값 구하기 (for 카운트 배열 크기 결정 / 카운트 배열 : 각 숫자의 등장 횟수)
    max_val = max(arr)
    count = [0] * (max_val + 1)
    for num in arr:
        count[num] += 1
    # 크기에 따라 구분된 배열을 다시 순회하며 병합
    sorted_arr = []
    for i, c in enumerate(count):
        sorted_arr.extend([i] * c)
    return sorted_arr
```

## 정렬 알고리즘 관련 질문 리스트

### 1. 안정 정렬과 불안정 정렬에 대해서 설명하고, 안정 정렬이 필요한 상황에 대해서 설명하세요.

- chatGPT 답변
    
    안정 정렬(Stability Sorting)란 동일한 키 값을 가진 요소들이 정렬된 후에도 원래의 상대적인 순서를 유지하는 정렬 알고리즘을 말합니다. 예를 들어, 키 값이 동일한 두 요소가 정렬 전에 A와 B 순서로 있다면, 정렬 후에도 A와 B의 순서는 유지됩니다. 대표적인 안정 정렬 알고리즘으로는 버블 정렬(Bubble Sort), 삽입 정렬(Insertion Sort), 병합 정렬(Merge Sort) 등이 있습니다.
    
    반면에 불안정 정렬(Unstable Sorting)란 동일한 키 값을 가진 요소들이 정렬 후에 원래의 상대적인 순서가 보장되지 않는 정렬 알고리즘입니다. 예를 들어, 정렬 전에 A와 B 순서로 있던 두 요소가 정렬 후에 B와 A 순서로 바뀔 수 있습니다. 대표적인 불안정 정렬 알고리즘으로는 선택 정렬(Selection Sort), 힙 정렬(Heap Sort), 퀵 정렬(Quick Sort) 등이 있습니다.
    
    안정 정렬이 필요한 상황은 다음과 같습니다:
    
    1. **다중 키 정렬(Multi-key Sorting)**: 여러 개의 키를 기준으로 데이터를 정렬해야 하는 경우, 첫 번째 키로 정렬한 후 두 번째 키로 다시 정렬할 때, 안정 정렬을 사용하면 첫 번째 키의 정렬 순서가 유지되므로 원하는 정렬 결과를 얻을 수 있습니다.
    2. **레코드 관리 시스템**: 데이터베이스나 레코드 관리 시스템에서 데이터를 정렬할 때, 동일한 키를 가진 레코드의 상대적 순서를 유지해야 하는 경우가 많습니다. 예를 들어, 동일한 날짜의 트랜잭션을 시간 순으로 유지해야 할 때 안정 정렬이 필요합니다.
    3. **사용자 경험**: 사용자가 정렬된 리스트를 볼 때, 동일한 값을 가진 항목들이 정렬 전의 순서를 유지하면 사용자가 더 직관적으로 데이터를 이해할 수 있습니다. 예를 들어, 이름으로 정렬한 후 나이로 다시 정렬하는 경우, 동일한 나이의 사람들은 원래 이름 순서가 유지되는 것이 더 자연스럽습니다.

### 2. 퀵 정렬에서 피벗 선택이 중요한 이유를 알려주세요.

- chatGPT 답변
    
    피벗 선택이 중요한 이유는 다음과 같습니다.
    
    1. **시간 복잡도에 미치는 영향**: 퀵 정렬의 평균 시간 복잡도는 O(nlog⁡n)O(n \log n)O(nlogn)이지만, 피벗 선택이 좋지 않은 경우 최악의 시간 복잡도는 O(n2)O(n^2)O(n2)이 됩니다. 예를 들어, 이미 정렬된 배열에서 항상 첫 번째 요소를 피벗으로 선택하면, 매번 한쪽 부분 배열의 크기가 0이 되고 다른 쪽 부분 배열의 크기가 n−1n-1n−1이 되므로, 분할이 비효율적으로 이루어집니다. 이는 최악의 경우를 초래하게 됩니다.
    2. **균형 잡힌 분할**: 이상적인 피벗은 배열을 균등하게 두 부분으로 나누는 것입니다. 피벗이 배열의 중앙값에 가깝다면, 분할된 두 부분의 크기가 거의 같아지므로, 재귀 호출 깊이가 최소화되고, 이는 퀵 정렬의 성능을 최적화합니다. 균형 잡힌 분할은 퀵 정렬의 평균 시간 복잡도를 보장하는 중요한 요소입니다.
    3. **재귀 호출의 깊이**: 퀵 정렬은 재귀 호출을 사용하여 부분 배열을 정렬합니다. 피벗이 잘 선택되면 재귀 호출의 깊이가 얕아져 스택 오버플로(stack overflow)의 위험이 줄어듭니다. 이는 특히 큰 배열을 정렬할 때 중요한 요소입니다.
    
    피벗을 선택하는 일반적인 방법으로는 다음과 같은 기법들이 있습니다:
    
    - **첫 번째 요소 또는 마지막 요소 선택**: 간단하지만, 이미 정렬된 배열에서는 최악의 경우를 초래할 수 있습니다.
    - **임의 요소 선택**: 배열에서 무작위로 선택하는 방법으로, 평균적으로 균형 잡힌 분할을 유도할 수 있습니다.

### 3. 병합정렬의 작동 원리와 장단점에 대해서 설명해주세요.

- chatGPT 답변
    
    **병합 정렬(Merge Sort)의 작동 원리:**
    
    병합 정렬은 분할 정복(Divide and Conquer) 알고리즘의 한 예로, 다음과 같은 단계로 작동합니다:
    
    1. **분할(Divide)**: 정렬할 배열을 절반으로 나누어 두 개의 하위 배열로 분할합니다. 이 과정을 배열의 크기가 1이 될 때까지 재귀적으로 반복합니다. 배열의 크기가 1인 경우, 이는 이미 정렬된 상태로 간주합니다.
    2. **정복(Conquer)**: 각 하위 배열을 재귀적으로 병합 정렬을 사용하여 정렬합니다.
    3. **병합(Merge)**: 두 개의 정렬된 하위 배열을 하나의 정렬된 배열로 병합합니다. 이 과정에서 두 하위 배열의 요소를 하나씩 비교하면서 정렬된 순서로 새 배열에 추가합니다.
    
    이 과정이 재귀적으로 반복되면서 최종적으로 정렬된 배열이 완성됩니다.
    
    **병합 정렬의 장점:**
    
    1. **안정 정렬(Stable Sort)**: 병합 정렬은 안정 정렬로, 동일한 키 값을 가진 요소들의 상대적인 순서가 정렬 후에도 유지됩니다. 이는 특정 상황에서 매우 중요한 특성입니다.
    2. **시간 복잡도 보장**: 병합 정렬의 시간 복잡도는 항상 O(nlog⁡n)O(n \log n)O(nlogn)으로, 최선, 평균, 최악의 경우 모두 동일합니다. 이는 다른 정렬 알고리즘에 비해 일관된 성능을 보장합니다.
    3. **외부 정렬에 적합**: 병합 정렬은 데이터를 디스크에 저장하고, 메모리에서 처리할 수 없는 큰 데이터를 정렬하는 외부 정렬에 적합합니다. 부분 배열을 병합하는 방식이기 때문에, 데이터를 블록 단위로 읽고 쓸 수 있습니다.
    
    **병합 정렬의 단점:**
    
    1. **공간 복잡도(Space Complexity)**: 병합 정렬은 추가적인 배열을 사용하여 병합 과정을 수행하므로, O(n)O(n)O(n)의 추가적인 공간이 필요합니다. 이는 메모리 사용량이 중요한 환경에서 단점으로 작용할 수 있습니다.
    2. **비교 횟수와 데이터 이동**: 병합 과정에서 많은 비교와 데이터 이동이 발생합니다. 이는 배열이 크지 않은 경우 다른 알고리즘에 비해 비효율적일 수 있습니다.
    3. **구현 복잡성**: 병합 정렬은 다른 단순한 정렬 알고리즘에 비해 구현이 더 복잡할 수 있습니다. 특히 재귀적인 병합 과정과 추가적인 배열 관리가 요구됩니다.
    
    결론적으로, 병합 정렬은 안정 정렬을 제공하며, 시간 복잡도가 일관되어 큰 데이터를 정렬하는 데 적합합니다. 그러나 추가적인 메모리 사용과 비교적 복잡한 구현이 필요하다는 단점이 있습니다. 따라서 특정 상황에 따라 병합 정렬을 사용하는 것이 유리할 수 있습니다.
    

### 4. 병합 정렬과 퀵 정렬의 차이점에 대해서 설명해주세요.

- 답변
    - 구분 기준
        - 퀵 정렬 : 피벗
        - 병합 정렬 : 배열의 중간값
    - 시간 복잡도
        - 퀵 정렬 : 피벗 선택에 따라 복잡도 차이 존재
        - 병합 정렬 : 모든 경우 동일한 O(n log n) 복잡도 가짐
    - 공간 복잡도
        - 퀵 정렬 : in-place 알고리즘 (추가 배열 생성 X) / 재귀적 호출을 기반으로 스택 공간 이용
            
            ⇒ 메모리 적게 사용
            
        - 병합 정렬 : 추가 배열을 이용해 하위 배열을 병합
            
            ⇒ 메모리 추가 사용
            
    - 안정성
        - 퀵 정렬 : 불안정 정렬 ⇒ 정렬 후 상대적 순서 유지 보장 안함
        - 병합 정렬 : 안정 정렬
- chatGPT 답변
    
    퀵 정렬과 병합 정렬의 차이점을 설명드리겠습니다.
    
    퀵 정렬은 피벗을 선택하여 배열을 두 부분으로 나누고, 각 부분을 재귀적으로 정렬하는 방식입니다. 평균적으로 매우 빠르며, 메모리를 적게 사용하지만 최악의 경우 시간 복잡도가 O(n2)O(n^2)O(n2)이 될 수 있습니다. 또한, 퀵 정렬은 불안정 정렬로 동일한 값을 가진 요소들의 상대적인 순서가 보장되지 않습니다.
    
    병합 정렬은 배열을 절반으로 나누어 각각을 재귀적으로 정렬한 후, 두 정렬된 하위 배열을 병합하는 방식입니다. 병합 정렬의 시간 복잡도는 항상 O(nlog⁡n)O(n \log n)O(nlogn)으로 안정적이지만, 추가적인 메모리 공간이 필요합니다. 병합 정렬은 안정 정렬로, 동일한 값을 가진 요소들의 상대적인 순서가 유지됩니다.
    
    따라서, 퀵 정렬은 일반적으로 더 빠르고 메모리를 적게 사용하지만, 최악의 경우 성능이 떨어질 수 있으며 불안정 정렬이라는 단점이 있습니다. 반면에, 병합 정렬은 일관된 성능을 제공하고 안정 정렬이라는 장점이 있지만, 추가적인 메모리 공간이 필요합니다. 상황에 따라 두 알고리즘을 적절히 선택하여 사용하는 것이 중요합니다.
    
    4o