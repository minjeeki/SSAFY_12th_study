# 선형 자료구조 (스택, 큐)

## 스택

: LIFO (선입 후출) 원칙을 따르는 선형 자료 구조

- 스택 용어
    - top : 스택의 맨 위 (입출력이 일어나는 곳)
- 스택의 삽입, 삭제 (입출력)은 모두 같은 위치(top)에서 일어난다

### 스택 ADT

- 객체 : 0개 이상의 요소를 가지는 선형 리스트 (배열 또는 연결리스트를 통해 구현)
- 연산
    - 스택 생성
    - 스택 초기화
    - 스택에 요소 추가 (push)
        - 스택이 모두 차있는 상황에서 push 수행 시 오류 발생
    - 스택에 요소 삭제 (pop)
        - 스택이 모두 비어있는 상황에서 pop 수행 시 오류 발생
- 현재 스택 상태 검사
    - 스택이 가득 차있는지 확인 (is_full)
    - 스택이 비어있는지 확인 (is_empty)
    - 스택의 맨 위(top) 요소를 확인 (peek)

### 스택 구현 - 배열 / 연결 리스트

> 내부 구현을 어떤 자료구조를 이용하는가에 상관없이 제공되는 인터페이스는 스택으로 동일
> 
> 
> ⇒ 선형의 자료구조 & top에서 삽입, 삭제 연산 진행
> 
- 배열을 이용한 스택 구현
    - 기본 동작
        - top : 요소가 차있는 인덱스 중 가장 큰 인덱스
        - 삽입 : top 변수 + 1 ⇒ top 인덱스에 값 추가,
        - 삭제 : top 인덱스에 해당하는 값 삭제 ⇒ top 변수 - 1
    - 장/단점
        - 장점 : 구현 간단하고 성능 (삽입, 삭제 연산에 대한 시간) 우수
        - 단점 : 스택의 크기가 고정
- 연결 리스트를 이용한 스택 구현
    - 기본 동작
        - top : top 노드 생성 → 가장 마지막으로 추가된 노드의 링크 필드에 top 노드 연결
        - 삽입 : 새 노드 생성 → 가장 마지막 노드의 top 노드 연결 대신 해당 노드 연결 → 새 노드 링크 필드에 top 노드 연결
        - 삭제 : 가장 마지막 노드의 앞에 있는 노드의 링크 필드를 top 노드에 연결
    - 장/단점
        - 장점 : 스택의 크기를 필요에 따라 가변적으로 조절 가능 (크기를 제한하지 않아도 됨)
        - 단점 : 구현 복잡, 배열 구현에 비해 메모리 소모가 많음

### 스택 응용

> 스택은 컴퓨터에서 믿을 수 없을 정도로 많이 사용되는 자료구조
> 
> 
> ⇒ “자료의 출력 순서가 입력 순서의 역순으로 이뤄져야 할 때” 많이 사용
> 
- 스마트폰의 ‘뒤로 가기’
- 함수의 중첩 호출 (호출된 이후 해당 함수가 호출된 위치로 돌아가야 함)
- 미로 탐색 알고리즘 (과정을 진행하다가 막다른 길에 도달할 경우 다시 교차점까지 되돌아감)

### 동적 배열 스택

## 큐

: FIFO 원칙을 따르는 선형 자료 구조

- 큐 용어
    - front : 큐에서 삭제가 일어나는 곳
    - rear : 큐에서 삽입이 일어나는 곳
- 큐의 삽입, 삭제 (입출력)은 다른 위치에서 일어난다

### 큐 ADT

- 객체 : 0개 이상의 요소를 가지는 선형 리스트 (배열 또는 연결리스트를 통해 구현)
- 연산
    - 큐 생성
    - 큐 초기화
    - 큐에 요소 추가 (enqueue)
        - 큐가 모두 차있는 상황에서 enqueue 수행 시 오류 발생
    - 큐에 요소 삭제 (dequeue)
        - 큐가 모두 비어있는 상황에서 dequeue 수행 시 오류 발생
- 현재 큐 상태 검사
    - 큐가 가득 차있는지 확인 (is_full)
    - 큐가 비어있는지 확인 (is_empty)
    - 큐의 맨 앞(front) 요소를 확인 (peek)

### 선형 큐와 원형 큐

> 선형 큐와 원형 큐의 주된 차이점은 메모리 사용, 구현 방식이 있음
> 
- 선형 큐
    
    : 선형적으로 데이터를 저장
    
    - 배열로 구현할 경우 : 데이터 제거 시 앞쪽의 공간이 비어 메모리 낭비 발생
    (요소를 앞으로 이동하는 등의 추가적인 작업 필요)
    - 연결리스트로 구현할 경우 : 메모리 낭비 문제를 해결되나 구현이 복잡해짐
    - 응용 : 작업 스케줄링
- 원형 큐
    
    : 배열을 사용해 원형으로 데이터를 저장 (실제 원형이 아닌 개념상 원형)
    
    - 배열의 시작과 끝이 연결된 것처럼 동작
        - front == rear의 경우 원형 큐가 비어있음을 의미
        - 포화 상태와 공백 상태 구별을 위해서 하나의 자리는 비워둠
        (포화되어 한바퀴를 돌았을 경우 빈 자리가 없다면 front == rear가 됨)
    - 배열의 처음과 끝이 연결되어 있기에 메모리 공간을 효율적으로 사용할 수 있음
        
        (데이터 제거된 이후에도 빈 공간 재사용 가능)
        
    - 인덱스 관리가 복잡해질 수 있음 ⇒ front와 rear를 원형으로 회전 시켜야 함
        
        (% 연산자를 이용해서 구현 가능)
        

### 큐 응용

- 대기열, 이륙 비행기, 인터넷 전송 데이터 패킷 모델링 등
- 컴퓨터와 주변기기 사이에는 항상 큐가 존재한다 ⇒ 버퍼 역할을 수행함
(컴퓨터의 CPU와 주변 기기 사이 속도 차이가 있기 때문)
- BFS (너비 우선 탐색) 등에서 활용

### 덱 (double-ended queue)

: 큐의 front와 rear에서 모두 삽입과 삭제가 가능한 큐 (중간에서의 삽입, 삭제는 불가함)

- 연산
    - 덱 생성
    - 덱 초기화
    - 덱에 요소 추가
        - 덱의 앞단(front)에 추가 (add_front)
        - 덱의 뒷단(rear)에 추가 (add_rear)
    - 큐에 요소 삭제
        - 덱의 앞단에서 삭제 (delete_front)
        - 덱의 뒷단에서 삭제 (delete_rear)
- 현재 큐 상태 검사
    - 큐가 가득 차있는지 확인 (is_full)
    - 큐가 비어있는지 확인 (is_empty)
    - 큐의 맨 앞(front) / 뒷단(rear) 요소를 확인 (get_front / get_rear)
- 덱 구현
    - 배열을 이용한 구현
        - 원형 큐를 확장할 경우 덱 역시 손쉽게 구현 가능
        - 선형 큐를 이용할 경우 메모리 낭비의 문제가 계속 발생
    - 연결리스트를 이용한 구현
        - 연결된 스택이나 큐에 비해 더 복잡
        - 이중 연결리스트로 구현하는 것이 필요
- 활용 : 회전 버퍼, 탐색 알고리즘 최적화, 슬라이딩 윈도우 등

### 우선순위 큐

: FIFO 원칙을 따르고 있지만 우선순위에 따라 처리 순서가 결정되는 특수한 형태의 큐

- 우선순위 큐는 배열 / 연결 리스트 / 힙을 이용하며 일반적으로 힙을 가장 많이 이용한다
    - 배열 / 연결 리스트를 사용하는 경우
        - 삽입 연산 : O(1) ⇒ 가장 뒤에 삽입
        - 삭제 연산 : O(n) ⇒ 우선순위가 가장 높은 것을 찾아야 하기에 전체 조회 필요
    - 히프를 사용하는 경우
        - 힙 : 완전 이진 트리의 일종
        - 삽입 연산 : O(log n) ⇒ 느슨한 정렬 상태를 유지해야 하기에 부모 노드와 관계 확인 거침
        - 삭제 연산 : O(log n) ⇒ 느슨한 정렬 상태를 이용해 모든 노드 조회 필요 없음
        (전체 높이가 log_2 n이기 때문)
- 활용 : 다익스트라 알고리즘, 네트워크 트래픽 관리, 작업 스케줄링 등

## 선형 자료구조 관련 질문 리스트

### 1. 2개의 stack을 활용해서 하나의 queue를 만드는 방법을 설명하세요. 해당 방식이 직접 queue를 구현하는 것에 비해 이점이 있다면 뭐가 있는지 설명하세요.

- chatGPT의 답변
    
    "2개의 stack을 활용해서 하나의 queue를 만드는 방법은 다음과 같습니다. Stack은 LIFO(Last In First Out) 구조로 동작하고 Queue는 FIFO(First In First Out) 구조로 동작하는데, 이를 결합하기 위해 두 개의 stack, stack1과 stack2를 사용합니다. 요소를 enQueue(삽입)할 때는 stack1에 push하고, 요소를 deQueue(삭제)할 때는 stack2에서 pop합니다. 만약 stack2가 비어 있다면, stack1의 모든 요소를 stack2로 옮긴 후 stack2에서 pop합니다. 이를 구현한 간단한 코드는 다음과 같습니다
    
    ```python
    class QueueUsingStacks:
        def __init__(self):
            self.stack1 = []
            self.stack2 = []
    
        def enQueue(self, item):
            self.stack1.append(item)
    
        def deQueue(self):
            if not self.stack2:
                while self.stack1:
                    self.stack2.append(self.stack1.pop())
            return self.stack2.pop() if self.stack2 else None
    
    ```
    
    enQueue 연산의 시간 복잡도는 O(1)이고, deQueue 연산은 최악의 경우 O(n)입니다. 그러나 평균적으로 각 요소는 한 번만 이동하기 때문에 사실상 O(1)에 가깝습니다. 이 방법은 특히 데이터 입력과 출력의 빈도가 다른 경우 유용합니다.
    
- 포인트 요약
    - 큐의 enqueue 작업 : stack1에서 push
        - 시간 복잡도 : O(1)
    - 큐의 dequeue 작업 : stack2에서 pop
        - 만약 stack2가 비어있을 경우 stack1의 모든 요소를 stack2로 옮긴 뒤 stack2에서 pop
        - 시간 복잡도 : 최악의 경우 O(n), 각 요소는 평균적으로 한번만 이동하기에 사실상 O(1)
    - 이점
        - 큐를 직접 구현하는 것은 스택을 구현하는 것에 비해 복잡하고,
        배열만을 이용해 선형 큐를 구현할 경우 메모리 낭비의 문제가 생긴다
        연결 리스트를 사용하더라도 노드의 링크 필드로 인해 배열보다 메모리 소모가 많다
        - 스택을 이용해 큐를 구현할 경우 스택의 기본 연산인 push, pop만으로 큐의 동작을 구현할 수 있어 코드가 간단하다, 또한 이미 스택을 사용하는 환경에서 큐 기능을 추가할 수 있다

### 2. 큐와 덱의 차이점에 대해서 설명해주세요.

- chatGPT의 답변
    
    큐(Queue)와 덱(Deque)는 둘 다 선형 자료구조이지만, 동작 방식과 사용 목적에 있어서 차이가 있습니다.
    
    먼저 큐는 FIFO(First In, First Out) 원칙을 따릅니다. 즉, 먼저 들어온 요소가 먼저 나가는 구조입니다. 큐에서는 요소가 한 쪽 끝에서 삽입되고, 반대쪽 끝에서 제거됩니다. 일반적으로 큐는 넓이 우선 탐색(BFS)이나 프로세스 관리에서 사용됩니다.
    
    반면에 덱(Deque, Double-ended Queue)는 양쪽 끝에서 삽입과 제거가 모두 가능한 자료구조입니다. 덱은 스택과 큐의 특성을 모두 가질 수 있어, 다양한 시나리오에서 유연하게 사용할 수 있습니다. 예를 들어, 덱은 슬라이딩 윈도우 문제나 최적화된 접근이 필요한 문제에서 사용됩니다.
    
    큐와 덱의 시간 복잡도는 대부분의 연산에 있어서 O(1)을 보장하지만, 사용하는 연산의 종류에 따라 적절한 자료구조를 선택하는 것이 중요합니다. 큐는 단방향 접근에 유리하며, 덱은 양방향 접근이 필요한 경우 유리합니다.
    

### 3. 선형 큐를 배열과 연결 리스트를 이용해서 구현할 경우 삽입, 삭제, 조회에 대한 시간 복잡도 차이가 어떻게 되는지 설명해주세요.

- 답변
    
    배열 기반 큐는 삽입이 일반적으로 빠르지만 삭제가 느린 반면, 연결 리스트 기반 큐는 삽입과 삭제가 모두 빠릅니다. 조회는 두 경우 모두 O(1)로 동일합니다.
    
    배열로 큐를 구현할 경우
    
    - 삽입 연산은 배열의 끝에 새로운 요소를 추가하는 것이기에 평균적으로 O(1)의 시간 복잡도를 갖는다. 하지만 배열의 크기가 고정되어 있는 경우 크기를 초과할 경우 배열을 재할당해야 하기 때문에 최악의 경우 O(n)의 시간 복잡도가 발생할 수 있다.
    - 삭제 연산은 첫번째 요소를 삭제하고 나머지 요소들을 앞으로 한칸씩 이동해야 하므로 O(n)의 시간 복잡도를 갖는다.
    
    연결 리스트로 큐를 구현할 경우
    
    - 삽입 연산에 대한 시간복잡도 계산은 tail 포인터의 유무에 따라 차이를 보인다. tail 포인터가 있을 경우 O(1)의 시간 복잡도를 가지나, tail 포인터가 없는 경우 마지막 요소를 찾기 위해 리스트를 순회해야 하므로 O(n)의 시간 복잡도를 가진다.
    - 삭제 연산의 경우 연결 리스트의 첫번째 요소를 삭제하는 것이기 때문에 O(1)의 시간 복잡도를 가진다.
    
    조회 연산의 경우 구현 방식에 상관 없이 첫번째 인덱스, 첫번째 노드의 요소를 확인하는 것이기에 O(1)의 시간복잡도를 가진다.