# 리스트 (배열 리스트, 연결 리스트)

![자료구조 가계도](/CS/minjeeki/data_structure/list/Untitled.png)

## 리스트

### 배열 리스트 (Array List)

- 데이터를 연속된 메모리 공간에 저장해 인덱스를 통해 각 데이터를 가리키는 형태로 구성된 선형 자료 구조
- 배열의 특징
    - 임의 접근 가능
    : 배열의 인덱스를 통해 어떤 원소든 즉시 접근할 수 있다.
    - 수정 시 비효율적
    : 원소의 추가나 삭제에는 전체 구조를 변경해야 하므로 시간이 소요된다.
    - 다양한 용도
    : 스택, 큐, 힙, 해시테이블, 행렬 등의 기본 구조로 활용
    - 정렬 알고리즘 구현에 배열이 자주 사용됨

### 연결 리스트 (Linked List)

- 데이터를 연속된 메모리 공간에 저장하지 않고, 각 데이터가 다음 데이터의 위치를 가리키는 형태로 구성된 선형 자료 구조
    - 노드
        
        : 각 데이터 단위
        
        - 노드에는 다음 노드를 가리키는 참조(주소)를 저장한다
- 연결 리스트의 특징
    - 동적 배열
    : 크기를 동적으로 조절할 수 있다
    - 삽입과 삭제의 용이성
    : 시작점이나 중간에 새로운 노드를 추가하거나
      기존 노드를 제거하는 것이 배열에 비해 간단
- 연결 리스트가 적합한 케이스
    - 자료의 양이 정해져 있지 않은 경우
    - 자료를 추가하거나 삭제하는 작업이 많은 경우
- 파이썬에서의 연결 리스트 구현
    
    : 파이썬에서는 모든 것이 객체이며, 변수는 객체를 참조하는 역할을 하기에 연결리스트의 구현도 간단히 객체 지향적으로 접근할 수 있다.
    
    ![Untitled](/CS/minjeeki/data_structure/list/Untitled%201.png)
    
    ```python
    # 노드 클래스 정의
    class Node:
    	def __init__(self, data):
    		self.data = data    #data : 값을 가리키는 변수 (속성)
    		self.next = None    #next : 다음 노드를 가리키는 변수
    
    # 노드 생성
    head = Node(1)
    head.next = Node(2)
    head.next.next = Node(3)
    
    # 연결 리스트 출력
    node = head    # 시작 위치 지정
    while node:    # node가 None일 경우 False로 종료
    	print(node.data, end = ' ')
    	node = node.next    # 다음 node를 가리킴
    	
    # 연결 리스트 끝에 새 노드 추가 : head부터 순차적으로 이동하며 끝 도달
    node = head
    while node:
    	if node.next is None:
    		node.next = Node(4)
    		break
    	node = node.next
    	
    # 연결 리스트 앞에 새 노드 추가
    node = Node(0)
    node.next = head
    head = node
    ```
    

### 배열 리스트와 연결 리스트의 차이

> 차이를 비교하는 이유는 상황에 따라 어떤 리스트를 사용하는 것이 유리한지를 판단하기 위함
> 
- 특징 비교
    
    ![Untitled](/CS/minjeeki/data_structure/list/4e68fbe7-d8d4-4496-b980-262f55f192f5.png)
    
- 시간 복잡도 차이
    
    ![Untitled](/CS/minjeeki/data_structure/list/Untitled%202.png)
    

### 파이썬의 리스트는 동적 배열이다

: 파이썬에서는 리스트를 동적 배열로 사용할 수 있다.

- 파이썬의 리스트
    - 연속한 메모리에 객체(objects)의 주소를 저장한다 (파이썬의 모든 것은 객체이기 때문)
    - 같은 자료형 뿐만 아니라 다양한 자료(객체)를 저장할 수 있다
    - 배열처럼 인덱스로 각 객체(자료)에 접근할 수 있고 슬라이싱할 수 있다.
    
    > 리스트의 요소는 연속한 메모리에 있지 않지만 각 객체의 메모리 주소는 연속한 메모리에 저장되어 있어 배열처럼 인덱싱으로 각 원소에 접근할 수 있다.
    > 

## 레퍼런스

- [[책] 좌충우돌, 파이썬으로 자료구조 구현하기](https://wikidocs.net/book/9059) - 3장. 파이썬으로 연결 리스트 구현하기
- [[웹] 팔만코딩경 ‘[자료구조] 리스트’](https://www.notion.so/bd56568457ad4a5e8c670114ced825b8?pvs=21)
- [[웹] 팔만코딩경 ‘배열 vs 연결 리스트’](https://www.notion.so/vs-5f1a4f9f25d14a3b9236e6d6cc9f8bb8?pvs=21)

## 질문

### 1. 배열 리스트와 연결 리스트의 차이를 기반으로 각각의 자료구조가 유리한 상황 1개씩 설명해주세요.

- chatGPT 답변
    
    배열 리스트와 연결 리스트는 각각의 구조와 특성에 따라 특정 상황에서 유리한 점이 있습니다.
    
    1. **배열 리스트가 유리한 상황**:
        - **빠른 접근이 필요한 경우**: 배열 리스트는 인덱스를 통해 O(1) 시간 복잡도로 원하는 요소에 접근할 수 있습니다. 따라서 데이터 접근이 빈번하게 발생하는 경우, 예를 들어, 요소의 인덱스를 통해 데이터를 자주 읽어와야 하는 경우 배열 리스트가 유리합니다.
        
        예시: "정렬된 데이터에서 특정 인덱스의 값을 자주 참조해야 하는 경우, 배열 리스트가 유리합니다."
        
    2. **연결 리스트가 유리한 상황**:
        - **빈번한 삽입/삭제가 필요한 경우**: 연결 리스트는 노드의 삽입과 삭제가 O(1)의 시간 복잡도로 이루어지기 때문에, 특정 위치에 빈번하게 데이터를 추가하거나 제거해야 하는 경우에 유리합니다. 배열 리스트는 삽입/삭제 시 해당 위치 이후의 모든 요소를 이동시켜야 하기 때문에 상대적으로 비효율적입니다.
        
        예시: "중간에 데이터를 자주 추가하거나 삭제해야 하는 작업, 예를 들어, 작업 스케줄을 실시간으로 업데이트해야 하는 경우, 연결 리스트가 유리합니다."
        

### 2. 배열 리스트와 연결 리스트의 삽입, 삭제, 조회 동작에 대해서 설명해주세요.

- chatGPT 답변
    
    배열 리스트와 연결 리스트의 삽입, 삭제, 조회 동작은 각각의 자료구조가 가지는 특성에 따라 다릅니다.
    
    ### 배열 리스트
    
    1. **삽입**:
        - **끝에 삽입**: 배열의 끝에 요소를 추가하는 것은 O(1)의 시간 복잡도를 가집니다.
        - **중간에 삽입**: 특정 위치에 요소를 삽입하려면 해당 위치 이후의 모든 요소를 한 칸씩 뒤로 이동시켜야 합니다. 따라서 최악의 경우 O(n)의 시간 복잡도를 가집니다.
    2. **삭제**:
        - **끝에서 삭제**: 배열의 끝에서 요소를 제거하는 것은 O(1)의 시간 복잡도를 가집니다.
        - **중간에서 삭제**: 특정 위치의 요소를 삭제하려면 해당 위치 이후의 모든 요소를 한 칸씩 앞으로 이동시켜야 합니다. 따라서 최악의 경우 O(n)의 시간 복잡도를 가집니다.
    3. **조회**:
        - 배열 리스트는 인덱스를 통해 직접 접근이 가능하므로 조회는 O(1)의 시간 복잡도를 가집니다.
    
    ### 연결 리스트
    
    1. **삽입**:
        - **처음에 삽입**: 연결 리스트의 첫 번째 위치에 삽입하는 것은 O(1)의 시간 복잡도를 가집니다.
        - **중간에 삽입**: 특정 위치에 삽입하려면 그 위치까지 순차적으로 접근해야 하므로 최악의 경우 O(n)의 시간 복잡도를 가집니다. 그러나 해당 위치를 이미 알고 있는 경우, 삽입 자체는 O(1)입니다.
    2. **삭제**:
        - **처음에서 삭제**: 연결 리스트의 첫 번째 위치의 요소를 제거하는 것은 O(1)의 시간 복잡도를 가집니다.
        - **중간에서 삭제**: 특정 위치의 요소를 삭제하려면 그 위치까지 순차적으로 접근해야 하므로 최악의 경우 O(n)의 시간 복잡도를 가집니다. 그러나 해당 위치를 이미 알고 있는 경우, 삭제 자체는 O(1)입니다.
    3. **조회**:
        - 연결 리스트는 인덱스를 통한 직접 접근이 불가능하므로 조회는 순차적으로 접근해야 하며 최악의 경우 O(n)의 시간 복잡도를 가집니다.
    
    이처럼 배열 리스트는 빠른 조회가 필요할 때 유리하고, 연결 리스트는 빈번한 삽입과 삭제가 필요할 때 유리합니다. 각 자료구조의 특성을 잘 이해하여 상황에 맞게 선택하는 것이 중요합니다.
    

### 3. Dynamic List에 대해 알고 있다면 어떤 자료구조인지, 알고 있는 예시가 있다면 설명해주세요

- chatGPT 답변
    
    Dynamic List는 크기가 가변적인 배열을 이용해 구현된 자료구조로, 필요에 따라 자동으로 크기가 조정되는 배열 리스트를 의미합니다. 일반적으로 동적 배열(dynamic array)이라고도 합니다.
    
    ### 특징
    
    - **가변 크기**: 초기에는 작은 크기로 시작하지만, 요소가 추가되어 배열의 크기를 초과할 경우 자동으로 더 큰 배열을 할당하고 기존 요소를 복사합니다.
    - **빠른 접근 시간**: 배열과 마찬가지로 인덱스를 통해 O(1) 시간 복잡도로 요소에 접근할 수 있습니다.
    - **효율적인 메모리 사용**: 처음에는 작은 메모리 공간을 사용하다가 필요에 따라 증가시키므로, 메모리 사용 효율이 높습니다.
    
    ### 예시
    
    1. **Java의 ArrayList**:
        - `ArrayList`는 Java의 표준 라이브러리에서 제공하는 동적 배열 클래스입니다. 초기에는 기본 크기로 배열을 생성하고, 요소가 추가될 때 배열의 크기가 부족해지면 크기를 두 배로 증가시킵니다.
        
        ```java
        java코드 복사
        import java.util.ArrayList;
        
        public class Example {
            public static void main(String[] args) {
                ArrayList<Integer> list = new ArrayList<>();
                list.add(1);
                list.add(2);
                list.add(3);
                System.out.println(list); // 출력: [1, 2, 3]
            }
        }
        
        ```
        
    2. **Python의 list**:
        - Python의 `list`는 동적 배열로 구현되어 있습니다. 리스트의 크기가 초과될 때마다 내부적으로 크기를 두 배로 증가시키는 방식으로 동작합니다.
        
        ```python
        python코드 복사
        my_list = [1, 2, 3]
        my_list.append(4)
        print(my_list) # 출력: [1, 2, 3, 4]
        
        ```
        
    
    ### 동작 원리
    
    1. **초기화**: 처음에는 작은 크기의 배열로 시작합니다.
    2. **확장**: 요소가 추가되어 배열의 크기를 초과할 경우, 보통 현재 배열 크기의 두 배 크기의 새로운 배열을 할당하고, 기존 배열의 요소를 모두 복사합니다.
    3. **추가/삭제**: 배열의 끝에 요소를 추가하거나 삭제하는 작업은 일반적으로 O(1)의 시간 복잡도를 가지지만, 배열 크기 확장이 필요한 경우 O(n)의 시간 복잡도를 가질 수 있습니다.
    4. **조회**: 배열과 마찬가지로 인덱스를 통해 O(1) 시간 복잡도로 접근할 수 있습니다.
    
    Dynamic List는 배열의 장점인 빠른 접근 속도와 연결 리스트의 장점인 가변 크기를 결합한 자료구조로, 많은 프로그래밍 언어에서 표준 라이브러리 형태로 제공되어 널리 사용되고 있습니다.
    

### 파이썬 추가 문제. 자료구조에서 이야기하는 배열 리스트와 파이썬의 리스트의 차이가 뭔지, 차이가 발생하는 이유가 뭔지 설명하세요

- chatGPT 답변
    
    자료구조에서 이야기하는 배열 리스트와 파이썬의 리스트의 차이점과 그 차이가 발생하는 이유에 대해 설명해드릴게요.
    
    ### 배열 리스트 (Array List)
    
    - **정의**: 배열 리스트는 고정된 크기의 연속된 메모리 블록에 데이터를 저장하는 자료구조입니다.
    - **특징**:
        - **고정 크기**: 배열의 크기는 선언 시에 미리 정해지며, 이후 변경할 수 없습니다.
        - **빠른 접근 속도**: 인덱스를 통해 특정 위치의 요소에 O(1) 시간 복잡도로 접근할 수 있습니다.
        - **메모리 효율성**: 연속된 메모리 블록을 사용하기 때문에 메모리 접근이 효율적입니다.
        - **비효율적 삽입/삭제**: 배열의 크기를 변경할 수 없기 때문에 삽입이나 삭제 시 배열을 새로 할당하거나, 요소를 이동시키는 과정이 필요하여 O(n) 시간이 걸릴 수 있습니다.
    
    ### 파이썬의 리스트
    
    - **정의**: 파이썬의 리스트는 동적 배열(Dynamic Array)로 구현되어 있으며, 크기를 자동으로 조정할 수 있는 가변 길이의 배열입니다.
    - **특징**:
        - **가변 크기**: 리스트의 크기는 자동으로 조정될 수 있으며, 요소를 추가하거나 제거할 때 리스트의 크기가 동적으로 변경됩니다.
        - **다양한 데이터 타입**: 리스트는 다양한 데이터 타입을 혼합하여 저장할 수 있습니다.
        - **내부 구현**: 파이썬 리스트는 일반적으로 배열 기반으로 구현되지만, 요소 추가/삭제 시 크기를 동적으로 조절하기 위해 여유 공간을 남겨 두는 방식으로 작동합니다. 요소를 추가할 때 여유 공간이 없으면 더 큰 배열을 할당하고 기존 요소를 복사하는 과정을 거칩니다.
        - **접근 속도**: 인덱스를 통한 접근은 O(1) 시간이 걸리지만, 리스트 크기를 조절하는 작업은 평균적으로 O(1) 시간이지만, 최악의 경우 O(n) 시간이 걸릴 수 있습니다.
    
    ### 차이 발생 이유
    
    1. **고정 크기 vs 가변 크기**:
        - 배열 리스트는 고정 크기인 반면, 파이썬 리스트는 동적 크기입니다. 파이썬 리스트는 필요에 따라 자동으로 크기를 조절할 수 있습니다.
    2. **메모리 할당 방식**:
        - 배열 리스트는 연속된 메모리 블록에 데이터를 저장하여 메모리 접근이 효율적입니다.
        - 파이썬 리스트는 요소를 추가할 때마다 크기를 조절할 수 있도록 여유 공간을 할당하여 저장합니다. 이는 메모리 할당과 해제가 빈번하게 발생할 수 있음을 의미합니다.
    3. **유연성**:
        - 배열 리스트는 고정된 크기 때문에 유연성이 떨어집니다.
        - 파이썬 리스트는 다양한 데이터 타입을 저장하고 크기를 동적으로 조절할 수 있어 더 유연하게 사용할 수 있습니다.
    
    이러한 차이점은 배열 리스트가 고정된 크기를 가지는 반면, 파이썬 리스트는 사용자의 편의를 위해 크기를 동적으로 조절할 수 있는 설계 철학에 기인합니다. 따라서 파이썬의 리스트는 사용하기 쉽고 유연하지만, 내부적으로 더 복잡한 메모리 관리 및 동작을 수행합니다.