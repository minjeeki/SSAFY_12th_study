# 해시

- 해싱 사용 케이스 : 컴파일러가 사용하는 심볼 테이블, 철자 검사기, 데이터베이스 등
    
    ⇒ 보통 사전(dictionary) 자료구조 구현 시 최상의 선택
    
    [사전 (dictionary / = map, table)](https://www.notion.so/dictionary-map-table-4d3e8034ebbe48f997ed5d34bb5033db?pvs=21)
    

### 해싱

: 키(key)에 산술적인 연산을 적용하여 항목이 저장되어 있는 테이블의 주소를 계산해 항목 접근

- 해시 테이블 : 키에 대한 연산에 의해 직접 접근이 가능한 구조
- 탐색 키는 문자열이거나 매우 큰 숫자
⇒ 탐색 키를 직접 배열의 인덱스로 사용하기에는 무리가 있음
⇒ 탐색 키를 작은 정수로 사상(mapping) 시키는 함수 필요

### 해싱의 (탐색)구조

- 해싱에서는 자료를 저장하는데 배열을 사용한다
    - 배열 : 원하는 항목이 들어있는 위치 (인덱스)를 알고 있다면, 다른 요소 접근 필요 없이 자료(값) 삽입, 접근 가능
- 해싱은 키만을 갖고 항목이 들어 있는 배열의 위치(인덱스)를 결정한다
    - 해시 함수 : 키를 입력받아 해시 주소를 생성하는 함수
    - 해시 주소 : 해시 함수의 결과, 해시 테이블의 인덱스로 사용

### 해시 테이블

: M개의 버킷으로 이루어지는 테이블

- 하나의 버킷은 s개의 슬롯(slot)을 가질 수 있음 / 대개 하나의 버킷은 하나의 슬롯을 가짐
    - 서로 다른 두개의 키가 해시 함수에 의해 동일한 해시주소로 변환(mapping)되는 경우가 있기 때문에 여러개의 항목을 동일한 버킷에 저장하기 위해 필요
    - 충돌 (collision) : 서로 다른 두개의 키 k1, k2에 대해 h(k1) = h(k2)인 경우
        - k1과 k2는 동의어(synonym)라고 함
        - 충돌이 자주 발생하면 버킷 내부에서의 순차 탐색 길어짐 ⇒ 탐색 성능 저하
            
            따라서 해시 함수를 수정하거나 해시 테이블의 크기 적절히 조절 필요
            
    - 오버 플로우 : 충돌이 할당된 슬롯 수보다 많이 발생하게 되어, 버킷에 더 이상 항목을 저장할 수 없게 되는 상황
- 하나의 슬롯에는 하나의 항목이 저장됨

## 해시 함수 (해싱 알고리즘)

- 이상적인 해싱 알고리즘 : 하나의 키당 해시테이블에서 하나의 공간을 할당 받는 것
    - 이상적인 상황에서의 O(1)의 시간 복잡도를 가짐
    - 실제 상황에서 어려운 이유
    : 보통의 상황에서 키는 매우 많고, 해시 테이블의 크기는 제약을 받기 때문
        
        ⇒ 저장하는 과정에서 충돌과 오버플로우가 빈번하게 발생
        
        ⇒ 이상적 시간복잡도 O(1)보다는 성능이 떨어지게 됨
        
        ⇒ 해싱에서는 키값을 해시 테이블의 주소로 변환하는 해시 함수가 잘 설계되어야 탐색 효율이 증대
        

### 좋은 해시 함수의 조건

- 충돌이 적어야 한다
- 해시함수의 값이 해시테이블의 주소 영역 내에서 고르게 분포되어야 한다
- 계산이 빨라야 한다

---

- 해시 테이블의 크기가 M인 경우 해시 함수는 키(정수, 문자열)들을 [0, M-1]의 범위의 정수로 변환시켜야 한다

### 해시 함수 1. 제산 함수 (나머지 연산자 이용)

: 나머지 연산자(mod)를 이용해 키를 해시 테이블의 크기로 나눈 나머지를 해시 주소로 사용

h(k) = k % M

- 다양한 응용 분야에 쉽게 적용 가능 & 해시 주소를 상당히 고르게 분포시킬 수 있음
- 해시 함수의 값 범위 : 0 ~ (M-1)
    
    ⇒ 해시 테이블의 인덱스로 사용하기에 이상적인 값이 됨
    
- 해시 테이블의 크기 M은 주로 소수 (prime number)를 선택함
    - M의 선택이 중요한 이유
        - M이 짝수일 경우
        : k값이 짝수인지, 홀수인지에 따라 영향을 받음
            - 보통 2의 배수를 갖는 메모리 주소를 갖고 해싱할 경우 짝수가 될 가능성이 높기에 해시 주소가 한쪽으로 편향됨 ⇒ 해시 테이블을 골고루 사용하지 않음
            
            ⇒ M은 항상 홀수여야 한다
            
            ⇒ M이 소수일 경우 0 ~ M-1을 골고루 사용하는 값을 만들어낸다.
            
        - 나머지 연산 수행 결과 음수가 나올 가능성에 대한 대비
            
            : k mod M이 음수일 경우 M을 더해서 결과값이 항상 0 ~ M-1이 되도록 해야 함
            
- 제산함수를 활용한 해시 함수의 최종 형태
    
    ```python
    int hash_func(int key)
    {
    	int hash_idx = key % M;
    	if (hash_idx < 0)
    		hash_idx += M;
    	return hash_idx;
    }
    ```
    

### 해시 함수 2. 폴딩 함수

: 키를 여러 부분으로 나누어 (분할) 분할된 부분을 모두 더한 값을 해시 주소로 사용하는 것
(키값을 해시 테이블 크기만큼의 수를 가지는 부분으로 분할함)

`hash_idx = (short)(key ^ (key >> 16))`

- 주로 탐색 키가 해시 테이블의 크기보다 더 큰 정수일 경우 사용
(키가 32비트, 테이블 인덱스가 16비트인 경우)
    
    ⇒ 키를 몇개의 부분으로 나눠 이를 더하거나 비트별로 XOR과 같은 부울 연산 사용
    
- 키를 나누고 더하는 방법에 사용하는 대표적 폴딩 방식
    
    : 이동 폴딩 (shift folding) / 경계 폴딩 (boundary folding)
    
    - 이동 폴딩 : 키를 여러 부분으로 나눈 값을 더하여 해시 주소로 사용
    - 경계 폴딩 : 키의 이웃한 부분을 거꾸로 더해 해시 주소를 얻음