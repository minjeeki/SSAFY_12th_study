# 기본적인 컴퓨터 구조
![image](https://github.com/user-attachments/assets/d9fbe401-775c-4b7a-ad34-80232c3139bf)
- 컴퓨터가 이해하는 정보는 데이터와 명령어가 있음
- ALU(Arithmetic & Logic Unit) : 컴퓨터에서 계산을 위해 수행하는 부품
- CU(Control Unit) : 전기 신호를 내보내고 명령어를 해석하는 장치
- Register : CPU 내부의 임시 저장 장치
- System bus : 컴퓨터의 핵심 부품들을 연결하는 가장 중요한 버스
  - 주소 버스 : 주소를 주고 받는 통로
  - 데이터 버스 : 명령어와 데이터를 주고 받는 통로
  - 제어 버스 : 제어 신호를 주고 받는 통로

# 소스 코드와 명령어
## 컴파일 언어 & 인터프리터 언어
### 컴파일 언어 
- 컴파일 : 소스 코드 전체가 저급 언어로 변환되는 과정
- 컴파일러가 소스 코드 전체를 보며 저급 언어로 변환
- 오류를 하나라도 발견시 컴파일 실패
- 목적 코드 : 컴파일러를 통해 저급 언어로 변환된 코드
- **컴파일 시점과 실행 시점이 다름**
### 인터프리터 언어
- 인터프리터 : 소스 코드를 한줄씩 차례대로 저급 언어로 변환하여 실행해주는 도구
- 오류가 있어도 그 전까지는 올바르게 실행
- **해석 시점과 실행 시점이 동일**
### Java는 어떤 방식으로 동작하나요?
- JIT(Just In Time) 컴파일 방식을 사용
- 프로그램을 실제 실행하는 시점에 컴파일하는 기법
- 인터프리트 방식과 컴파일 방식을 혼합한 방식이 바로 JIT 컴파일러의 역할
- 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지

> 캐싱 : 파일 복사본을 캐시 또는 임시 저장 위치에 저장하여 보다 빠르게 액세스할 수 있도록 하는 프로세스에 해당

# 명령어의 구조
## 연산 코드와 오퍼랜드
- 명령어는 기본적으로 '무엇을 대상으로, 어떤 작동을 수행하라'는 구조로 되어 있음.
  
  | 연산 코드 필드 | 오퍼랜드 필드 |
  | ------------- | ------------ |
### 연산 코드
- 연산자
- 데이터 전송
  - `MOVE` : 데이터 이동
  - `STORE` : 메모리에 데이터 저장
  - `LOAD(FETCH)` : 메모리에서 CPU로 데이터를 가져오기 
  - `PUSH` : 스택에 데이터 저장
  - `POP` : 스택에서 데이터 가져오기
- 산술/논리 연산
  - `ADD / SUBSTRACT / MULTIPLY / DIVIDE`
  - `INCREMENT / DECREMENT`
  - `AND / OR / NOT`
  - `COMPARE`
- 제어 흐름 변경
  - `JUMP` : 특정 주소로 실행 순서 옮기기
  - `CONDITIONAL JUMP` : 조건 부합시 `JUMP`
  - `HALT` : 프로그램의 실행 중지
  - `CALL` : 되돌아올 주소 저장한 채 `JUMP`
  - `RETURN` : `CALL` 호출할 때 저장했던 주소로 돌아가기
- 입출력 제어
  - `READ(INPUT)` : 특정 입출력 장치로부터 데이터를 읽어라
  - `WRITE(OUTPUT)` : 특정 입출력 장치로 데이터를 써라
  - `START IO` : 입출력 장치를 시작하라
  - `TEST IO` : 입출력 장치의 상태를 확인하라
### 오퍼랜드
- 피연산자
- 연산에 사용할 데이터 또는 데이터가 저장된 위치를 의미
- 명령어 안에 하나도 없을 수도 있음


## 주소 지정 방식
- 연산 대상의 위치를 파악하는 방법 - 주소 지정 방식에 따라
### 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- (장)연산에 사용할 데이터를 메모리나 레지스터에서 찾는 과정이 없음
- (단)표현할 수 있는 데이터 크기가 작음

  | 연산 코드 | 데이터 |
  | -------- | ------ |
  
### 직접 주소 지정 방식
- 오퍼랜드 필드에 유효주소를 직접 명시
- (장) 즉시 주소 지정 방식에 비해 유효 주소 표현 범위 증가
- (단) 유효 주소에 제한

  | 연산 코드 | 유효 주소 |
  | --------- | --------- |

  | 메모리 |
  | ------ |
  |  ....  |
  | 데이터 |
  |  ....  |

### 간접 주소 지정 방식
- 유효 주소 역시 오퍼랜드 필드에 명시
- (장) 직접 주소 지정 방식보다 표현할 수 있는 유효 주소 범위가 더 넓어짐
- (단) 두번의 메모리 접근 - 일반적으로 느린 방식

  | 연산 코드 | 유효 주소의 주소|
  | --------- | --------- |

  | 메모리 |
  | ------ |
  |  ....  |
  | 유효 주소 |
  |  데이터  |

### 레지스터 주소 지정 방식
- 연산에 사용할 데이터를 레지스터에 저장
- (장) CPU 외부 메모리 접근보다는 CPU 내부 레지스터에 접근하는 것이 더 빠름
- (단) 직접 주소 지정 방식과 비슷한 단점 공유
  
  | 연산 코드 | 유효 주소 |
  | --------- | --------- |

  | 레지스터 |
  | ------ |
  |  데이터  |

### 레지스터 간접 주소 지정 방식
- 레지스터와 메모리 모두 활용
- 연산에 사용할 데이터를 메모리에 저장하고 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
  
  | 연산 코드 | 유효 주소를 저장한 레지스터 |
  | --------- | --------- |

  | 레지스터 |
  | ------ |
  |  유효 주소  |

  | 메모리 |
  | ------ |
  |  데이터  |
