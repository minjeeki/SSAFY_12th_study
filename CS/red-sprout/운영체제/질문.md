# 운영체제 시작하기 

### **운영체제의 역할과 커널의 기능에 대해 설명해보세요.**

**답변:**
운영체제는 컴퓨터 하드웨어를 관리하고, 응용 프로그램들이 효율적으로 실행될 수 있도록 지원하는 시스템 소프트웨어입니다. 운영체제는 사용자와 하드웨어 간의 인터페이스를 제공하며, 자원 관리, 파일 시스템 관리, 프로세스 관리 등의 주요 기능을 수행합니다. 이 중에서도 커널은 운영체제의 핵심 부분으로, 하드웨어 자원 관리, 메모리 관리, 프로세스 스케줄링 등의 중요한 역할을 담당합니다. 커널은 항상 메모리에 상주하며, 시스템 자원에 대한 접근을 제어하고, 안전하고 효율적인 시스템 운영을 보장합니다.

### **이중 모드에 대해 설명하고, 이중 모드에서 각 모드(사용자 모드와 커널 모드)의 차이점과 그 중요성에 대해 설명해보세요.**

**답변:**
이중 모드는 CPU가 명령어를 실행할 때 사용자 모드와 커널 모드로 나뉘는 것을 의미합니다. 사용자 모드에서는 응용 프로그램이 실행되며, 직접 하드웨어에 접근할 수 없고, 제한된 명령어만 실행할 수 있습니다. 반면, 커널 모드에서는 운영체제의 핵심 기능이 실행되며, 모든 시스템 자원에 대한 완전한 접근 권한을 갖습니다. 이중 모드는 시스템의 안정성과 보안을 보장하기 위해 필수적입니다. 사용자 모드에서 실행되는 프로그램이 시스템 자원에 직접 접근하지 못하도록 함으로써, 프로그램의 오류나 악의적인 행동으로부터 시스템을 보호할 수 있습니다. 필요한 경우 시스템 호출(System Call)을 통해 사용자 모드에서 커널 모드로 전환하여 운영체제의 서비스를 사용할 수 있습니다.

### **멀티프로그래밍과 멀티태스킹의 차이점에 대해 설명해보세요.**

**답변:**
멀티프로그래밍은 메모리에 여러 프로그램을 동시에 적재하여 CPU가 하나의 프로그램을 끝낸 후 다른 프로그램을 실행할 수 있도록 하는 기법입니다. 이를 통해 CPU의 사용 효율을 높일 수 있습니다. 반면, 멀티태스킹은 하나의 CPU가 여러 작업을 매우 빠르게 전환하여 동시에 여러 작업이 수행되는 것처럼 보이도록 하는 기법입니다. 멀티태스킹은 멀티프로그래밍의 확장 개념으로, 실제로는 하나의 CPU가 교대로 작업을 수행하지만, 사용자에게는 동시에 여러 작업이 처리되는 것처럼 보입니다. 이는 현대의 운영체제에서 매우 일반적인 방식으로, CPU의 활용도를 극대화합니다.

### **System Call이 무엇이며, 왜 중요한지 설명해보세요.**

**답변:**
시스템 호출(System Call)은 응용 프로그램이 운영체제의 커널이 제공하는 서비스를 요청할 때 사용하는 인터페이스입니다. 시스템 호출을 통해 응용 프로그램은 파일 시스템 접근, 프로세스 생성, 메모리 관리, 입출력 장치 제어 등의 기능을 수행할 수 있습니다. 시스템 호출은 사용자 모드에서 실행되는 응용 프로그램이 커널 모드에서만 가능한 작업을 안전하게 수행할 수 있도록 해줍니다. 이를 통해 프로그램이 직접 하드웨어에 접근하지 않고도 필요한 자원에 접근할 수 있으며, 이 과정에서 시스템의 안정성과 보안이 보장됩니다. 시스템 호출은 운영체제의 핵심 서비스와 응용 프로그램 간의 중요한 연결 고리 역할을 합니다.

# 동기화

### 질문 1: 프로세스 동기화가 필요한 이유는 무엇인가요?

**답변:**  
프로세스 동기화는 여러 프로세스가 동시에 공유 자원에 접근할 때 발생할 수 있는 데이터 불일치, 레이스 컨디션 등의 문제를 방지하기 위해 필요합니다. 동기화를 통해 프로세스들이 올바른 순서로 자원에 접근하고, 필요한 경우 상호 배제를 통해 하나의 프로세스만 자원에 접근할 수 있도록 보장합니다. 이는 시스템의 안정성과 데이터 일관성을 유지하는 데 필수적입니다.

### 질문 2: 상호 배제(mutual exclusion)란 무엇인가요?

**답변:**  
상호 배제는 하나의 프로세스가 임계 구역에 진입하여 자원을 사용하는 동안 다른 프로세스가 해당 임계 구역에 들어가지 못하도록 하는 개념입니다. 이를 통해 여러 프로세스가 동시에 자원에 접근하여 발생할 수 있는 충돌이나 데이터 불일치를 방지할 수 있습니다. 상호 배제를 구현하기 위한 대표적인 방법으로는 뮤텍스 락(Mutex lock)과 세마포어(semaphore)가 있습니다.

### 질문 3: 뮤텍스 락과 세마포어의 차이점은 무엇인가요?

**답변:**  
뮤텍스 락(Mutex lock)은 상호 배제를 구현하기 위한 기법으로, 하나의 프로세스만 임계 구역에 진입할 수 있도록 합니다. 뮤텍스 락은 일반적으로 1개의 자원에 대해 동작하며, 잠금(acquire)과 해제(release) 메커니즘을 사용하여 임계 구역을 관리합니다.

세마포어(semaphore)는 뮤텍스와 유사하지만, 여러 개의 프로세스가 동시에 접근할 수 있는 자원 개수를 관리할 수 있다는 점에서 차이가 있습니다. 세마포어는 특정 자원의 사용 가능 수를 나타내는 정수 값을 관리하며, 이를 통해 여러 프로세스가 자원에 접근할 수 있는 동시성을 제어합니다. 세마포어는 바쁜 대기(busy waiting) 대신 대기 큐를 사용하여 자원을 기다리는 프로세스들이 CPU 시간을 낭비하지 않도록 할 수 있습니다.

### 질문 4: 생산자-소비자 문제란 무엇이며, 이 문제를 어떻게 해결할 수 있나요?

**답변:**  
생산자-소비자 문제는 하나의 버퍼를 두고 생산자와 소비자가 데이터를 삽입하고 추출하는 과정에서 발생할 수 있는 동기화 문제입니다. 생산자가 버퍼에 데이터를 삽입하는 동안 소비자가 데이터를 읽으면 데이터의 불일치가 발생할 수 있습니다. 이를 해결하기 위해 세마포어를 사용하여 생산자와 소비자가 동시에 버퍼에 접근하지 않도록 제어할 수 있습니다. 또한, 세마포어를 통해 버퍼가 가득 찬 경우 생산자가 대기하고, 버퍼가 비어 있는 경우 소비자가 대기하도록 구현할 수 있습니다.

### 질문 5: 모니터(Monitor)란 무엇이며, 왜 사용되나요?

**답변:**  
모니터는 공유 자원에 대한 접근을 제어하는 고수준의 동기화 도구입니다. 모니터는 공유 자원과 이를 제어하는 절차들을 하나의 단위로 묶어 관리하며, 프로세스는 반드시 모니터의 인터페이스를 통해서만 자원에 접근할 수 있습니다. 모니터는 내부적으로 상호 배제를 보장하며, 조건 변수를 통해 특정 조건에서 프로세스를 대기시키거나 깨울 수 있는 기능을 제공합니다.

## 자바 동시성과 관련하여
### 질문 1: 자바에서 동기화를 어떻게 구현하나요?

**답변:**  
자바에서 동기화는 `synchronized` 키워드를 사용하여 구현할 수 있습니다. 이 키워드는 메서드나 블록을 임계 구역으로 지정하여, 하나의 스레드만 해당 구역에 접근할 수 있도록 보장합니다. 예를 들어, 메서드 선언에 `synchronized`를 추가하거나 특정 객체를 대상으로 `synchronized` 블록을 만들어 동기화를 구현할 수 있습니다.

**꼬리 질문:**  
`synchronized` 블록과 `synchronized` 메서드의 차이는 무엇인가요? 언제 각각을 사용해야 하나요?

**답변:**  
`synchronized` 메서드는 메서드 전체를 임계 구역으로 설정하는 것이며, 해당 객체의 모든 스레드가 메서드의 실행을 마칠 때까지 기다리게 만듭니다. 반면, `synchronized` 블록은 메서드의 일부 코드만 임계 구역으로 설정할 수 있어 더 세밀하게 동기화할 수 있습니다. `synchronized` 블록은 성능 최적화가 필요한 경우나, 특정 객체만 잠그고 싶을 때 사용합니다.

### 질문 2: 자바에서 `volatile` 키워드의 역할은 무엇인가요?

**답변:**  
`volatile` 키워드는 변수의 값이 여러 스레드에 의해 수정될 수 있음을 알리는 역할을 합니다. `volatile`로 선언된 변수는 각 스레드가 변수의 값을 직접 메인 메모리에서 읽고 쓰도록 보장하므로, CPU 캐시에서 읽어오거나 쓰는 것을 방지합니다. 이를 통해 변수의 최신 값이 모든 스레드에서 일관되게 유지되도록 합니다.

**꼬리 질문:**  
`volatile` 키워드가 동기화와 어떻게 다르며, 언제 `volatile`을 사용해야 하나요?

**답변:**  
`volatile`은 변수의 값이 메인 메모리에 직접 저장되도록 하여 스레드 간의 가시성을 보장하지만, 원자성을 보장하지는 않습니다. 즉, `volatile`은 읽기-쓰기 연산이 원자적으로 이뤄지지 않는 경우에는 동기화 문제를 해결하지 못합니다. `volatile`은 단순히 가시성만이 중요한 경우에 사용하고, 원자성이 중요한 경우에는 `synchronized`나 `ReentrantLock`과 같은 동기화 메커니즘을 사용해야 합니다.

### 질문 3: 자바의 `ReentrantLock`과 `synchronized`의 차이점은 무엇인가요?

**답변:**  
`ReentrantLock`은 자바에서 제공하는 동기화 메커니즘 중 하나로, `synchronized`와 유사하게 임계 구역을 보호합니다. 그러나 `ReentrantLock`은 보다 유연한 기능을 제공하는데, 예를 들어 공정성(Fairness)을 보장할 수 있고, 시도 횟수나 대기 시간을 설정하여 잠금을 시도할 수 있습니다. 또한, `synchronized`와 달리 명시적으로 잠금을 해제해야 하므로, 이를 잊지 않도록 주의해야 합니다.

**꼬리 질문:**  
`ReentrantLock`을 사용할 때 발생할 수 있는 잠금 해제 실수를 방지하기 위한 방법은 무엇인가요?

**답변:**  
잠금 해제 실수를 방지하기 위해 `ReentrantLock`을 사용할 때는 반드시 `finally` 블록에서 `unlock()` 메서드를 호출하도록 해야 합니다. 이렇게 하면 예외가 발생하더라도 잠금이 확실히 해제되어 데드락(deadlock)을 방지할 수 있습니다. 예를 들어, `try { lock.lock(); ... } finally { lock.unlock(); }` 구조를 사용하는 것이 좋습니다.

### 질문 4: 자바에서 `wait()`, `notify()`, `notifyAll()` 메서드는 어떻게 동작하나요?

**답변:**  
`wait()`, `notify()`, `notifyAll()` 메서드는 자바의 동기화 메커니즘에서 스레드 간의 통신을 위해 사용됩니다. `wait()`는 호출된 스레드를 대기 상태로 만들며, 이 스레드는 `notify()`나 `notifyAll()` 메서드가 호출될 때까지 대기하게 됩니다. `notify()`는 대기 중인 스레드 중 하나를 깨워서 실행 상태로 전환시키고, `notifyAll()`은 모든 대기 중인 스레드를 깨워서 실행 대기 상태로 전환시킵니다. 이 메서드들은 `synchronized` 블록이나 메서드 내에서 호출되어야 합니다.

**꼬리 질문:**  
`wait()` 메서드와 `sleep()` 메서드의 차이점은 무엇인가요?

**답변:**  
`wait()` 메서드는 객체의 모니터 락을 해제하고, 호출된 스레드를 대기 상태로 만듭니다. 이 스레드는 `notify()` 또는 `notifyAll()`이 호출될 때까지 대기하며, `synchronized` 블록 내에서만 호출될 수 있습니다. 반면, `sleep()` 메서드는 현재 스레드를 지정된 시간 동안 멈추게 하지만, 객체의 모니터 락을 해제하지 않습니다. 또한, `sleep()`은 `synchronized` 블록 외부에서도 호출될 수 있습니다.

### 질문 5: 자바의 `ThreadLocal` 클래스는 무엇이며, 언제 사용하나요?

**답변:**  
`ThreadLocal` 클래스는 각 스레드가 자신만의 고유한 변수를 가질 수 있도록 지원합니다. 이를 통해 여러 스레드가 같은 변수를 사용하더라도 서로 간섭 없이 독립적인 값을 유지할 수 있습니다. `ThreadLocal`은 주로 스레드 안전성이 중요한 경우, 특정 데이터를 각 스레드가 독립적으로 관리해야 하는 경우에 사용됩니다. 예를 들어, 데이터베이스 연결이나 사용자 세션과 같은 컨텍스트 데이터를 각 스레드마다 독립적으로 저장하고자 할 때 유용합니다.

**꼬리 질문:**  
`ThreadLocal` 사용 시 주의해야 할 점은 무엇인가요?

**답변:**  
`ThreadLocal` 사용 시 가장 중요한 점은 메모리 누수(memory leak)입니다. 스레드가 종료되지 않으면 `ThreadLocal`에 저장된 데이터가 계속 유지되기 때문에, 스레드 종료 후에 `ThreadLocal` 변수를 적절히 정리해야 합니다. 이를 위해 `ThreadLocal`의 `remove()` 메서드를 사용하여 불필요한 데이터를 삭제해 메모리 누수를 방지해야 합니다.