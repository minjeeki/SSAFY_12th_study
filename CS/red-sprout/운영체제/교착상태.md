# 교착상태란
## 식사하는 철학자 문제
- Dining philosophers problem
- 다섯 명의 철학자, 가운데에는 포크 두개를 사용하여 식사할 수 있는 스파게티
> - 일정 시간 생각을 한다.
> - 왼쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
> - 오른쪽 포크가 사용 가능해질 때까지 대기한다. 만약 사용 가능하다면 집어든다.
> - 양쪽의 포크를 잡으면 일정 시간만큼 식사를 한다.
> - 오른쪽 포크를 내려놓는다.
> - 왼쪽 포크를 내려놓는다.
> - 다시 1번으로 돌아간다.
- 모든 철학자가 동시에 포크를 집어든다면? - 다른 철학자가 포크 내려놓을 때까지 대기
- 영원히 식사 못하는 상황 발생 가능 - **교착상태(deadlock)**
### 예시
- 뮤텍스 락에서의 교착상태
```
lock1 = true;
while(lock2 == true)
;
// 임계 구역 작업
lock1 = false;
```
```
lock2 = true;
while(lock1 == true)
;
// 임계 구역 작업
lock2 = false;
```
- 서로서로 lock이 false 될 때까지 기다리고 있음 - 교착상태

## 자원 할당 그래프
- Resource-allocation graph
- 해당 그래프가 원의 형태를 띄면 교착 상태
1. 프로세스는 원으로, 자원 종류는 사각형으로
2. 사용할 수 있는 자원 개수는 자원 사각형 내 점으로
3. 프로세스가 어떤 자원을 할당받아 사용중이라면 자원에서 프로세스를 향해 화살표를 표시(점유)
4. 프로세스가 어떤 자원을 기다리고 있으면 프로세스에서 자원으로 화살표를 표시(요구)

## 교착 상태 발생 조건
### 상호 배제(Mutual exclusion)
- 식사하는 철학자 문제 - 포크 하나로 여러명이 식사 가능 시 교착 상태 X
- 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없을 때
### 점유와 대기(Hold and wait)
- 식사하는 철학자 문제 - 포크를 들고 대기하기에 교착 상태 발생
- 프로세스가 어떤 자원을 할당받은 채로 다른 자원 할당받기 위한 대기
### 비선점(Nonpreemptive)
- 식사하는 철학자 문제 - 포크 뺏기 가능시 교착 상태 X
- 자원을 이용하는 프로세스 작업이 끝나야 그 자원을 다른 프로세스에서 이용
### 원형 대기(Circular wait)
- 자원 할당 그래프가 원의 형태로 그려짐

# 교착 상태 해결
## 교착 상태 예방
### 상호 배제(Mutual exclusion)
- 모든 자원 공유 가능 - 사실상 현실에서는 무리
### 점유와 대기(Hold and wait)
- 특정 프로세스에 자원을 모두 할당하거나 아예 못하게 하거나
- 프로세스 시작 시, 모든 필요한 자원을 할당받게 하는 방법
- 자원이 필요할 경우, 보유 자원을 모두 놓고 다시 요청.
- 자원 활용률 낮음, 기아 현상(Starvation) 발생 가능
### 비선점(Nonpreemptive)
- 자원 뺏기 가능
- 모든 자원이 선점 가능하지는 않음
### 원형 대기(Circular wait)
- 자원 유형에 할당 순서 정하기
- 번호 붙이기의 어려움, 기아 현상(Starvation) 발생 가능, 자원 이용률 저하
> 기아 현상(Starvation) : 프로세스가 원하는 자원을 계속 할당받지 못하는 상태

## 교착 상태 회피
### 교착 상태 회피
- 교착 상태가 발생하지 않은 정도로만 자원 할당
- `안전 상태(safe state)` : 모든 프로세스가 정상적으로 자원을 할당받고 종료될 수 있는 상태, 안전 순서열 존재
- `불안점 상태(unsafe state)` : 교착 상태가 발생할 수도 있는 상황, 안전 순서열 없음
- `안전 순서열(safe sequence)` : 교착 상태 없이 안전하게 프로세스들에게 자원을 할당할 수 있는 순서
    - 프로세스들이 안전(safe) 하기 위해서는 각 프로세스들의 자원요청이 

## 교착 상태 검출 후 회복
- 교착 상태 발생을 인정하고 사후에 조치
### 선점을 통한 회복
- 교착 상태가 해결될 때까지 한 프로세스씩 자원을 몰아주는 방식
- 다른 프로세스로부터 자원 강제로 뺏고 할당
### 프로세스 강제 종료를 통한 회복
- 교착 상태 없어질 때까지 강제 종료
- 모두 강제 종료 - 작업 내역 손실
- 하나씩 강제 종료 - 손실 최소화, 교착 상태 확인시 오버헤드 야기

## 잠재적 문제 무시
- 타조 알고리즘(ostrich algorithm) - 모른 체하기
- 교착 상태가 매우 드물게 발생하기에 이 조치 자체가 더 큰 오버헤드일 수 있음

# 추가 설명
## 교착 상태 회피
### Resource allocation graph algorithm
![회피1](/CS/red-sprout/운영체제/img/resource_allocation_graph_algo.png)
- 자원당 인스턴스가 1개
- 프로세스가 자원을 미래에 요청 가능(점선으로 표시)
- 요청시에는 실선으로
- 해제되면 다시 점선으로
- cycle이 생기지 않는 경우에만 요청 자원 할당
- cycle 생성 여부 조사 시 `O(n^2)`
- https://velog.io/@suuhyeony/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Ch7.-Deadlock

### Banker's algorithm
- 자원당 인스턴스가 여러개
- 자원의 할당 허용 여부를 결정하기 전에 미리 결정된 모든 자원의 최대 가능한 할당량을 시뮬레이션하여 안전 여부 검사
- 대기 중인 다은 모든 활동의 교착 상태 가능성을 조사하여 안정 상태 여부 검사 확인
- 각종 자료구조
  - `Availabe` : 시스템 전체 가용 자원
  - `Max` : 각 프로세스가 요구하는 최대 자원
  - `Allocation` : 각 프로세스에 현재 할당된 자원
  - `Need` : 각 프로세스에 남아 있는 추가 요구량, `Need(i) = Max(i) - Allocation(i)`
- 동작 순서
  - `Request(i) < Need(i)` : 다음 단계 이동, 아니면 오류 상태
  - `Request <= Available` : 다음 단계 이동, 아니면 자원 부족으로 프로세스 대기
  - 다음과 같이 상태 변경
    ```
    Available = Available - Reqeust(i);
    Allocation(i) = Allocation(i) + Request(i);
    Need(i) = Need(i) - Request(i);
    ```
- 안정 & 불안정 검사
  - `Work = Available`, `Finish[i] = False`로 초기화
  - `Finish[i] = False`, `Need(i) <= Work` 만족하는 것을 찾기
    - 해당하는 것에 대해서 `Work = Work + Allocation(i)`, `Finish[i] = True`
  - 모든 i에 대해 `Finish[i] = True`이면 시스템은 안정상태
- 단점
  - 일정하게 남아있는 자원 수를 파악하기 매우 어려움
  - 다중 프로그래밍 시스템에서는 사용자 수가 변함
  - **교착 상태 회피 알고리즘 실행 시 오버헤드 야기**
  - 프로세스는 자원을 보유한 상태로 종료 불가
  - 항상 불안정 상태를 방지 - 자원 이용도가 낮음
- https://hoyeonkim795.github.io/posts/bankers/
- https://velog.io/@minu-j/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A7%8C%ED%99%94%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%EC%9D%80%ED%96%89%EC%9B%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-%ED%9A%8C%ED%94%BC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
