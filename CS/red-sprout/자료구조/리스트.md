# 리스트

## 사전적 의미
'줄 세워져 있는 데이터', '쭉 늘어선 데이터'

## 리스트의 구현
1. 원소를 연속된 공간에 존재하는 배열로 배치하는 방법
2. 링크를 이용해 원소들을 연결하는 방법

## 배열 리스트(ArrayList)
https://velog.io/@red-sprout/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-ArrayList-%EA%B5%AC%ED%98%84

## 연결 리스트(LinkedList)
https://velog.io/@red-sprout/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-LinkedList-%EA%B5%AC%ED%98%84

# 질문
### 배열 리스트와 연결 리스트의 차이점은?
<details>
<summary>예시</summary>

배열 리스트 자료구조는 메모리의 연속된 공간에서 데이터를 관리하기에 논리적 저장 순서와 물리적 저장 순서가 일치합니다. 따라서 인덱스(index)로 해당 원소(element)에 접근할 수 있습니다. 그렇기 때문에 O(1)에 해당 원소로 접근할 수 있습니다. 즉 random access 가 가능하다는 장점이 있습니다.

하지만 삭제 또는 삽입의 과정에서 단점이 있습니다.

만약 배열의 원소 중 어느 원소를 삭제했다고 했을 때 빈 공간이 생깁니다. 따라서 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift해줘야 하는 비용(cost)이 발생하고 이 경우의 시간 복잡도는 O(n)가 됩니다. 그렇기 때문에 Array 자료구조에서 삭제 기능에 대한 time complexity 의 worst case 는 O(n)이 됩니다.

삽입의 경우도 마찬가지입니다. 만약 첫번째 자리에 새로운 원소를 추가하고자 한다면 모든 원소들의 인덱스를 1 씩 shift 해줘야 하므로 이 경우도 O(n)의 시간을 요구하게 됩니다.

- 여기서 조금 더 효율적인 방법이 없을까 꼬리 질문 있음
- Java의 경우 이를 완화하였는데 어떻게 하였을까?

연결 리스트의 경우 이 부분을 해결하였습니다. 각각의 원소들은 정점과 포인터로 구성되어있고, 이 포인터가 자신의 원소 다음에 어떤 원소가 있는지 기억하고 있습니다. 즉, 삽입과 삭제를 이부분만 바꿔주면 되기 때문에 O(1)으로 해결 가능합니다.

다만 배열 리스트와 달리 인덱스를 찾는 과정에서 처음부터 끝까지 조사하기 때문에 O(n)의 시간이 발생합니다.
</details>

### 배열 리스트나 연결 리스트를 활용해 문제를 해결한 경험이 있나요?
<details>
<summary>예시</summary>

DB의 공연 자료를 JDBC를 통해 SELECT 문을 작성한 결과를 조회할 때, ResultSet을 통해 받은 결과를 ArrayList로 받은 바가 있습니다. 배열의 경우 실제 얼마나 많은 데이터가 들어오는지 확신할 수 없기에 리스트 형태의 자료구조를 활용하였습니다.
</details>

### 자바에서는 배열 리스트를 구현할 때 공간이 얼만큼 늘어나는지, 그리고 그 이유를 설명해보세요.
<details>
<summary>예시</summary>

자바에서는 배열 리스트를 구현시 1칸씩 증가하는 형태가 아닌 메모리를 1.5배 확보하는 방식으로 구현이 되어 있습니다. 이 때 N번 자료를 넣었을 때 수행 횟수는 N에 비례해서 O(N)입니다. 따라서 1개의 자료를 넣었을 시 평균적으로 O(1)으로 실행합니다.

일반적으로 2배를 늘릴 수도 있는데, 시간 및 공간 복잡도를 종합적으로 고려하여 1.5배 늘리는 방식을 택합니다.
</details>