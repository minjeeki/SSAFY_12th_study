# 해시 테이블
https://velog.io/@red-sprout/자료구조-HashTable-구현

# 질문
### 질문 1: 해시 테이블이란 무엇이며, 왜 사용하는가?
**답변:**  
해시 테이블(Hash Table)은 데이터를 (키, 값) 쌍으로 저장하는 자료 구조입니다. 해시 함수를 사용하여 키를 배열의 인덱스로 변환하여 값을 저장합니다. 해시 테이블을 사용하는 이유는 평균적으로 O(1)의 시간복잡도로 데이터를 빠르게 검색, 삽입, 삭제할 수 있기 때문입니다. 이는 특히 큰 데이터 집합에서 효율적으로 작동합니다.

### 질문 2: 해시 충돌(Hash Collision)은 무엇이며, 이를 해결하는 방법에는 어떤 것이 있는가?
**답변:**  
해시 충돌은 서로 다른 두 키가 같은 해시 값을 가져 동일한 배열 인덱스에 저장되려고 할 때 발생합니다. 이를 해결하는 방법에는 두 가지 주요 접근법이 있습니다:
1. **체이닝(Chaining):** 충돌이 발생한 인덱스에서 연결 리스트를 사용하여 여러 값을 저장하는 방법입니다. 즉, 같은 인덱스에 있는 항목들을 연결 리스트로 관리합니다.
2. **개방 주소법(Open Addressing):** 충돌이 발생하면 다른 빈 인덱스를 찾아 데이터를 저장하는 방법입니다. 방법에는 선형 탐색(Linear Probing), 제곱 탐색(Quadratic Probing), 이중 해시(Double Hashing) 등이 있습니다.

### 질문 3: 해시 함수를 잘 설계하는 것이 중요한 이유는 무엇인가?
**답변:**  
해시 함수를 잘 설계하면 해시 충돌의 빈도를 줄일 수 있어 해시 테이블의 성능을 최적화할 수 있습니다. 해시 충돌이 많아지면 체이닝 방식에서는 연결 리스트의 길이가 길어져 조회 시간이 O(N)으로 증가하고, 개방 주소법에서는 충돌 해결을 위한 추가적인 연산이 필요해 성능이 저하됩니다. 따라서 해시 함수는 키를 고르게 분포시켜 충돌을 최소화해야 합니다.

### 질문 4: 자바에서 체이닝을 사용한 해시 테이블을 어떻게 구현하는가?
**답변:**  
자바에서 체이닝을 사용한 해시 테이블은 다음과 같은 방식으로 구현할 수 있습니다:
1. 해시 테이블의 각 인덱스에 연결 리스트를 저장할 수 있도록 배열을 생성합니다.
2. 키의 해시 값을 계산하고, 배열의 크기와 % 연산을 통해 인덱스를 구합니다.
3. 구한 인덱스에 연결 리스트를 사용하여 데이터를 저장하거나 조회합니다.

### 질문 5: 해시 테이블의 장점과 단점은 무엇인가?
**답변:**  
**장점:**
- **빠른 데이터 접근:** 평균적으로 O(1)의 시간복잡도로 데이터를 검색, 삽입, 삭제할 수 있습니다.
- **유연성:** 다양한 타입의 키를 사용할 수 있습니다.

**단점:**
- **해시 충돌:** 충돌이 발생하면 성능이 저하될 수 있습니다. 이를 해결하기 위한 추가적인 메모리나 연산이 필요합니다.
- **메모리 사용:** 해시 테이블은 빈 공간을 많이 사용할 수 있어 메모리 효율성이 떨어질 수 있습니다.
- **해시 함수의 품질:** 해시 함수가 고르게 분포하지 않으면 충돌이 증가하고 성능이 저하됩니다. 해시 함수를 잘 설계하는 것이 중요합니다.

### Double Hashing의 장점과 단점

**장점:**
1. **충돌 해결 능력:** 이중 해시는 두 번째 해시 함수를 사용하여 충돌이 발생할 때 다른 위치로 이동할 수 있으므로 충돌 문제를 효과적으로 해결합니다.
2. **클러스터링 방지:** 선형 탐색과 달리 클러스터링(즉, 연속된 버켓에 데이터가 몰리는 현상)을 줄일 수 있습니다.
3. **효율성:** 체이닝 방식과 비교할 때, 링크드 리스트를 사용하지 않으므로 메모리 효율성이 높습니다.

**단점:**
1. **복잡성 증가:** 두 개의 해시 함수를 사용해야 하므로 구현이 복잡해질 수 있습니다.
2. **삭제가 어려움:** 삭제된 요소를 표기하고 그 자리를 비워 두어야 하기 때문에 관리가 어려울 수 있습니다.
3. **두 번째 해시 함수 설계:** 두 번째 해시 함수를 잘못 설계하면 성능이 크게 저하될 수 있습니다.

**단점 해결 방안:**
1. **적절한 두 번째 해시 함수 설계:** 두 번째 해시 함수는 테이블 크기와 서로 소수 관계가 되도록 설계하여 충돌을 피합니다.
2. **삭제된 요소 관리:** 삭제된 요소를 특별한 값(예: `DELETED`)으로 표시하고, 검색 시 이를 무시하도록 구현하여 문제를 해결합니다.
3. **재해싱:** 테이블이 일정 수준의 충돌을 겪으면 테이블 크기를 증가시키고 모든 요소를 재해싱하여 저장하는 방법을 사용할 수 있습니다.

### Load Factor

**Load Factor란?**
- **Load Factor**는 해시 테이블의 요소 개수(n)와 테이블 크기(k)의 비율을 나타내며, \( \text{Load Factor} = \frac{n}{k} \) 로 계산됩니다.
- 해시 테이블의 현재 사용 상태를 나타내며, 테이블이 얼마나 채워졌는지 나타냅니다.

**Load Factor의 중요성:**
- **성능 유지:** Load Factor가 높아지면 충돌이 증가하여 검색, 삽입, 삭제 성능이 저하됩니다.
- **재해싱 트리거:** Load Factor가 특정 임계값을 초과하면 테이블 크기를 늘리고 재해싱을 수행하여 성능을 유지합니다.

**자바의 Load Factor 정책:**
- 자바의 `HashMap`은 기본적으로 0.75의 Load Factor를 사용합니다.
- Load Factor가 0.75를 초과하면 해시 테이블 크기를 두 배로 늘리고 모든 요소를 재해싱하여 성능 저하를 방지합니다.

### 멀티스레드 환경에서의 해시 테이블 설계

멀티스레드 환경에서 해시 테이블을 안전하게 사용하기 위해 다음과 같은 방법을 설계할 수 있습니다:

1. **락을 사용한 동기화:** 
   - **전역 락:** 해시 테이블 전체에 대해 단일 락을 사용하여 동기화하는 방법입니다. 구현이 간단하지만 성능 저하가 큽니다.
   - **버킷 수준 락:** 해시 테이블의 각 버킷에 대해 개별적으로 락을 사용하여 동기화하는 방법입니다. 전역 락보다 성능이 우수합니다.

2. **ConcurrentHashMap 사용:**
   - 자바에서는 `ConcurrentHashMap`을 사용하여 멀티스레드 환경에서 안전하게 해시 테이블을 사용할 수 있습니다. `ConcurrentHashMap`은 내부적으로 세그먼트 락을 사용하여 높은 동시성을 제공합니다.

3. **Read-Write Lock:**
   - **Read-Write Lock**을 사용하여 읽기와 쓰기 작업을 분리할 수 있습니다. 읽기 작업은 동시에 수행할 수 있지만, 쓰기 작업은 단일 스레드만 수행하도록 제한하여 성능을 향상시킵니다.
