# 우선순위 큐 & 힙
## Java Collection
https://velog.io/@red-sprout/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-Heap-Priority-Queue

## 구현
https://velog.io/@red-sprout/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%EA%B5%AC%ED%98%84

# 질문
## 힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.

### 힙의 삽입 방식
힙(Heap)은 완전 이진 트리의 형태를 가지며, 다음과 같은 과정으로 삽입이 이루어집니다.

1. **삽입 위치 찾기**: 힙의 마지막 자리에 새로운 원소를 삽입합니다. 이는 완전 이진 트리의 특성을 유지하기 위함입니다.
2. **힙 속성 유지**: 새로운 원소가 삽입된 후, 부모 노드와 비교하여 힙 속성을 유지합니다. 최소 힙의 경우 부모 노드가 더 작아야 하고, 최대 힙의 경우 부모 노드가 더 커야 합니다. 만약 힙 속성이 깨진다면, 새로운 원소와 부모 노드를 교환합니다. 이 과정을 반복하여 힙 속성을 회복합니다.

이 과정은 트리의 높이에 비례하는 O(log n)의 시간복잡도를 가집니다.

### 힙의 삭제 방식
힙에서의 삭제는 주로 루트 노드의 삭제(최대 힙의 경우 최대값, 최소 힙의 경우 최소값)로 이루어집니다.

1. **루트 노드 삭제**: 루트 노드를 삭제합니다.
2. **마지막 원소 이동**: 힙의 마지막 원소를 루트 위치로 이동시킵니다.
3. **힙 속성 유지**: 루트에서부터 자식 노드들과 비교하여 힙 속성을 유지합니다. 최소 힙의 경우 더 작은 자식 노드와 교환하고, 최대 힙의 경우 더 큰 자식 노드와 교환합니다. 이 과정을 반복하여 힙 속성을 회복합니다.

이 과정 역시 트리의 높이에 비례하는 O(log n)의 시간복잡도를 가집니다.

### 왜 이진탐색트리와 달리 편향이 발생하지 않는지
힙은 **완전 이진 트리**의 형태를 유지하므로 편향이 발생하지 않습니다. 완전 이진 트리는 모든 레벨이 꽉 채워져 있으며, 마지막 레벨의 노드들이 왼쪽에서 오른쪽으로 차례대로 채워집니다. 이 특성 덕분에 힙의 높이는 항상 log n에 비례하게 됩니다.

반면에, 이진탐색트리(Binary Search Tree, BST)는 특정 규칙(왼쪽 자식 노드는 부모 노드보다 작고, 오른쪽 자식 노드는 부모 노드보다 큼)에 따라 노드가 삽입되므로 삽입 순서에 따라 트리가 편향될 수 있습니다. 예를 들어, 오름차순으로 정렬된 데이터를 이진탐색트리에 삽입하면 트리는 한쪽으로 치우친 형태(편향된 트리)가 되어 최악의 경우 트리의 높이는 n에 비례하게 됩니다.

따라서 힙은 항상 균형을 유지하여 O(log n)의 시간복잡도를 보장하는 반면, 이진탐색트리는 경우에 따라 편향이 발생하여 최악의 경우 O(n)의 시간복잡도를 가질 수 있습니다.
