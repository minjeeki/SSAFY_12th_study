# 스택
## 관련 내용 및 구현
https://velog.io/@red-sprout/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-stack-%EA%B5%AC%ED%98%84

# 질문
## 스택 2개로 큐를, 큐 2개로 스택을 구현해보는 아이디어를 제시하시기 바랍니다.
### 스택 2개로 큐를 구현하는 아이디어
스택 2개를 사용하여 큐를 구현하는 방법은 스택의 LIFO(Last In First Out) 특성을 활용하여 FIFO(First In First Out) 특성을 만들기 위함입니다. 

1. **입력 스택과 출력 스택 준비**: 두 개의 스택을 준비합니다. 하나는 입력을 위한 스택(input stack), 다른 하나는 출력을 위한 스택(output stack)입니다.
2. **enqueue 연산**: 새로운 원소를 큐에 추가할 때마다 입력 스택에 push합니다.
3. **dequeue 연산**: 원소를 큐에서 제거할 때는 출력 스택에서 pop합니다. 만약 출력 스택이 비어 있다면, 입력 스택의 모든 원소를 pop하여 출력 스택에 push한 후, 출력 스택에서 pop합니다.

이 방법은 각 연산이 대체로 O(1)의 시간복잡도를 가지지만, 최악의 경우 O(n) 시간복잡도를 가질 수 있습니다.

### 큐 2개로 스택을 구현하는 아이디어
큐 2개를 사용하여 스택을 구현하는 방법은 큐의 FIFO 특성을 활용하여 스택의 LIFO 특성을 만들기 위함입니다.

1. **입력 큐와 보조 큐 준비**: 두 개의 큐를 준비합니다. 하나는 입력을 위한 큐(main queue), 다른 하나는 보조 큐(helper queue)입니다.
2. **push 연산**: 새로운 원소를 스택에 추가할 때는 보조 큐에 enqueue합니다. 그 후, 입력 큐의 모든 원소를 보조 큐에 dequeue하여 enqueue한 후, 입력 큐와 보조 큐를 교체합니다.
3. **pop 연산**: 원소를 스택에서 제거할 때는 입력 큐에서 dequeue합니다.

이 방법은 각 연산이 대체로 O(n)의 시간복잡도를 가집니다.

## Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명하시기 바랍니다.
- **Prefix 표기법(전위 표기법)**: 연산자가 피연산자 앞에 위치하는 표기법입니다. 예: +AB
- **Infix 표기법(중위 표기법)**: 연산자가 피연산자 사이에 위치하는 표기법입니다. 예: A+B
- **Postfix 표기법(후위 표기법)**: 연산자가 피연산자 뒤에 위치하는 표기법입니다. 예: AB+

**계산 방법**
- **Prefix 계산**: 스택을 사용하여 오른쪽에서 왼쪽으로 수식을 읽습니다. 피연산자를 만나면 스택에 push하고, 연산자를 만나면 스택에서 두 개의 피연산자를 pop하여 연산을 수행한 후 결과를 다시 스택에 push합니다.
- **Infix 계산**: 중위 표기법을 계산하려면 일반적으로 후위 표기법으로 변환한 후 계산합니다. 변환 방법은 연산자 우선순위를 고려하여 스택을 사용하여 변환합니다.
- **Postfix 계산**: 스택을 사용하여 왼쪽에서 오른쪽으로 수식을 읽습니다. 피연산자를 만나면 스택에 push하고, 연산자를 만나면 스택에서 두 개의 피연산자를 pop하여 연산을 수행한 후 결과를 다시 스택에 push합니다.

## 스택의 활용 사례를 설명하시기 바랍니다.
1. **함수 호출의 관리**: 재귀 함수 호출 시, 함수 호출 스택을 사용하여 각 함수 호출 상태를 관리합니다.
2. **수식의 괄호 유효성 검사**: 수식의 괄호가 올바르게 매칭되는지 확인하기 위해 스택을 사용합니다.
3. **그래프 탐색**: DFS(Depth First Search) 알고리즘은 스택을 사용하여 구현할 수 있습니다.
4. **Prefix, Infix, Postfix**: Prefix, Infix, Postfix 표기법을 사용한 계산을 구현할 때 스택을 사용합니다.
5. **Undo 기능**: 텍스트 편집기 등의 소프트웨어에서 실행 취소(undo) 기능을 구현할 때, 이전 상태를 스택에 저장합니다.
