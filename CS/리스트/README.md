# 리스트


# 리스트의 구현
- 1차원 배열
- 단순연결리스트(노드가 다른 노드를 가리킴)
- 이중연결리스트(노드가 순방향, 역방향으로 이중 연결됨)
- 원형연결리스트(노드의 시작과 끝이 연결되어 있음)

### 리스트 주요 메서드

```java
item[] <- 원소들이 저장되는 배열
numItems[] <- 원소자리의 인덱스

add(i,x) <- 리스트의 i번째 원소로 x를 삽입한다.
append(x) <- 리스트 맨 뒤에 원소 x를 추가한다.
remove(i) <- 리스트의 i번째 원소를 삭제한다.
removeItem(x) <- 리스트의 처음으로 나타나는 x를 삭제한다.
get(i) <- 리스트 i번째 원소를 알려준다.
set(i,x) <- 리스트 원소 i를 x로 대체한다.
indexOf(x) <- 원소 x가 리스트의 몇 번째 원소이지 알려준다.
len() <- 리스트의 총 원소 수를 알려준다. 
isEmpty() <- 리스트가 빈 리스트인지 알려준다.
clear() <- 리스트를 깨끗이 청소한다
```

# 배열(Array)

---

- 동일한 타입의 원소들이 연속적인 메모리 공간에 할당
- 각 항목이 하나의 원소에 저장(기본 자료구조)
- 인덱스를 이용하여 원소에 접근(삽입 &삭제 연산 제외) → O(1)
    
    (*O(1) :  가장 빠른 알고리즘 유형)
    
- 배열명 = 배열의 첫번째 원소의 레퍼런스를 저장(레퍼런스=주소)
    
    ex) a[i]= 인덱스 i를 가지는 원소를 가리키는 레퍼런스
    
- 각 원소 a[i]는 a가 가지고 있는 레퍼런스에 원소의 크기(바이트) * i를 더하여 a[i]의 레퍼런스를 계산
    
    a[i] = a + (원소의 크기 * i)
    

## Overflow

: (빈 자리가 없어) 새 항목을 삽입할 수 없는 상황

- 배열은 사용 전 미리 정해진 크기의 메모리 공간을 할당 받음(컴파일 할 때)
- 해결방안 → 동적배열

---

## 동적배열

---

: 프로그램이 실행되는 동안 할당된 배열(자바에서는 ArrayList가 동적 배열로 사용됨)

overflow 발생하면 배열크기 2배  확장, 3/4비어잇으면 1/2로 축소(메모리낭비 줄임)

↔ 정적배열 : 크기가 정해져 있는 배열

### ArrList 클래스

- 자바에서 리스트를 배열로 구현한 클래스
- insertLast()
    
    가장 뒤에 새 항목 삽입하는 메서드
    
- insert(item, int k)
    
     새 항목을 k-1번(k번 인덱스) 항목 다음에 삽입
    

### **LinkedList 클래스**

- ****이중 연결 리스트로 구현
- 자바의 List, Deque, Queue 인터페이스를 구현

# 단순연결리스트

---

- 동적 메모리 할당을 이용해 리스트 구현
- 가장 간단한 형태의 자료구조
- 노드가 생성될 때마다 메모리 할당 후 노드 저장
- 동적 메모리를 할당 후 노드를 저장, 노드는 레퍼런스를 이용하여 다음노드를 가리키며 노드를  한 줄로 연결
    - 마지막 노드는 null을 가리킴
- 삽입이나 삭제 시 항목들의 이동이 필요없음
- 순차탐색
- 대부분의 경우 배열은 빈공간을 가지고 있으나 연결리스트는 빈공간 없음

## 배열리스트와 연결리스트 비교

- 배열리스트
    - 시작부터 고정된 크기 지정(정적)
    - 연속된 공간에 원소 저장
    - 정렬이나 조회 할때 용이
    - 원소당 필요공간이 연결리스트에 비해 적음
- 연결리스트
    - 원소가 들어오는 대로 공간을 할당(동적)
    - 비교적 삽입, 삭제 용이
    - 연속성이 없음
    - 원소의 링크를 위한 공간이 추가로 필요

### 배열의 크기 축소

- 중간에 있는 원소 삭제 → size 1 감소
- 삭제된 원소 뒤에 있는 원소들 앞으로 당김
- 배열의 크기가 1/4가 되면 배열 크기 1/2축소
- 예시
    - 배열 크기 : 8, 현재 두 개의 항목만 있다고 가정
    - 항목 수가 배열크기의 1/4일 때(3/4비어있을 때) 배열 크기 1/2축소 ⇒ 배열 크기 4
        
        ⇒ 축소된 배열 절반은 항목, 나머지 절반은 비어있는 상태로 만들기 위함
        

### 수행시간

- 인덱스를 이용하여 배열 원소에 접근 → **O(1)**
- 삽입, 삭제의 경우 삭제 항목 뒤 따르는 항목들이 이동해야하므로 최악의 경우 → O(N)
- 새 항목 가장 뒤에 삽입 → **O(1)**
- 배열의 크기 확대&축소(최악의 경우) → **O(N)**
- 상각분석에 따르면 삽입, 삭제의 평균 수행시간은 → **O(1)**
- 삽입, 삭제 연산 (각각 상수 개의 레퍼런스를 갱신하므로) → **O(1)**
    - insertAfter(), deleteAlfter() 경우 특정 노드 레퍼런스가 주어지지 않으면 head로 부터 P를 찾기 위해 search() 수행 하므로 → **O(n)**
- 탐색 연산(순차 탐색하므로) → O(N)

### 이진 탐색 알고리즘

배열리스트에서 원소를 검색하는 시간을 줄여주는 알고리즘이다. 최악의 경우 O(log n), 최선의 경우 O(1) 시간이든다.

```java
// A[p..r]에서 원소 x의 인덱스를 리턴
binarySearch(A[], p, r, x):
	if(p > r) return NOT_FOUND
    else
    	q <- (p+r)/2
        if(x = A[q]) return q
        else if (x < A[q]) return binarySearch(A, p, q-1, x)
        else binarySearch(A, p, q+1, x)
```

# 이중연결리스트(양방향 연결리스트)

---

- 각 노드가 두 개의 레퍼런스를 가지고 각각 이전 노드와 다음 노드를 가리키는 연결리스트
- 각 노드 앞뒤로 링크되는 양방향 연결리스트는 다음노드뿐 아니라 직전 노드에 대한 링크도 가져 한 노드만 알면 앞 뒤로 자유롭게 이동가능한 연결리스트
    - 단순 연결리스트 = 단방향, 반대 방향 X
        
        → 각 노드의 앞뒤로 링크를 만들어 문제 해소
        
        → 노드 마다 추가로 한 개의 레퍼런스를 추가로 저장해야 한다는 단점을 가짐
        
- 자바의 LinkedList 클래스는 이중 연결 리스트로 구현

### 수행시간

- 삽입, 삭제 연산 (각각 상수 개의 레퍼런스를 갱신하므로)→ O(1)
- 탐색 연산(순차 탐색하므로) → O(N)
    - 노드의 삽입, 삭제가 양방향으로 쉽게 이루어지므로 단순연결리스트 보다 유리

# **원형 연결리스트**

---

- 마지막 노드가 첫 노드와 연결된 단순연결리스트
    - head가 더미 헤드 노드를 가리키도록 하는 대신 마지막 노드에 대한 레퍼런스 tail을 두고, 마지막 노드가 맨 앞의 더미 헤드 노드를 링크하는 방식
    - 마지막 노드의 레퍼런스가 저장된 last 가 단순연결리스트의 head 같은 역할
- 연결 리스트에서는 마지막 노드에 대한 접근성 최악
    
    → 마지막 노드가 첫 번째 노드를 링크하여 문제 해소
    
- 리스트가 empty 가 아니면 어떤 노드도 null레퍼런스를 가지지 않으므로 프로그램에서 null 조건을 검사하지 않아도 됨
- 탐색 시 단방향으로 만 가능 (반대방향 → 무한루프 우려)

### 원형연결리스트의 응용

- 여러사람이 차례로 돌아가며 하는 게임 구현 시 적합한 자료구조
- 많은 사용자들이 동시에 사용하는 컴퓨터에서 CPU시간을 분할하여 작업들에 할당하는 운영체제에 사용
- 이항힙(Binomial Heap), 피보나치힙(Pfibonacci Heap) → 우선순위큐 구현 시 부분 사용

### 수행시간

- 삽입, 삭제 연산 (각각 상수 개의 레퍼런스를 갱신하므로)→ O(1)
- 탐색 연산(순차 탐색하므로) → O(N)
- 마지막노드, 첫 노드 방문 → O(1)

---

# **가상 질의응답**

---

**질문 1: 1차원 배열과 연결 리스트의 주요 차이점은 무엇인가요?**

1차원 배열은 연속적인 메모리에 동일한 타입의 원소들이 저장되어 인덱스를 이용한 빠른 접근이 가능하지만, 삽입과 삭제 시 전체 원소를 이동해야 합니다. 반면 연결 리스트는 동적으로 메모리를 할당받아 노드 간의 레퍼런스로 연결되며, 삽입과 삭제가 용이하지만 원소 접근 시 순차 탐색이 필요합니다.

**추가 질문: 배열의 크기를 동적으로 조절하는 방법에 대해 설명해보세요.**

배열의 크기를 동적으로 조절하기 위해 동적 배열을 사용하며, 자바에서는 ArrayList가 이를 구현합니다. 원소 추가 시 배열의 크기를 두 배로 확장하고, 배열의 3/4이 비어 있을 때 크기를 절반으로 축소하여 메모리 사용을 효율화합니다.

---

**질문 2: 단순 연결 리스트와 이중 연결 리스트의 차이점은 무엇인가요?**

단순 연결 리스트는 각 노드가 다음 노드를 가리키는 단방향 리스트입니다. 반면, 이중 연결 리스트는 각 노드가 이전 노드와 다음 노드를 가리키는 양방향 리스트로, 삽입과 삭제가 더 용이하지만 추가적인 메모리가 필요합니다.

**추가 질문: 이중 연결 리스트를 사용하는 예시를 들어보세요.**

이중 연결 리스트는 양방향 탐색이 필요한 웹 브라우저의 '뒤로 가기'와 '앞으로 가기' 기능 구현에 적합합니다. 각 노드는 방문한 페이지를 가리키며, 이전 페이지와 다음 페이지로 이동이 가능합니다.

---

**질문 3: 원형 연결 리스트의 특징과 장점은 무엇인가요?**

원형 연결 리스트는 마지막 노드가 첫 번째 노드를 가리키는 리스트로, 마지막 노드에서 첫 번째 노드로의 접근이 용이합니다. 이는 null 조건 검사를 줄여주며, 특정 상황에서 효율적인 자료구조로 사용될 수 있습니다.

**추가 질문: 원형 연결 리스트의 응용 사례를 설명해보세요.**

원형 연결 리스트는 여러 사람이 차례로 돌아가며 하는 게임이나, CPU 시간을 분할하여 작업에 할당하는 운영체제의 라운드 로빈 스케줄링 알고리즘에 사용됩니다.

---

**질문 4: 배열과 연결 리스트의 수행 시간에서 차이를 보이는 이유는 무엇인가요?**

배열은 연속적인 메모리 공간에 저장되어 인덱스를 이용한 접근이 빨라 O(1) 시간이 소요되지만, 삽입과 삭제 시 원소 이동이 필요하여 O(N) 시간이 소요됩니다. 연결 리스트는 동적 메모리 할당으로 삽입과 삭제가 빠르지만, 순차 탐색이 필요하여 원소 접근 시 O(N) 시간이 소요됩니다.

**추가 질문: 이진 탐색 알고리즘이 배열에서 사용되는 이유는 무엇인가요?**

이진 탐색 알고리즘은 정렬된 배열에서 중간 원소를 기준으로 검색 범위를 반으로 줄여가며 탐색을 진행해 O(log n) 시간 내에 원소를 찾을 수 있어 효율적입니다. 이는 순차 탐색의 O(N) 시간 복잡도보다 훨씬 빠릅니다.