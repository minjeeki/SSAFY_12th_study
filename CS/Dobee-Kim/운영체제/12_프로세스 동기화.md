# 12-1 동기화란

## 동기화의 의미
- 프로세스들 사이의 수행 시기를 맞추는 것
- 실행 순서 제어 : 프로세스를 올바른 순서대로 실행
- 상호 배제 : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

### 실행 순서 제어를 위한 동기화
- 동시에 실행되는 프로세스를 올바른 순서대로 실행하는 것

### 상호 배제를 위한 동기화
- 공유 불가능한 자원의 동시 사용을 피하기 위해 사용되는 알고리즘
> 생산자와 소비자 문제

## 공유 자원과 임계 구역
### 공유자원
- 프로세스들이 공유하는 공동의 자원
  - 전역 변수, 파일, 입출력장치, 보조기억 장치 등이 될 수 있음
### 임계구역
- 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
- 두 개 이상의 프로세스가 임계 구역에 진입하고자 하면 둘 중 하나는 대기해야함
### 레이스 컨디션(race condition)
- 잘못된 실행으로 인해 여러 프로세스가 동시 다발적으로 임계 구역의 코드를 실행하여 문제가 발생한 경우
  - 데이터의 일관성이 깨짐
> 발생 이유
> 고급 언어는 컴퓨터가 이해할 수 있는  .여러줄의 저급 언어로 변환되고, 이를 실행하는 과정에서 문맥 교환이 일어날 수 있음.

### 임계 구역 문제를 해결하는 방법
- 상호 배제(mutual exclusion) : 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없음.
- 진행(progress) : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 함.
- 유한 대기(bounded waiting) : 한 프로세스가 임계 구역에 진입하고 싶다면, 그 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다.(임계 구역에 들어오기 위해 무한정 대기해선 안됨)

# 12-2 동기화 기법
## 뮤텍스 락(mutex lock)
- 동시에 접근해서는 안되는 자원에 접근하지 않도록 만드는 도구 = 상호 배제를 위한 동기화 도구
> 옷가게 탈의실 안에 사람이 있는지 없는지 알 수 없는 상황에서 사용중이면 자물쇠를 걸어두기 -> 탈의실을 열어보고 자물쇠가 걸려있다면 안에 사람이 있다고 판단
- 하나의 전역 변수와 두 개의 함수로 구현
  - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
  - 임계 구역을 잠그는 역할 : acquire 함수
    - 프로세스가 임계 구역에 진입하기 전에 호출하는 함수. 임계 구역이 잠겨 있다면 임계 구역이 열릴 때까지 구역을 반복적으로 확인하고, 열려 있다면, 임계 구역을 잠그는 함수
  - 임계 구역의 잠금을 해제하는 역할 : release 함수
     - 임계 구역에서의 작업이 끝나고 호출하는 함수. 현재 잠긴 임계 구역을 열어주는 함수
 - 바쁜 대기(busy wait) : 임계 구역이 잠겨있는지 반복적으로 확인하는 대기 방식
```
acquire(){
  while (lock == true) /*만약 임계 구역이 잠겨 있다면*/
  ;                    /*임계 구역이 잠겨 있는지를 반복적으로 확인*/
  lock = true;         /*만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금*/
// 임계 구역
release(){
  lock = false;        /*임계 구역 작업이 끝났으니 잠금 해제*/
}
```
## 세마포(semaphore)
- 공유 자원이 여러 개 있는 상황에서도 적용이 가능한 동기화 도구
- 뮤텍스 락은 하나의 공유 자원에 접근하는 프로세스를 상정한 방식 -> 탈의실이 여러개 있는 경우를 가정하고 만든 동기화 도구가 세마포
- 철도 신호기에서 유래한 단어로, 멈춤 신호와 가도 좋다의 신호로서 임계 구역을 관리함
- 하나의 변수와 두 개의 함수로 구현
  - 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역변수 S
  - 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait 함수
  - 임계 구역 앞에서 기다리는 프로세스에 이제 가도 좋다고 신호를 주는 signal 함수
```
wait() {
  while (S <= 0) /*임계 구역에 접근할 수 있는 프로세스 개수가 0 이하라면*/
  ;              /*사용할 수 있는 자원이 있는지 반복적으로 확인하고,*/
  S--;           /*임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 감소시키고 임계 구역에 진입함*/
}
signal() {
  S++;           /*임계 구역에서의 작업을 마친 뒤 S를 1 증가시킴*/
}
```

- 문제 : 사용할 수 있는 공유 자원이 없는 경우, 프로세스는 무작정 무한히 반복하며 S를 확인해야 함
- 그래서 실제로 세마포는 더 좋은 방법을 사용함
  - 만일 사용할 수 있는 자원이 없을 경우 wait 함수는 해당 프로세스 상태를 대기 상태로 만들고
  - 그 프로세스의 PCB를 세마포를 위한 대기 큐에 집어 넣음
  - 다른 프로세스가 임계 구역에서의 작업이 끝나고 signal 함수를 호출하면
  - signal 함수는 대기 중인 프로세스를 대기 큐에서 제거하고, 프로세스 상태를 준비 상태로 변경한 뒤 준비 큐에 올려줌
- 세마포를 활용해 실행순서 제어도 가능함
  - 세마포의 변수 S를 0으로 두고, 먼저 실행할 프로세스 뒤에 signal 함수, 다음에 실행할 프로세스 앞에 wait 함수 붙이기

## 모니터(monitor)
- 사용자가 사용하기 훨씬 편리한 도구인 모니터
  - 세마포는 잘못된 코드로 인해 예기치 못한 결과를 얻을 수도 있음 -> 이를 해결
- 공유 자원과 공유 자원에 접근하기 위한 인터페이스(통로)를 묶어 관리함 -> 프로세스는 반드시 인터페이스를 통해서만 공유 자원에 접근하도록 함
  - 공유 자원을 다루는 인터페이스에 접근하기 위한 큐를 만들고, 모니터 안에 항상 하나의 프로세스만 들어오도록 함
  - 모니터는 조건 변수를 활용해 프로세스 순서를 제어함
    - 조건 변수로는 wait과 signaml 연산을 수행할 수 있음
    - wait : 호출한 프로세스의 상태를 대기 상태로 전환하고 일시적으로 대기 큐에 삽입하는 연산
    > 모니터에 진입하기 위해 삽입되는 큐 (상호 배제를 위한 큐)와  wait가 호출되어 실행이 중단된 프로세스들이 삽입되는 큐(조건 변수에 대한 큐)는 다름
    - 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait을 통해 실행을 중단함
    - 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개함

# CS 질문
## 임계 영역(Critical Section)에 대해 설명해주세요.
임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다.

## 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.
공유된 자원에 여러개의 프로세스가 동시에 접근하게 되면 임계 영역(Critical Section) 문제가 발생할 수 있고, 이를 해결 하기 위해 데이터를 한번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야합니다.
동기화 도구에는 대표적으로 뮤텍스와 세마포어가 있습니다.

가장 큰 차이점은 동기화 대상의 개수입니다.
Mutex는 동기화 대상이 오직 1개 일 때 사용하고, Semaphore는 동기화 대상이 1개 이상일 때 사용합니다.

세마포어는 뮤텍스가 될수 있지만, 뮤텍스는 세마포어가 될 수 없습니다. 뮤텍스는 0과 1로 이루어진 이진상태를 가지므로 Binary Semaphore라고도 합니다.

뮤텍스는 자원 소유 가능 + 책임을 가지는 반면, 세마포어는 자원 소유가 불가합니다. 뮤텍스는 상태가 0, 1 뿐이므로 Lock을 가질 수 있습니다.

현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 lock을 획득한 프로세스가 반드시 그 락을 해제해야 합니다.

## 프로세스 동기화란 무엇이며, 왜 중요한가요?
프로세스 동기화는 여러 프로세스가 동시에 실행될 때 자원에 대한 접근 순서를 조정하여 충돌을 방지하는 기법입니다. 
동기화가 없으면 두 프로세스가 동시에 자원을 수정하거나 읽는 과정에서 데이터 무결성이 깨질 수 있습니다. 따라서 동기화는 데이터의 일관성을 유지하고 충돌을 방지하는 데 매우 중요합니다.

## 생산자-소비자 문제(Producer-Consumer Problem)를 설명하고 이를 해결하는 동기화 기법에 대해 말해보세요.
생산자-소비자 문제는 생산자가 데이터를 생성하고 소비자가 데이터를 소비하는 과정에서 데이터 버퍼가 공유되는 문제입니다.
이를 해결하기 위해 세마포어를 사용하여 버퍼가 가득 찬 경우 생산자를 대기시키고, 비어 있는 경우 소비자를 대기시킵니다.

## 스핀락(Spinlock)은 어떤 상황에서 사용되며, 일반적인 락과 어떤 차이가 있나요?
스핀락은 락을 얻을 때까지 계속해서 반복적으로 확인하는 방식입니다. 일반적인 락과 달리, 스핀락은 락을 얻지 못한 상태에서 대기하지 않고 계속해서 CPU 자원을 사용하여 락을 확인합니다. 따라서 짧은 시간 동안만 기다려야 할 때 스핀락이 더 효율적이지만, 장시간 대기해야 하는 경우 CPU 자원을 낭비할 수 있습니다.

## 바운디드 대기(Bounded Waiting)는 무엇이며, 동기화 문제에서 왜 중요한가요?
바운디드 대기는 어떤 프로세스가 자원을 무한정 기다리지 않도록 보장하는 개념입니다. 이를 통해 모든 프로세스가 일정 시간 내에 자원에 접근할 수 있도록 보장하며, 이는 공정성을 보장하는 중요한 요소입니다. 바운디드 대기가 없으면 특정 프로세스가 계속 대기 상태에 빠지는 기아(starvation) 상태가 발생할 수 있습니다.

## 멀티 스레딩 환경에서 동기화 문제가 발생하면 어떤 성능 이슈가 발생할 수 있나요?
멀티 스레딩 환경에서 동기화 문제가 발생하면 병목 현상, CPU 오버헤드, 컨텍스트 스위칭 비용 증가와 같은 성능 이슈가 발생할 수 있습니다. 특히, 뮤텍스나 세마포어를 과도하게 사용할 경우 성능 저하가 일어날 수 있습니다. 또한, 락 경합(lock contention)이 발생하면 스레드가 자원을 대기하는 시간이 길어져 응답성이 떨어질 수 있습니다.
