# 10-1. 프로세스 개요

- 프로세스 : 실행중인 프로그램
- 보조기억 장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 그 프로그램은 프로세스가 됨
- 포그라운드 프로세스(foreground process) : 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스(background process) : 사용자가 보지 못하는 뒤편에서 실행
- 서비스 : 사용자와 상호작용하지 않고, 정해진 일만 수행하는 백그라운드 프로세스, 유닉스 체제에서는 데몬이라고 부름

## 프로세스 제어 블록

> 모든 프로세스는 실행을 위해 CPU를 필요로 하지만, CPU 자원은 한정적임

> 프로세스들은 돌아가며 한정된 시간만큼만 CPU를 이용함 -> 타이머 인터럽트가 발생하면 자신의 차례를 양보하고, 다음 차례가 올 때까지 기다림

> 운영체제는 번갈아 수행되는 프로세스의 실행 순서를 관리하고, 프로세스에 CPU를 비롯한 자원을 배분함. 이 역할을 수행하는게 PCB

- PCB : 프로세스와 관련된 정보를 저장하는 자료 구조

### 특징

- PCB는 커널 영역에 생성됨
- 프로세스 생성 시에 만들어지고 실행이 끝나면 폐기함
  - 새로운 프로세스가 생성되었다 = 운영체제가 PCB를 생성했다.
  - 프로세스가 종료되었다 = 운영체제가 해당 PCB를 폐기했다

### PCB에 담기는 정보

- 프로세스ID
  - PID라고 하며, 특정 프로세스를 식별하기 위해 부여하는 고유 번호
  - 같은 일을 수행하는 프로그램이라고 해도, 두 번 실행하면, PID가 다른 두 개의 프로세스가 실행됨
- 레지스터 값
  - 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원함
  - PCB 안에는 해당 프로세스가 실행하며 사용했던 레지스터 값들이 담김
- 프로세스 상태
- CPU 스케줄링 정보
- 메모리 관리 정보
  - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
  - 베이스 레지스터, 한계 레지스터 값, 페이지 테이블 정보
- 사용한 파일과 입출력 장치 목록

## 문맥 교환

- 하나의 프로세스에서 다른 프로세스로 실행 순서가 넘어가면 -> 지금까지의 중간 정보를 백업함
- 문맥 : 중간 정보, 하나의 프로세스 수행을 재개하기 위해 기억해야할 정보
  - PCB에 기록되는 정보들은 문맥임
- 인터럽트가 발생하면, 운영체제는 해당 프로세스의 PCB를 문맥에 백업 -> 뒤이어 실행할 프로세스B의 문맥을 복구함 => 자연스럽게 실행되는 프로세스가 바뀜
- 문맥 교환 : 기존 프로셋의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것
  > 문맥 교환을 너무 자주 하면 오버헤드가 발생할 수 있음

## 프로세스의 메모리 영역

사용자 영역에 프로세스가 어떻게 배치되는가

### 코드 영역

- 텍스트 영역
- 실행할 수 있는 코드(기계어로 이루어진 명령어) 저장
- CPU가 실행할 명령어가 담겨 있기에 쓰기 금지, 읽기 전용 공간

### 데이터 영역

- 프로그램이 실행되는 동안 유지해야할 데이터 저장

  - ex : 전역 변수 (프로그램이 실행되는 동안 유지되며, 프로그램 전체에 접근할 수 있는 변수)

- 코드 영역과 데이터 영역은 프로그램은 크기가 변하지 않음
  - 프로세스를 구성할 명령어가 바뀔 일도 없고, 데이터 영역에 저장될 내용은 프로그램 실행동안 유지될 데이터임
  - 정적 할당 영역이라고 부름
- 힙 영역과 스택 영역은 프로세스 실행과정에서 크기가 변할 수 있음
  - 동적 할당 영역

### 힙 영역

- 프로그래머가 직접 할당할 수 있는 저장공간
- 언젠가 메모리 공간을 반환해야함 (더 이상 해당 메모리 공간을 사용하지 않겠다고 선언)
- 메모리 누수 : 메모리 공간을 반환하지 않을 시, 할당한 공간이 계속 남아 메모리 낭비를 초래하는 것

### 스택 영역

- 데이터를 일시적으로 저장하는 공간
  - ex: 매개변수, 지역변수
- 실시간으로 크기가 변할 수 있으므로 동적 할당 영역
- 일반적으로 스택영역은 높은 주소에서 낮은 주소로, 힙 영역은 낮은주소에서 높은 주소로 할당이 되어, 새로 할당되는 주소가 겹칠일이 없도록 함

# 10-2 프로세스 상태와 계층 구조

## 프로세스 상태

- 생성 상태 : 프로세스를 생성 중인 상태
- 준비 상태 : 당장이라도 CPU에 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니라 기다리는 상태
- 실행 상태 : CPU를 할당받아 실행 중인 상태. 프로세스가 할당된 시간을 모두 사용하면 다시 준비 상태가 됨. 실행 도중 입출력장치를 사용하여 입출력 장치가 끝날 때까지 기다려야 한다면 대기 상태가 됨.
- 대기 상태 : 특정 이벤트가 일어나길 기다리는 상태. 대표적으로 입출력 장치의 작업을 기다리는 상태
- 종료 상태 : 프로세스가 종료된 상태. 운영체제는 PCB와 프로세스가 사용한 메모리를 정리함
- 프로세스 상태 다이어그램
  ![alt text](img/image8.png)

## 프로세스 계층 구조

- 프로세스 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있음
  - 부모 프로세스 : 새 프로세스를 생성한 프로세스
  - 자식 프로세스 : 부모 프로세스에 의해 생성됨
- 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID(Parent PID)를 기록함

## 프로세스 생성 기법

- fork : 자신의 복사본을 자식 프로세스에 생성 (복사)
  - 부모 프로세스의 자원들이 상속됨. PID나 저장된 메모리 위치는 다름
- exec : 자신의 메모리 공간을 다른 프로그램을 교체 (새로운 프로그램 내용으로 전환하여 실행하는 시스템 호출) (옷 갈아입기)
  - 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화됨.
  - exec을 하지 않으면, 부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행함

# 10-3. 스레드

- 스레드 : 실행의 단위. 프로세스를 구성하는 실행의 흐름 단위.
  - 하나의 프로세스는 여러개의 스레드를 가질 수 있음
  - 스레드를 이용하면, 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있음
- 단일 스레드 프로세스 : 실행의 흐름 단위가 하나
  - 스레드 개념 도입 후, 하나의 프로세스가 여러 일을 동시에 처리할 수 있게됨
- 프로세스의 스레드들은 실행에 필요한 최소한의 정보(프로그램 카운터를 포함한 레지스터, 스택)만을 유지한 채 프로세스 자원을 공유하며 실행됨 (프로세스의 자원을 공유함)
  > 리눅스는 프로세스와 스레드를 크게 구분하지 않음. 프로세스와 스레드 모두 실행의 문맥이라는 점에서 동등하다고 간주하고 태스크라는 이름으로 통일하여 명명.

## 멀티프로세스와 멀티스레드

- 멀티프로세스 : 여러 프로세스를 동시에 실행하는 것
- 멀티스레드 : 여러 스레드로 프로세스를 동시에 실행하는 것
  > 동일한 작업을 수행하는 단일 스레드 프로세스를 여러 개 실행하는 것 vs 하나의 프로세스를 여러 스레드로 실행하는 것
- 프로세스끼리는 기본적으로 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유함
- 같은 프로세스 내 스레드는 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유하고, 열린 파일과 같은 프로세스 자원을 공유함.
- 멀티 스레드
  - 장점 : 스레드는 프로세스의 자원을 공유하기 때문에 협력과 통신에 유리함, 메모리를 효율적으로 사용할 수 있음
  - 단점 : 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있음
- 멀티 프로세스
  - 장점 : 하나의 프로세스에 문제가 생겨도 다른 프로세스에는 지장이 적거나 없음
  - 단점 : 같은 프로그램을 실행하기 위해 메모리에 동일한 내용들이 중복해서 존재할 수 있음 -> 메모리 낭비

> 프로세스 간 통신(IPC; inter-Process-Communication)

    - 프로세스간 기본적으로 자원을 공유하진 않지만, 자원을 공유하고 데이터를 주고받을 수 있음
    - 파일을 통한 프로세스 간 통신
    - 공유 메모리 활용
    - 소켓, 파이프 등을 통해 통신

# CS 질문

### 프로세스와 쓰레드의 차이에 대해 설명해주세요.

프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다.

쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.

### 데드락에 대해 설명해주세요.

둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.
예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 자원 B를 필요로 하고 P2는 자원 A를 필요로 한다면 두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 됩니다.

### 멀티 프로세스와 멀티 쓰레드의 특징에 대해 설명해주세요.

멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만 멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.

멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만 하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다.

### 컨텍스트 스위칭(Context Switching)이 무엇인지 설명해주세요.

멀티 프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업을 말합니다.

### 멀티 스레딩의 문제점

멀티 프로세스 기반으로 프로그래밍할 때는 프로세스 간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없었지만 멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써줘야 한다. 서로 다른 스레드가 데이터와 힙 영역을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다.

그렇기 때문에 멀티스레딩 환경에서는 동기화 작업이 필요하다. 동기화를 통해 작업 처리 순서를 컨트롤 하고 공유 자원에 대한 접근을 컨트롤 하는 것이다. 하지만 이로 인해 병목현상이 발생하여 성능이 저하될 가능성이 높다. 그러므로 과도한 락으로 인한 병목현상을 줄여야 한다.

### 멀티 스레드 vs 멀티 프로세스

멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 안고 있다. 반면 멀티 프로세스 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다. 이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.

### 프로세스간 통신은 어떻게 하나요?

- 스레드는 서로의 자원을 공유하고 있기 때문에 스레드간 통신은 별도의 자원을 사용하지 않아도 됩니다. 하지만 프로세스의 경우 데이터를 공유하고 있지 않기 때문에 공유메모리를 사용하는 방법과 메세지전달 방법으로 2가지 방법이 있습니다.

- 공유 메모리 : 프로세스들이 주소 공간 일부를 공유하는 것을 의미합니다. 커널이 메모리에 별도의 shared memory를 할당합니다. 프로세스들은 shared memory의 정보를 이용해 서로 데이터를 전달 및 공유 합니다.

- 메세지 전달 : 시스템 콜을 이용하여 구현합니다. 시스템 콜이란 커널영역에서 사용하는 명령어들이며 커널을 통해 메세지를 보내고 받습니다. 즉, 프로세스들 사이에 커널이 데이터를 중재하는 것입니다. 예를 들어, pipe , socket , message queue 가 있습니다.

2가지 방식의 장단점 역시 존재합니다. 공유메모리를 사용할 경우 간단하지만 메모리를 공유하기 때문에 자원 동기화의 문제가 있을 것이며 메세지를 전달한다면 동기화 문제는 없지만 속도가 느립니다.
