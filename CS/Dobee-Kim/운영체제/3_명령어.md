# 1. 소스 코드와 명령어
## 고급 언어와 저급언어
- 고급 언어 : 사람을 위한 언어 = 프로그래밍 언어 = 사람이 이해하고 작성하기 쉽게 만들어진 언어
- 저급 언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어
> 저급언어
- 기계어 : 0과 1의 명령어 비트로 이루어진 언어
- 어셈블리어 : 기계어를 읽기 편한 형태로 번역한 언어 (프로그래밍 언어와는 다르며, 한줄 한줄이 명령어)

## 컴파일 언어와 인터프리터 언어
- 고급 언어를 저급 언어로 변환하는 방식
- 대부분의 언어는 컴파일 방식과 인터프리트 방식이 섞여있음
### 컴파일 언어
- 컴파일러에 의해 변환
- C
- 소스 코드 전체가가 저급언어로 변환됨. 코드 내에 오류를 하나라도 발견하면 컴파일에 실패함
- 목적 코드 : 컴파일러를 통해 저급 언어로 변환된 코드 (컴파일 결과)

### 인터프리터 언어
- 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어
- Python
- 소스 코드를 한줄씩 차례로 실행
- N번쨰 줄에 문법 오류가 있더라도 N-1번째 줄까지는 올바르게 실행
- 컴파일 언어보다 속도가 느림

## 목적 파일 vs 실행 파일
- 목적 파일 : 목적 코드로 이루어진 파일
- 실행 파일 : 실행 코드로 이루어진 파일
- 링킹 : 목적 코드가 실행 파일이 되기 위해 거쳐야하는 작업 (해당 파일에 없는 기능을 다른 파일로부터 연결 짓는 작업이 필요함. ex: 외부 함수나 라이브러리 참조할 경우 기계어로 바꾼다고 바로 실행X)

# 2. 명령어의 구조
## 연산 코드와 오퍼랜드
- 명령어 : 연산 코드와 오퍼랜드로 구성되어 잇음
- 연산코드 : 명령어가 수행할 연산, 연산자
- 오퍼랜드 : 연산에 사용할 데이터 / 연산에 사용할 데이터가 저장된 위치, 피연산자
### 오퍼랜드
- 숫자나 문자 등을 나타내는 데이터 / 메모리나 레지스터 주소
- 주로 주소값이 담김. 주소 필드라고 부름
- 오퍼랜드의 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어로 나뉨
### 연산 코드
- 4가지 종류가 있음
  - 데이터 전송
  - 산술/논리 연산
  - 제어 흐름 변경
  - 입출력 제어

## 주소 지정 방식
- 왜 오퍼랜드 필드에 데이터가 아닌 메모리나 레지스터의 주소를 담는가?
  - 명령어의 길이 때문
  - 오퍼랜드 필드 안에 주소값이 담긴다면, 표현할 수 있는 데이터의 크기는 하나의 메모리 주소 or 레지스터 주소에 저장할 수 있는 공간만큼 커짐
- 유효 주소 : 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식 : 연산에 사용할 데이터 위치를 찾는 방법, 유효 주소를 찾는 방법
  ### 즉시 주소 지정 방식
  - 연산에 사용할 데이터를 오퍼랜드 필드이 직접 명시하는 방식
  - 표현할 수 있는 데이터의 크기가 작아짐
  - 연산에 사용할 데이터를 메모리나 레지스터로 찾는 과정 없으므로 속도가 빠름
  > 연산 코드 | 연산에 사용할 데이터
  ### 직접 주소 지정 방식
  - 오퍼랜드 필드에 유효 주소를 직접적으로 명시
  - 표현할 수 있는 데이터의 크기가 커짐
  - 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어듦 ( 표현할 수 있는 유효 주소에 제한이 생길 수 있음)
  > 연산 코드 | 유효 주소 ---> 메모리 || 연산에 사용할 데이터 ||
  ### 간접 주소 지정 방식
  - 유효 주소의 주소를 오퍼랜드 필드에 명시
  - 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓음
  - 두 번의 메모리 접근이 필요하기 때문에 일반적으로 느린 방식
  > 연산 코드 | 유효 주소의 주소 ---> 메모리 || 유효 주소 ---> | 연산에 사용할 데이터 ||
  ### 레지스터 주소 지정 방식
  - 직접 주소 지정 방식과 비슷, 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
  - CPU 외부에 있는 메모리에 접근하는 것보다 내부에 있는 레지스터에 접근하는 것이 빠름
  - 직접 주소 지정방식과 비슷한 문제 표현할 수 있는 레지스터 크기에 제한이 생김
  > 연산 코드 | 유효 주소 ---> CPU || 레지스터 || 연산에 사용할 데이터 || ||
  ### 레지스터 간접 주소 지정 방식
  - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소인 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시 
  - 메모리에 접근하는 횟수가 한 번으로 줄어듬 -> 레지스터 간접 주소 접근 방식이 간접 주소 지정 방식보다 빠름

  > 연산 코드 | 유효 주소를 지정한 레지스터 --> CPU || 레지스터 || 유효 주소 || || ---> 메모리 || 연산에 사용할 데이터 ||

## 스택과 큐
###  스택 : 한쪽 끝이 막혀 있는 통과 같은 저장공간
- LIFO(후입선출)
- PUSH : 데이터를 저장하는 명령어
- POP : 저장된 데이터를 꺼내는 명령어
### 큐 : 양쪽이 뚫려 있는 통과 같은 저장 공간
- FIFO(선입선출)


### 질문
- 직접 주소 지정 방식과 레지스터 주소 지정 방식의 용어를 나눠둔 이유가 무엇인가?