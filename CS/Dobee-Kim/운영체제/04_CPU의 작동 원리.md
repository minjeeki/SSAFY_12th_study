# 4-1. ALU와 제어장치
- CPU : 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
- ALU : 계산을 담당
- 제어장치 : 명령어를 읽어 들이고 해석
- 레지스터 : 임시 저장장치

## ALU
- 피연산자와 수행할 연산이 필요
- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어신호를 받아들임
- 연산을 수행한 결과값은 바로 메모리에 저장되지 않고, 일시적으로 레지스터에 저장됨
  - 왜?
  - CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 빠름
  - ALU가 연산할 떄마다 값을 메모리에 접근한다면 CPU의 프로그램 실행 속도를 눚출 것
- 플래그 : ALU가 계산 결과와 더불어 내보내는 것
  - 연산 결과에 대한 추가적인 정보를 내보내야 할 때, 추가적인 상태 정보를 플래그라고 함
  > 이진수만 봐서는 음수인지 양수인지 판단하기 어려움 -> 방금 계산한 결과는 음수라는 추가 정보를 내보냄 -> 이게 플래그
- 플래그의 종류
  1. 부호 플래그 : 연산한 결과의 부호 (음수일 경우 1, 양수일 경우 0)
  2. 제로 플래그 : 연산 결과가 0인지의 여부 (연산 결과가 0일 경우 1, 아닐 경우 0)
  3. 캐리 플래그 : 연산 결과 올림수나 빌림수가 발생했는지 여부 (올림수나 빌림수가 발생할 경우 1, 아닐 경우 0)
  4. 오버플로우 플래그 : 오버플로우 발생여부 (연산 결과가 연산 결과를 담을 레지스터보다 큰 상황) (발생한 경우 1 아닐 경우 0)
  5. 인터럽트 플래그 : 인터럽트가 가능한지 여부 (인터럽트가 가능할 경우 1, 아닐 경우 0)
  6. 슈퍼바이저 플래그 : 커널 모드로 실행중인지(1), 사용자 모드로 실행중인지(0) 나타냄
- 플래그 레지스터라는 레지스터에 저장됨
- 플래그 레지스터 : 플래그 값들을 저장하는 레지스터

## 제어장치
- 제어 신호를 내보내고, 명령어를 해석하는 부품
- 컴퓨터 부품을 관리하고 작동시키기 위한 일종의 전기 신호

### 제어장치가 받아들이는 정보
1. 클럭 신호
- 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위, 컴퓨터의 모든 부품이 클럭 신호라는 박자에 맞춰 작동한다
- 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있음
2. 해석해야 할 명령어
- 명령어 레지스터 : CPU가 해석해야 할 명령어가 저장되는 특별한 레지스터.
- 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야할 내용을 알려줌
3. 플래그 레지스터 속 플래그 값
- 플래그 : ALU 연산에 대한 추가적인 상태 정보
4. 시스템 버스 중 제어 버스로 전달된 제어 신호
- 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들임
- 제어 장치는 CPU 내부와 외부로 제어 신호를 보냄
  - 외부
    - 메모리에 전달 : 메모리에 저장된 값을 읽거나, 새로운 값을 씀
    - 입출력장치에 전달 : 입출력장치의 값을 읽거나, 새로운 값을 씀 
  - 내부
    - ALU에 전달 : ALU가 수행할 연산 지시
    - 레지스터에 전달 : 레지스터 간에 데이터를 이동시키거나, 레지스터에 저장된 명령어 해석

# 4-2. 레지스터
- 프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장됨
> 반드시 알아야 할 레지스터
1. 프로그램 카운터
  - 메모리에서 읽어 들일 명령어의 주소를 저장
  - 명령어 포인터라고도부름
  
2. 명령어 레지스터
  - 해석할 명령어, 메모리에서 읽어 들인 명령어를 저장하는 레지스터
  - 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냄
3. 메모리 주소 레지스터
  - 메모리의 주소를 저장하는 레지스터
  - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침
4. 메모리 버퍼 레지스터
  - 메모리와 주고받을 값을 저장하는 레지스터
  - 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침
> 메모리에 저장된 프로그램을 실행하는 과정
>1. CPU에 실행할 프로그램 : 1000번지부터 1500번지까지 저장. 1000번지에 1101(2)이 저장되어 있음
>2. 프로그램을 처음부터 실행하기 위해 프로그램 카운터에 1000이 저장. = 메모리에서 가져올 명령어가 1000번지에 위치
>3. 1000번지를 읽어들이기 위해 주소 버스로 1000번지를 내보냄. 이를 위해 메모리 주소 레지스터에는 1000이 저장됨
>4. 메모리 읽기 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리에 보내짐
>5. 메모리 1000번지에 저장된 값이 데이터 버스를 통해 메모리 버퍼 레지스터로 전달됨. 프로그램 카운터는 증가되어(1001) 다음 명령어를 읽어들일 준비를 함
>6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동함
>7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어신호를 발생시킴
> - 프로그램 카운터는 지속적으로 증가하며 계속 다음 명령어를 읽어 들일 준비를 함

5. 플래그 레지스터
  - ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장
6. 범용 레지스터
  - 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
  - 데이터와 주소 모두를 저장할 수 있음
7. 스택 포인터
  - `스택 주소 지정 방식`이라는 주소 지정 방식에 사용
8. 베이스 레지스터
  - 프로그램 카운터와 함께 `변위 주소 지정 방식`에 사용

> 스택 포이터와 베이스 레지스터는 주소 지정 방식에 사용될 수 있는 특별한 레지스터

### 스택 주소 지정 방식
- 스택과 스택 포인터를 이용한 주소 지정방식
- 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터, 스택의 어디까지 데이터가 채워져 있는지에 대한 표시
- 스택은 메모리 안에 있음. 
- 스택 영역 메모리 안에 스택처럼 사용할 영역. 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역

### 변위 주소 지정 방식
- 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 연산코드 | 레지스터 | 오퍼랜드
- 오퍼랜드 필드와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등을 ㅗ나뉨

- `상대 주소 지정 방식`
  - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
  > 프로그램 카운터 : 읽어들일 명령어의 주소가 저장되어 있음
  > 오퍼랜드가 -3이면, CPU는 읽어 들이기로 한 명령어로부터 세번째 이전 번지로 접근
  > 오퍼랜드가 3이면, CPU는 읽어 들이기로 한 명령어의 3번째 이후 번지로 접근
- `베이스 레지스터 주소 지정 방식`
  - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
  - 베이스 레지스터는 기준 주소, 오퍼랜드는 기준 주소로부터 떨어진 거리로서의 역할을 함
  > 베이스 레지스터에 200의 값이 있고, 오퍼랜드가 40이라면, 기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라
