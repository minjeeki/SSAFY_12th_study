# 4-1. ALU와 제어장치
- CPU : 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치
- ALU : 계산을 담당
- 제어장치 : 명령어를 읽어 들이고 해석
- 레지스터 : 임시 저장장치

## ALU
- 피연산자와 수행할 연산이 필요
- 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어신호를 받아들임
- 연산을 수행한 결과값은 바로 메모리에 저장되지 않고, 일시적으로 레지스터에 저장됨
  - 왜?
  - CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 빠름
  - ALU가 연산할 떄마다 값을 메모리에 접근한다면 CPU의 프로그램 실행 속도를 눚출 것
- 플래그 : ALU가 계산 결과와 더불어 내보내는 것
  - 연산 결과에 대한 추가적인 정보를 내보내야 할 때, 추가적인 상태 정보를 플래그라고 함
  > 이진수만 봐서는 음수인지 양수인지 판단하기 어려움 -> 방금 계산한 결과는 음수라는 추가 정보를 내보냄 -> 이게 플래그
- 플래그의 종류
  1. 부호 플래그 : 연산한 결과의 부호 (음수일 경우 1, 양수일 경우 0)
  2. 제로 플래그 : 연산 결과가 0인지의 여부 (연산 결과가 0일 경우 1, 아닐 경우 0)
  3. 캐리 플래그 : 연산 결과 올림수나 빌림수가 발생했는지 여부 (올림수나 빌림수가 발생할 경우 1, 아닐 경우 0)
  4. 오버플로우 플래그 : 오버플로우 발생여부 (연산 결과가 연산 결과를 담을 레지스터보다 큰 상황) (발생한 경우 1 아닐 경우 0)
  5. 인터럽트 플래그 : 인터럽트가 가능한지 여부 (인터럽트가 가능할 경우 1, 아닐 경우 0)
  6. 슈퍼바이저 플래그 : 커널 모드로 실행중인지(1), 사용자 모드로 실행중인지(0) 나타냄
- 플래그 레지스터라는 레지스터에 저장됨
- 플래그 레지스터 : 플래그 값들을 저장하는 레지스터

## 제어장치
- 제어 신호를 내보내고, 명령어를 해석하는 부품
- 컴퓨터 부품을 관리하고 작동시키기 위한 일종의 전기 신호

### 제어장치가 받아들이는 정보
1. 클럭 신호
- 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위, 컴퓨터의 모든 부품이 클럭 신호라는 박자에 맞춰 작동한다
- 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있음
2. 해석해야 할 명령어
- 명령어 레지스터 : CPU가 해석해야 할 명령어가 저장되는 특별한 레지스터.
- 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야할 내용을 알려줌
3. 플래그 레지스터 속 플래그 값
- 플래그 : ALU 연산에 대한 추가적인 상태 정보
4. 시스템 버스 중 제어 버스로 전달된 제어 신호
- 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들임
- 제어 장치는 CPU 내부와 외부로 제어 신호를 보냄
  - 외부
    - 메모리에 전달 : 메모리에 저장된 값을 읽거나, 새로운 값을 씀
    - 입출력장치에 전달 : 입출력장치의 값을 읽거나, 새로운 값을 씀 
  - 내부
    - ALU에 전달 : ALU가 수행할 연산 지시
    - 레지스터에 전달 : 레지스터 간에 데이터를 이동시키거나, 레지스터에 저장된 명령어 해석

# 4-2. 레지스터
- 프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장됨
> 반드시 알아야 할 레지스터
1. 프로그램 카운터
  - 메모리에서 읽어 들일 명령어의 주소를 저장
  - 명령어 포인터라고도부름
  
2. 명령어 레지스터
  - 해석할 명령어, 메모리에서 읽어 들인 명령어를 저장하는 레지스터
  - 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냄
3. 메모리 주소 레지스터
  - 메모리의 주소를 저장하는 레지스터
  - CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거침
4. 메모리 버퍼 레지스터
  - 메모리와 주고받을 값을 저장하는 레지스터
  - 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거침
> 메모리에 저장된 프로그램을 실행하는 과정
>1. CPU에 실행할 프로그램 : 1000번지부터 1500번지까지 저장. 1000번지에 1101(2)이 저장되어 있음
>2. 프로그램을 처음부터 실행하기 위해 프로그램 카운터에 1000이 저장. = 메모리에서 가져올 명령어가 1000번지에 위치
>3. 1000번지를 읽어들이기 위해 주소 버스로 1000번지를 내보냄. 이를 위해 메모리 주소 레지스터에는 1000이 저장됨
>4. 메모리 읽기 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리에 보내짐
>5. 메모리 1000번지에 저장된 값이 데이터 버스를 통해 메모리 버퍼 레지스터로 전달됨. 프로그램 카운터는 증가되어(1001) 다음 명령어를 읽어들일 준비를 함
>6. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동함
>7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어신호를 발생시킴
> - 프로그램 카운터는 지속적으로 증가하며 계속 다음 명령어를 읽어 들일 준비를 함

5. 플래그 레지스터
  - ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장
6. 범용 레지스터
  - 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
  - 데이터와 주소 모두를 저장할 수 있음
7. 스택 포인터
  - `스택 주소 지정 방식`이라는 주소 지정 방식에 사용
8. 베이스 레지스터
  - 프로그램 카운터와 함께 `변위 주소 지정 방식`에 사용

> 스택 포이터와 베이스 레지스터는 주소 지정 방식에 사용될 수 있는 특별한 레지스터

### 스택 주소 지정 방식
- 스택과 스택 포인터를 이용한 주소 지정방식
- 스택 포인터 : 스택의 꼭대기를 가리키는 레지스터, 스택의 어디까지 데이터가 채워져 있는지에 대한 표시
- 스택은 메모리 안에 있음. 
- 스택 영역 메모리 안에 스택처럼 사용할 영역. 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역

### 변위 주소 지정 방식
- 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식
- 연산코드 | 레지스터 | 오퍼랜드
- 오퍼랜드 필드와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등을 ㅗ나뉨

- `상대 주소 지정 방식`
  - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
  > 프로그램 카운터 : 읽어들일 명령어의 주소가 저장되어 있음
  > 오퍼랜드가 -3이면, CPU는 읽어 들이기로 한 명령어로부터 세번째 이전 번지로 접근
  > 오퍼랜드가 3이면, CPU는 읽어 들이기로 한 명령어의 3번째 이후 번지로 접근
- `베이스 레지스터 주소 지정 방식`
  - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
  - 베이스 레지스터는 기준 주소, 오퍼랜드는 기준 주소로부터 떨어진 거리로서의 역할을 함
  > 베이스 레지스터에 200의 값이 있고, 오퍼랜드가 40이라면, 기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라

# 4-3. 인터럽트
### 하드웨어 인터럽트 처리 순서

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보냄
2. CPU는 실행 사이클이 끝나고 명령어 인출 전 항상 인터럽트 여부 확인
3. 인터럽트 요청 확인후 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업
5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
6. 인터럽트 서비스 루틴 실행이 끝나면 백업해 둔 작업을 복구하여 실행 재개

### 인터럽트 요청 신호

- 지금 끼어들어도 되나요? CPU에게 물어보는 것

### 인터럽트 플래그

- 인터럽트 플래그 : 가능 불가능 설정
  - 인터럽트 플래그가 불가능으로 설정되어 있어도 무시할 수 없는 인터럽트 요청도 있음 -> 하드웨어 고장, 정전으로 인한 인터럽트

### 인터럽트 서비스 루틴

- 인터럽트 핸들러
- 인터럽트를 처리하기 위한 프로그램

### 인터럽트 벡터

- 인터럽트 서비스 루틴을 식별하기 위한 정보
- 인터럽트 서비스 루틴의 시작 주소를 알 수 있음 - 실행에 도움

### 인터럽트 발생 전까지 레지스터에 저장되어 있었던 값들은 어떻게 하나?

- 스택에 백업해둠
- 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴 실행
- 인터럽트 처리 후, 스택에 저장해 둔 값을 다시 불러온 뒤 수ㅜ행하던 작업을 재개

# 예외의 종류

- CPU가 예외를 처리한 후 본래 작업으로 되돌아왔을 때 어디서부터 실행하느냐

### 폴트(fault)

- 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
  - CPU 명령어 실행 시, 실행에 필요한 데이터가 보조기억장치에 있어서 메모리로 가져와야 하는 경우, CPU는 폴트를 발생시킴

### 트랩(trap)

- 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
  - 디버깅할 때 주로 사용

### 중단(abort)

- CPU가 실행중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

### 소프트웨어 인터럽트

- 시스템 호출이 발생했을 때 나타남

# 질문

### 소프트웨어 인터럽트와 하드웨어 인터럽트의 차이점은 무엇인가요?

- 하드웨어 인터럽트는 외부 장치(예: 키보드, 마우스, 네트워크 카드 등)에서 발생하는 인터럽트입니다. 반면에 소프트웨어 인터럽트는 프로그램의 특정 명령어에 의해 발생하는 인터럽트입니다. 예를 들어, 시스템 호출(System Call)은 소프트웨어 인터럽트를 유발합니다. 하드웨어 인터럽트는 외부 이벤트에 의해 발생하므로 비동기적으로 발생하는 반면, 소프트웨어 인터럽트는 프로그램의 흐름에 따라 발생합니다

### 예외와 인터럽트의 차이점은? 소프트웨어 인터럽트는 예외라고 볼 수 있나요?

1. 발생 원인
   예외: 예외는 주로 프로그램 내에서 발생하는 오류나 특수한 상황 때문에 발생합니다. 예를 들어, 0으로 나누기, 페이지 폴트, 잘못된 명령어 실행 등 CPU에서 명령어를 실행하는 도중에 발생하는 예외적인 상황이 예외를 유발합니다.
   인터럽트: 인터럽트는 일반적으로 외부 장치(예: 키보드, 마우스, 하드웨어 타이머 등)에서 발생하는 이벤트에 의해 유발됩니다. 예를 들어, 키보드 입력이 들어오거나 타이머가 만료되었을 때 발생합니다.
2. 발생 시점
   예외: 예외는 CPU가 명령어를 실행하는 도중에 발생합니다. 즉, 프로그램의 흐름을 따라가다가 예외 상황이 발생했을 때 발생합니다.
   인터럽트: 인터럽트는 프로그램 실행과는 별개로, 비동기적으로 발생합니다. 외부 장치가 CPU에게 주의를 요청하는 시점에 발생합니다.
3. 처리 방식
   예외: 예외는 예외 핸들러(Exception Handler)에 의해 처리됩니다. 예외가 발생하면 CPU는 현재 명령어의 실행을 중단하고, 해당 예외를 처리하기 위한 코드로 점프합니다.
   인터럽트: 인터럽트는 인터럽트 핸들러(Interrupt Handler)에 의해 처리됩니다. 인터럽트가 발생하면 CPU는 현재 작업을 중단하고 인터럽트 벡터 테이블을 참조하여 해당 인터럽트에 대응하는 핸들러를 실행합니다.
4. 사용 목적
   예외: 예외는 주로 프로그램의 오류 처리나 특수한 조건에 대한 대처를 위해 사용됩니다. 예를 들어, 잘못된 메모리 접근이 발생하면 이를 처리하기 위해 예외가 사용됩니다.
   인터럽트: 인터럽트는 외부 장치의 요구를 즉시 처리하기 위해 사용됩니다. 예를 들어, 입력 장치로부터 데이터를 수신하거나 시스템 타이머에 의해 주기적인 작업을 처리할 때 인터럽트가 사용됩니다.
5. 우선순위
   예외: 예외는 발생한 오류의 심각도에 따라 우선순위가 다를 수 있습니다. 일부 예외는 시스템이 즉시 처리해야 하며, 다른 작업을 중단하고 처리될 수 있습니다.
   인터럽트: 인터럽트는 일반적으로 우선순위에 따라 처리됩니다. 우선순위가 높은 인터럽트는 낮은 우선순위의 인터럽트를 중단하고 처리될 수 있습니다.

- 소프트웨어 인터럽트가 예외로 간주되는 이유:
- 공통된 처리 메커니즘: 소프트웨어 인터럽트와 예외는 둘 다 인터럽트 벡터 테이블을 통해 특정 핸들러로 점프하는 방식으로 처리됩니다. 이 때문에 소프트웨어 인터럽트도 예외와 유사하게 여겨질 수 있습니다.
- CPU의 관점: CPU는 소프트웨어 인터럽트를 처리할 때와 예외를 처리할 때 동일한 메커니즘을 사용합니다. 이로 인해 소프트웨어 인터럽트를 예외의 한 형태로 분류하기도 합니다.

### 인터럽트 우선순위는 무엇이며, 어떻게 관리되나요?

- 하드웨어적으로는 인터럽트 컨트롤러가 우선순위를 관리하며, 소프트웨어적으로는 운영체제가 인터럽트 처리 루틴에서 우선순위를 조정할 수 있습니다.

### 인터럽트 핸들러에서 발생할 수 있는 문제점은 무엇이며, 이를 해결하기 위한 방법은 무엇인가요?

- 인터럽트 핸들러에서 발생할 수 있는 대표적인 문제로는 레이스 컨디션, 교착 상태, 그리고 핸들러의 장시간 실행으로 인한 시스템 성능 저하 등이 있습니다. 레이스 컨디션을 방지하기 위해서는 적절한 동기화 메커니즘을 사용해야 하며, 교착 상태를 피하기 위해서는 자원 할당 순서를 엄격히 관리해야 합니다. 또한, 인터럽트 핸들러는 가능한 짧게 설계하여 장시간 실행으로 인한 성능 저하를 방지하고, 복잡한 작업은 핸들러가 아닌 다른 스레드나 프로세스에서 처리하도록 해야 합니다.
