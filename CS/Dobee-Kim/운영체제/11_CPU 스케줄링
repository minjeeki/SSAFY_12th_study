# 11-1. CPU 스케줄링 개요

- CPU 스케줄링 : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것. 컴퓨터 성능과도 직결됨

## 프로세스 우선순위

- 우선순위가 높은 프로세스 : 빨리 처리해야하는 프로세스
  - ex : 입출력 작업이 많은 프로세스 -> 입출력 작업을 완료하기 전까지 입출력 집중 프로세스는 대기 상태가 될 예정이므로 먼저 처리해버리면 다른 프로세스가 CPU를 사용할 수 있음
- 입출력 집중 프로세스 : 입출력이 많은 프로세스, 입출력을 위한 대기 상태에 더 많이 머무름, 입출력 버스트가 많은 작업
- CPU 집중 프로세스 : CPU 작업이 많은 프로세스, 대기 상태보다는 실행 상태에 더 많이 머무름, CPU 버스트가 많은 작업
  > 입출력 버스트 : 입출력을 기다리는 작업
  > CPU 버스트 : CPU를 이용하는 작업
- 우선순위 부여 : 상황과 프로세스의 중요도에 맞게 CPU를 이용할 수 있도록 하기 위해서 부여함. PCB에 우선순위를 명시함

## 스케줄링 큐

- 운영체제가 매번 모든 PCB를 검사하여 먼저 자원을 이용할 프로세스를 결정하는 일은 매우 번거로움
- 프로세스들에게 줄 서서 기다릴 것을 요구하고, 스케줄링 큐를 구현하고 관리함
- 운영체제가 관리하는 대부분의 자원은 큐로 관리함.
  - 준비 큐 : CPU를 이용하고 싶은 프로세스들이 서는 줄
  - 대기 큐 : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
    - 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, PCB를 준비 상태로 변경한 뒤에 대기 큐에서 제거함

## 선점형과 비선점형 스케줄링

- 선점형 스케줄링 : 프로세스가 CPU를 비롯한 자원들을 사용하고 있떠라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
  - 어느 하나의 프로세스가 자원 사용을 독점할 수 없음
  - 장점 : 어느 한 프로세스의 자원 독점을 막고, 프로세스들에 골고루 자원을 배분할 수 있음
  - 단점 : 문맥 교환(컨텍스트 스위칭) 과정에서 오버헤드 발생 가능
- 비선점형 스케줄링 : 하나의 프로세스가 자원을 사용하고 있다면, 그 프로세스가 종료되거나 스스로 대기상태에 접어들 기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식
  - 하나의 프로세스가 자원 독점
  - 장점 : 문맥 교환에서 발생하는 오버헤드가 선점형 스케줄링보다 작음
  - 단점 : 모든 프로세스가 골고루 자원을 사용할 수 없음

# 11-2. CPU 스케줄링 알고리즘

## FCFS 스케줄링 (선입 선처리 스케줄링)

- First come First Served Scheduling
- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식
  - 단점 : 프로세스들이 기다리는 시간이 매우 길어질 수 있음
- 호위효과(convey effect) : 짧은 실행시간을 가진 프로세스가 실행되기 위해 앞선 프로세스의 긴 실행을 기다려야 하는 것

## SJF 스케줄링 (최단 작업 우선 스케줄링)

- Shortest Job First Scheduling
- 준비 큐에 삽입된 프로세스 들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행
  - 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수 있음

## 라운드 로빈 스케줄링 (Round Robin Scheduling)

- 선입 선처리 스케줄링 + 타임 슬라이스
- 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
- 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링.
  - 정해진 시간을 모두 사용했음에도, 프로세스가 완료되지 않았으면, 다시 큐의 맨 뒤에 삽입(컨텍스트 스위칭)
- 타임 슬라이스의 크기가 중요
  - 지나치게 크면 : 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생김
  - 지나치게 작으면 : 문맥 교환에 발생하는 비용이 커 CPU가 프로세스 처리보다 전환에 힘을 다씀

## SRT 스케줄링(Shortest Remaining Time) 최소 잔여 시간 우선 스케줄링

- 최단 우선 스케줄링 알고리즘 + 라운드 로빈 알고리즘

## 우선순위 스케줄링 (priority Scheduling)

- 프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행
- 기아 현상 : 우선순위가 높은 프로세스를 우선 처리하기 때문에, 우선순위가 낮은 프로세스는 실행이 계속 연기될 수 있음
- 에이징 : 기아현상을 방지하기 위한 대표적인 기법. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

## 다단계 큐 스케줄링 (multilevel queue scheduling)

- 우선순위별로 준비 큐를 여러개 사용하는 스케줄링 방식
- 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어있으면 다음 우선순위 큐에 있는 프로세스들을 처리
- 큐별로 타임 슬라이스를 여러개 지정 가능, 큐마다 다른 스케줄링 알고리즘 사용도 가능

## 다단계 피드백 큐 스케줄링 (multilevel feedback queue scheduling)

- 앞선 다단계 큐 스케줄링에선 프로세스들이 큐 사이를 이동할 수 없음 -> 우선순위가 낮은 프로세스들이 계속 연기될 수 있음
- 다단계 큐 스케줄링과 비슷하지만, 하나 다른점 : 프로세스들이 큐 사이를 이동할 수 있음
- 새로 준비상태가 된 프로세스가 있다면 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정 시간동안 실행(타임 슬라이스) -> 실행이 안끝나면 다음 우선순위 큐에 삽입되어 실행 반복
  - CPU를 오래 사용해야하는 프로세스는 점차 우선순위가 낮아짐
  - CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 끝남
- 에이징 기법을 적용해 기아 현상 예방도 가능 : 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 -> 우선순위가 높은 큐로 점차 이동시킴
  => 가장 일반적인 CPU 스케줄링 알고리즘
