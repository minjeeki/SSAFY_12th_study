### 선형 자료구조 (스택, 큐)

1. 스택의 주요 연산은 무엇이며, 스택을 사용하는 실제 사례를 설명해주세요. 스택을 활용한 알고리즘을 하나 예시로 들어주세요.

> 기대 답변: push, pop, peek 연산 설명, 함수 호출 스택, 브라우저의 뒤로 가기 기능 등 예시, 예를 들어 괄호 유효성 검사 알고리즘 설명.

2. 큐의 주요 연산은 무엇이며, 큐를 사용하는 실제 사례를 설명해주세요. 큐와 스택의 차이점을 비교해주세요.

> 기대 답변: enqueue, dequeue, peek 연산 설명, 운영 체제의 작업 스케줄링, 네트워크 패킷 처리 등 예시, 스택은 LIFO, 큐는 FIFO 등 차이점 설명.

3. 우선순위 큐(Priority Queue)는 일반적인 큐와 어떻게 다르며, 이를 구현하는 방법에 대해 설명해주세요. 또한 우선순위 큐의 사용 사례를 설명해주세요.

> 기대 답변: 우선순위 큐는 요소에 우선순위를 부여하여 우선순위가 높은 요소가 먼저 처리됨, 힙(heap)을 사용하여 구현, 다익스트라 알고리즘 등 예시.

4. 링크드 리스트로 스택과 큐를 각각 구현할 때의 장단점을 설명해주세요.

> 기대 답변: 배열 기반과 비교하여 링크드 리스트는 동적 크기 조절이 가능하지만, 포인터 관리가 필요하여 메모리 오버헤드가 있음. 각 경우의 삽입/삭제 연산 효율성 비교.

5. 링크드 리스트를 사용하여 큐를 구현하고, 배열 기반 큐와의 차이점을 설명하세요.

```python
코드 복사
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedListQueue:
    def __init__(self):
        self.front = self.rear = None

    def enqueue(self, value):
        new_node = Node(value)
        if self.rear is None:
            self.front = self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node

    def dequeue(self):
        if self.front is None:
            return None
        value = self.front.value
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        return value
```
>링크드 리스트 기반 큐는 동적 크기 조절이 가능하며, 배열 기반 큐는 고정 크기를 가지므로 크기 변경이 필요할 때 비용이 발생합니다.

### 정렬 알고리즘

1.  퀵 정렬(Quick Sort)의 원리와 시간 복잡도에 대해 설명해주세요. 퀵 정렬의 최악의 경우와 이를 피하기 위한 전략은 무엇인가요?

> 기대 답변: 분할 정복 알고리즘, 평균 O(n log n), 최악의 경우 O(n^2), 피벗 선택 전략 설명 (랜덤 피벗 선택, median-of-three 등).

2. 머지 정렬(Merge Sort)의 원리와 시간 복잡도에 대해 설명해주세요. 퀵 정렬과 비교했을 때의 장단점은 무엇인가요?

> 기대 답변: 분할 정복 알고리즘, O(n log n) 시간 복잡도, 안정 정렬, 추가 메모리 사용 필요, 퀵 정렬보다 속도가 느리지만 안정성이 있는 경우 설명.

3. 힙 정렬(Heap Sort)의 원리와 시간 복잡도에 대해 설명해주세요. 힙 정렬을 구현할 때 주요 단계는 무엇인가요?

> 기대 답변: 힙 데이터 구조를 이용, O(n log n) 시간 복잡도, 힙 생성(build heap)과 힙 정렬(heapify) 과정 설명.

4. 버블 정렬(Bubble Sort)의 원리와 시간 복잡도에 대해 설명해주세요. 버블 정렬이 다른 정렬 알고리즘보다 비효율적인 이유는 무엇인가요?

> 기대 답변: 인접 요소를 반복적으로 비교 및 교환, O(n^2) 시간 복잡도, 많은 비교와 교환 연산으로 인한 비효율성 설명.

5. 삽입 정렬(Insertion Sort)의 원리와 시간 복잡도에 대해 설명해주세요. 삽입 정렬이 특정 상황에서 효율적인 이유는 무엇인가요?

> 기대 답변: 요소를 하나씩 정렬된 부분과 비교하여 올바른 위치에 삽입, 평균 및 최악 O(n^2), 최선 O(n), 대부분 정렬된 배열에서는 효율적임.

6. 정렬 알고리즘의 안정성과 비안정성에 대해 설명하고, 각 정렬 알고리즘이 안정적인지 여부를 설명해주세요. 예를 들어 퀵 정렬과 병합 정렬을 비교해주세요.

> 기대 답변: 안정성은 같은 값의 요소가 원래 순서대로 유지되는지 여부, 병합 정렬은 안정적, 퀵 정렬은 비안정적, 안정성과 비안정성의 의미 및 중요성 설명.