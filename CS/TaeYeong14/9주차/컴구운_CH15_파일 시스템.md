### 15-1. 파일과 디렉터리

- **파일** : 하드 디스크나 SSD와 같은 보조기억장치에 저장된 관련 정보의 집합
    - **속성(메타데이터)** : 파일의 속성은 파일의 크기, 생성 날짜, 수정 날짜, 소유자, 접근 권한, 파일 유형 등의 정보를 포함하는 메타데이터이다. 운영체제는 이 정보를 이용해 파일을 관리하고 접근 권한을 제어한다.
    - **파일 속성과 유형**
        - 파일의 속성에는 파일과 관련된 다양한 부가 정보들이 있다. 예를 들어, 파일의 이름, 확장자, 크기, 생성 및 수정 시간, 소유자, 접근 권한 등이 포함된다.
        - **파일 유형** : 운영체제는 파일의 확장자를 통해 파일의 유형을 파악할 수 있다. 예를 들어, `.txt`는 텍스트 파일, `.exe`는 실행 파일, `.jpg`는 이미지 파일을 나타낸다.
    - **파일 연산을 위한 시스템 호출**
        - 파일을 생성, 열기, 읽기, 쓰기, 닫기 등의 작업을 수행하기 위해 시스템 호출이 사용된다.
        - 주요 시스템 호출에는 `open()`, `read()`, `write()`, `close()`, `delete()` 등이 있다. 이들은 운영체제와 사용자 간의 인터페이스 역할을 하여 파일에 접근할 수 있도록 한다.
- **디렉터리(폴더)** : 정보를 저장하는 파일들의 집합으로, 파일들을 논리적으로 구분하고 관리할 수 있도록 하는 구조이다. 디렉터리는 파일을 그룹으로 묶어 관리하며, 디렉터리 내에는 다른 디렉터리(서브디렉터리)도 포함될 수 있다.

- **경로** : 디렉터리를 이용해 파일 위치를 나타내는 정보로, 파일의 이름을 특정 짓는 데 사용된다.
    - 절대 경로 : 루트 디렉터리(일반적으로 `/`로 표시됨)부터 시작하는 경로로, 파일이나 디렉터리의 전체 경로를 명시한다. 예를 들어, `/home/user/document.txt`는 절대 경로이다.
    - 상대 경로 : 현재 작업 디렉터리부터 시작하는 경로로, 현재 위치를 기준으로 파일이나 디렉터리의 경로를 명시한다. 예를 들어, 현재 디렉터리가 `/home/user`라면 `document.txt`는 상대 경로이다.

- 상대 경로를 나타내는 또 다른 방법
    - `.` (점) : 현재 디렉터리를 나타낸다.
    - `..` (두 개의 점) : 부모 디렉터리(상위 디렉터리)를 나타낸다. 예를 들어, `../document.txt`는 현재 디렉터리의 부모 디렉터리에 있는 `document.txt` 파일을 가리킨다.

### 15-2. 파일 시스템

- **파일 시스템**
    
    : 파일과 디렉터리를 보조기억장치에 일목요연하게 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램. 파일 시스템은 파일들의 저장, 검색, 수정, 삭제 등의 작업을 지원하며, 데이터를 효율적으로 관리할 수 있게 해준다.
    
    - 대표적 파일 시스템
        - **FAT 파일 시스템** : FAT(File Allocation Table)을 이용하는 연결 할당 기반의 파일 시스템. 주로 MS-DOS와 Windows에서 사용되며, 단순한 구조로 인해 널리 사용된다. FAT12, FAT16, FAT32와 같은 다양한 버전이 있다.
        - **유닉스 파일 시스템** : i-node(inode)를 이용하는 색인 할당 기반의 파일 시스템. 각 파일의 메타데이터와 블록 주소를 저장하는 i-node를 통해 파일을 관리한다. 이 파일 시스템은 UNIX 계열 운영체제에서 주로 사용된다.

- **파티셔닝과 포매팅**
    - **파티셔닝** : 저장 장치를 논리적인 영역으로 나누는 작업. 예를 들어, 하나의 물리적 디스크를 여러 개의 독립된 파티션으로 나눌 수 있다. 각 파티션은 서로 독립적으로 운영체제가 설치되거나 파일 시스템이 설정될 수 있다. (쉬운이해 - 서랍 안을 칸막이로 영역을 나누는 작업)
    - **파티션** : 
    파티셔닝을 통해 나누어진 논리적 영역 하나하나를 말한다. 예를 들어, 하나의 하드 드라이브가 `C:`, `D:`로 나뉘어 있다면, 각 드라이브가 하나의 파티션이다.
    - **포매팅** : 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하는 작업. 새로운 데이터를 쓸 수 있게 하기 위해 파일 시스템을 초기화하는 과정이다. 포매팅 후에는 데이터를 효율적으로 관리하고 접근할 수 있게 된다.

- **파일 할당 방법**
    - **연속 할당** : 파일이 저장 장치 내에서 연속적인 공간을 차지하도록 블록을 할당하는 방법. 이 방법은 파일이 연속적으로 저장되므로 접근 속도가 빠르지만, 파일의 크기가 변할 때 외부 단편화가 발생할 수 있다.
    - **불연속 할당**
        - **연결 할당** : 각 블록의 일부에 다음 블록의 주소를 저장하여 블록들을 연결 리스트 형태로 관리하는 방식. 파일이 연속적이지 않게 저장될 수 있으나, 파일의 크기를 동적으로 조절할 수 있다.
        - **색인 할당** : 파일의 모든 블록 주소를 하나의 색인 블록에 모아 관리하는 방식. 색인 블록에는 파일을 구성하는 모든 블록의 주소가 저장되어 있어, 접근 속도가 빠르며 단편화 문제를 줄일 수 있다.

- **저널링 파일 시스템**
    
    : 파일 시스템에 변경 사항을 기록하는 저널(일지)을 유지하여, 시스템이 비정상적으로 종료되었을 때 파일 시스템의 일관성을 유지하는 방법. 변경 사항이 먼저 저널에 기록된 후, 실제 데이터가 저장된다. 시스템이 비정상적으로 종료되더라도 저널을 통해 파일 시스템을 복구할 수 있다. 대표적인 저널링 파일 시스템으로는 ext3, ext4 등이 있다.
    
- **마운트**
    
    : 운영체제가 파일 시스템을 액세스할 수 있도록 디스크 파티션을 특정 디렉터리에 연결하는 과정. 예를 들어, 리눅스 시스템에서 `/dev/sda1` 파티션을 `/mnt` 디렉터리에 마운트하면, `/mnt` 디렉터리를 통해 해당 파티션의 파일에 접근할 수 있다.
    

---

### 질문

### i-node가 무엇인가요?

i-node는 **유닉스(U*nix) 파일 시스템**에서 사용되는 중요한 데이터 구조입니다. i-node는 파일에 대한 메타데이터를 저장하는 곳으로, 파일의 실제 데이터는 포함하지 않지만, 파일에 접근하는 데 필요한 모든 정보를 담고 있습니다.

**i-node**는 다음과 같은 정보를 포함합니다:

- **파일의 소유자와 그룹**: 파일을 소유한 사용자와 그룹의 ID.
- **파일 권한**: 파일에 대한 읽기, 쓰기, 실행 권한.
- **파일의 크기**: 파일의 바이트 단위 크기.
- **파일의 생성, 수정, 접근 시간**: 파일이 생성, 수정, 접근된 시간.
- **링크 수**: 이 i-node를 참조하는 하드 링크의 개수.
- **데이터 블록의 위치**: 파일의 실제 데이터가 저장된 블록들의 주소 목록.

각 파일이나 디렉터리는 하나의 i-node에 연결되어 있으며, i-node의 번호(인덱스 번호)는 파일 시스템에서 파일을 식별하는 데 사용됩니다. 이를 통해 파일 시스템은 i-node 번호를 이용해 파일에 접근하고, 데이터 블록을 찾아 데이터를 읽거나 씁니다.

i-node 구조는 파일 시스템의 효율성을 높이고, 빠르게 파일에 접근할 수 있게 해주는 중요한 역할을 합니다. 특히, 유닉스 계열 시스템에서 파일 관리의 핵심 요소입니다.

### 프로그래밍 언어 상에서 제공하는 파일 관련 함수(Python - open(), Java - BufferedReader/Writer 등)은 파일을 어떤 방식으로 읽어들이나요?

프로그래밍 언어에서 제공하는 파일 관련 함수들은 보통 다음과 같은 방식으로 파일을 읽어들입니다:

1. **파일 열기**: 함수가 호출되면, 파일을 열기 위한 시스템 콜이 실행됩니다. 예를 들어, Python의 `open()` 함수나 Java의 `BufferedReader` 클래스는 파일을 열기 위해 운영체제에 요청합니다. 이 과정에서 파일 디스크립터(파일을 참조하는 핸들)를 얻습니다.
2. **버퍼링**:
    - **Python**의 `open()` 함수와 **Java**의 `BufferedReader`/`BufferedWriter` 클래스는 모두 버퍼링을 사용합니다. 버퍼링은 파일의 내용을 작은 크기의 조각이 아니라 큰 덩어리로 읽어들임으로써, 디스크 입출력의 효율성을 높이는 방법입니다.
    - 예를 들어, `BufferedReader`는 파일의 내용을 일정 크기의 버퍼로 미리 읽어 들여, 프로그램이 읽기 요청을 할 때마다 디스크에 접근하는 대신, 메모리에서 빠르게 데이터를 제공할 수 있습니다.
3. **읽기/쓰기**:
    - 파일이 열린 후, 읽기 함수(`read()`, `readline()` 등)를 호출하면, 해당 함수는 운영체제에 파일 데이터를 요청합니다. 이 데이터는 버퍼에 저장되고, 이후 프로그램이 요청할 때마다 버퍼에서 데이터를 가져옵니다.
    - 파일 쓰기(`write()`) 역시 비슷한 방식으로 작동하며, 버퍼에 데이터를 쓴 후, 버퍼가 꽉 차거나 파일을 닫을 때 실제로 디스크에 기록됩니다.
4. **파일 닫기**:
    - 파일 작업이 끝나면, 반드시 파일을 닫아야 합니다. 이 과정에서 버퍼에 남아 있는 데이터가 디스크에 기록되며, 파일 디스크립터가 해제되어 리소스가 반환됩니다.
    - Python의 `with` 문이나 Java의 `try-with-resources` 구문은 파일이 자동으로 닫히도록 보장해 주어 리소스 누수를 방지합니다.

요약하면, 파일 관련 함수들은 시스템 콜을 통해 파일을 열고, 버퍼를 사용하여 효율적으로 파일 데이터를 읽고 쓰며, 작업이 끝나면 파일을 닫아 리소스를 해제하는 방식으로 동작합니다. 이 과정에서 파일 시스템의 i-node와 같은 구조를 통해 파일의 실제 데이터에 접근하게 됩니다.
