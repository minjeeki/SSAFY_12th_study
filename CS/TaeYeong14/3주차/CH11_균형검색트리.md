### 균형 검색 트리
  : 트리 자료구조의 일종으로, 삽입, 삭제, 검색 연산이 일정한 시간 안에 수행되도록 높이가 균형을 이루도록 유지하는 트리
    
  - **AVL 트리**
    : 이진 탐색 트리를 기본으로 하며 트리의 균형이 깨질 때 4가지 회전을 통해서, 스스로 균형을 유지하는 트리.
        
    노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1을 넘어가지 않도록 유지 ⇒ 최악의 경우에도 O(log n)의 시간 복잡도로 검색, 삽입, 삭제 연산을 수행할 수 있음
        
    - 4가지 회전
      - LL회전
        - LL상태에서 발생 (LL상태 : 루트 노드 기준으로 왼쪽 높이 - 오른쪽 높이 > 1, 왼쪽 자신 노드 기준에서 또, 왼쪽 높이 > 오른쪽 높이인 상태)
      - RR회전
        - RR상태에서 발생 (RR상태 : 루트 노드 기준, 오른쪽 높이 - 왼쪽 높이 > 1, 오른쪽 자식 노드 기준에서 또, 오른쪽 높이 > 왼쪽 높이인 상태)
      - LR회전
        - LR상태에서 발생 (LR상태 : 루트 노드 기준, 왼쪽 높이 - 오른쪽 높이 > 1, 자식 노드 기준에서 또, 오른쪽 높이 > 왼쪽 높이인 상태)
      - RL회전
        - RL상태에서 발생 (RL상태 : 루트 노드 기준, 오른쪽 높이 - 왼쪽 높이 > 1, 오른쪽 자식 노드 기준에서 또, 왼쪽 높이 > 오른쪽 높이인 상태)
    
  - **레드-블랙 트리**
    : 노드가 레드 또는 블랙인 색깔을 가지며, 특정한 규칙을 따름
        
    - 규칙
      - 루트 노드는 항상 검은색이다.
      - 모든 리프(NIL) 노드는 검은색이다.
      - 빨간색 노드의 자식은 항상 검은색이다(즉, 빨간색 노드는 연속적으로 존재할 수 없다).
      - 루트에서 모든 리프 노드까지 가는 경로에는 동일한 수의 검은색 노드가 포함되어야 한다.
    
  - **Red-Black 트리 vs AVL 트리**
      - AVL Tree가 red-black Tree보다 빠른 Search를 제공한다.
        - AVL트리는 더욱 엄격한 균형을 이루고 있기 때문
      - red-black Tree은 AVL Tree보다 빠른 삽입과 삭제를 제공한다.
        - red-black 트리는 상대적으로 느슨한 균형으로 인해 회전이 거의 이루어지지 않기 때문
      - red-black Tree는 AVL Tree보다 색깔을 저장하기 위해 더 많은 Space Complexity가 필요
      - red-black Tree는 Java의 treeMap과 같이 대부분의 언어의 map, multimap, multiset에 사용되고 있다.
      - AVL tree는 검색에 속도가 중요한 Database에 사용되고 있다.
    
  - **B-트리**
    : 자식 노드의 수가 여러 개인 다진 트리. 노드에 여러 키를 저장하고 자식 노드로 포인터를 가지는 구조로 데이터베이스 및 파일 시스템에서 사용됨. 높은 가지 수를 통해 트리의 높이를 낮추고 디스크 입출력 효율을 높임.
        
    - 특징
      - 모든 리프 노드는 같은 깊이에 있다.
      - 각 노드는 최소 m/2에서 최대 m개의 자식 노드를 가질 수 있다(m은 B-트리의 차수).
      - 각 노드는 적어도 m/2-1에서 최대 m-1개의 키를 가질 수 있다.
      - 삽입, 삭제 연산 시 분할 및 병합을 통해 균형을 유지한다.

### 질문
#### Red Black Tree는 어떻게 균형을 유지할 수 있을까요?
Red-Black Tree는 각 노드에 색상(빨간색 또는 검은색)을 할당하여 트리가 균형을 유지하도록 합니다. 트리의 균형을 유지하기 위해 다음과 같은 작업을 수행합니다:

- 삽입 및 삭제 후 조정: 새로운 노드를 삽입하거나 기존 노드를 삭제한 후, 트리의 균형이 깨질 수 있습니다. 이 경우, 색상 변경 및 회전(좌회전 및 우회전) 작업을 통해 균형을 맞춥니다.
- 회전: 트리의 균형을 맞추기 위해 좌회전 및 우회전을 사용합니다. 회전 작업은 서브트리의 높이를 조정하여 트리의 균형을 유지합니다.
- 색상 변경: 트리의 색상 규칙을 유지하기 위해 노드의 색상을 변경합니다. 이는 트리의 루트에서 리프까지의 모든 경로에 동일한 수의 검은색 노드가 있도록 합니다.


#### Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.
Red-Black Tree는 다음과 같은 주요 성질을 가지고 있습니다:

- 노드의 색상: 모든 노드는 빨간색 또는 검은색입니다.
- 루트 노드: 루트 노드는 항상 검은색입니다.
- 빨간색 노드의 자식: 빨간색 노드의 자식은 항상 검은색입니다. 즉, 빨간색 노드는 연속으로 나타날 수 없습니다.
- 검은색의 균형: 모든 리프 노드(NIL, NULL)에서 루트 노드까지의 경로에는 동일한 수의 검은색 노드가 포함되어 있습니다.


#### 2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?
Red-Black Tree가 많이 사용되는 이유는 다음과 같습니다:

- 균형 유지의 효율성: Red-Black Tree는 삽입 및 삭제 연산 시 트리의 균형을 효율적으로 유지합니다. AVL 트리보다 회전 횟수가 적어 평균적으로 더 빠른 성능을 보입니다.
- 단순 구현: Red-Black Tree의 구현은 상대적으로 간단하며, 표준 라이브러리(예: C++의 std::map, std::set, Java의 TreeMap, TreeSet)에서도 널리 사용됩니다.
- 고정된 균형: Red-Black Tree는 최악의 경우에도 트리의 높이가 O(log n)으로 유지됩니다. 이는 검색, 삽입, 삭제 연산의 시간 복잡도를 보장합니다.
- 다양한 응용 분야: Red-Black Tree는 데이터베이스, 파일 시스템, 네트워크 라우팅 테이블 등 다양한 분야에서 균형 이진 탐색 트리로서의 성능을 발휘합니다.
  
이러한 이유들로 인해 Red-Black Tree는 많은 응용 프로그램에서 균형 이진 탐색 트리(BBST)로 널리 사용됩니다.
