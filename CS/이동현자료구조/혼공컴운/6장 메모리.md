## 램의 종류

### dram
동적인 램. dram은 시간이 지나면 저장된 데이터가 점차 사라진다.
장점 싸다 소비 전력이 낮다 집적도가 높다.

### sram
정적인 램. dram과 달리 시간이 지나도 사라지지 않고 속도도 dram보다 빠르다.
그러나 집적도가 낮고 소비 전력도 크고 가격도 더 비싸다. sram은 속도가 빨라야하는 저장장치, 캐시 메모리에 사용된다. 

### sdram 
클럭 신호와 동기화된, 발전된 형태의 dram이다. 

### ddr sdram
가장 흔히 사용되는 램. 대역폭을 넓혀 속도를 빠르게 만든 sdram이다.
대역폭은 도로와 비슷하게 된다. 

## 메모리의 주소 공간
물리 주소는 메모리 하드웨어가 사용하는 주소, 논리 주소는 cpu와 실행 중인 프로그램이 사용하는 주소이다.

논리 주소와 물리 주소의 변환이 이루어져야 원활히 작업이 이루어질 수 있고 이를 mmu가 수행해준다. (메모리 관리 장치)

### 한계 레지스터
논리 주소를 벗어나는 명령어의 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호하는게 한계 레지스터가 담당한다.
프로그램의 논리 주소의 최대 크기를 저장한다.

### 베이스 레지스터
프로그램의 첫 물리 주소를 저장한다. 

## 캐시 메모리
cpu가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 느리다. 
캐시 메모리도 cpu에 가장 가까우면 L1 캐시, L2 캐시, L3 캐시라고 나뉘어 부른다. 
속도는 L1이 젤 빠르고 용량은 L3가 가장 크다. 

### 캐시 히트
캐시에 모든 내용을 가져다 저장할 수는 없다. 예측해서 저장하는데, 예측이 들어맞아 활용될 경우를 캐시 히트라고 한다
캐시 미스는 예측 실패로 데이터를 메모리에서 직접 가져와야하는 경우이고 성능이 떨어지게 된다. 

### 참조 지역성의 원리
이러한 캐시 미스로 인한 성능 저하를 막기 위해 캐시 적중률을 높이려하는데 이를 참조 지역성의 원리로 캐시 메모리에 가져올 데이터를 결정한다.
1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

   1번 부터 보면 우리가 변수를 설정하면 그 변수는 많이 호출되는 경향이 있다. 이것이 **시간 지역성**이다.
   2번은 메모리에 워드, 웹 브라우저, 게임 프로그램이 있다고 하면 서로 관련 있는 데이터끼리 모여서 저장된다.
   CPU가 워드 프로세서를 실행할 때에는 워드 프로세서 프로그램이 모여 있는 공간 근처를 집중적으로 접근할 것인 것이다. 이를 **공간지역성**이라고 한다.


## 메모리 계층

: 메모리 계층에는 레지스터, 캐시 메모리, 저장장치가 있다.

## 메모리 계층 구조(Memory Hierachy)

![img](https://velog.velcdn.com/images%2Fyu-jin-song%2Fpost%2Ff9c8088c-0fec-4dad-ac95-ddf3601aa1d4%2F%EB%A9%94%EB%AA%A8%EB%A6%AC_%EA%B3%84%EC%B8%B5_%EA%B5%AC%EC%A1%B0.png)

- 메모리를 필요에 따라 여러가지 종류로 나누어 두는 것
    
    → **CPU가 메모리에 더 빨리 접근 가능함**
    
- 컴퓨터의 설계에 있어 각각의 특징이 있는 서로 다른 여러 종류의 저장 장치를 함께 사용하여 최적의 효율을 낼 수 있게 하는 것
- 상황에 맞게 여러 저장 장치를 각각 사용할 수 있도록 하여 저렴하고 성능 좋은 컴퓨터를 구현하는 설계
    
    
    | 명칭 | 위치 | 접근 속도 |
    | --- | --- | --- |
    | 레지스터 | CPU 내부 | 빠름 |
    | 캐시 | CPU 내부 | 빠름 |
    | 메모리 | CPU 외부 | 레지스터와 캐시보다 느림 |
    | 하드디스크 | CPU 직접 접근 불가 | 데이터를 메모리로 이동시켜 접근 가능 |

### **✅ 레지스터(Register)**

- 개념
    - CPU가 요청을 처리하는 데 필요한 데이터를 일시적으로 저장하는 기억장치
        - CPU(Central Processing Unit), 중앙처리 장치
            
            ![img](https://velog.velcdn.com/images%2Fyu-jin-song%2Fpost%2Fc4a3084f-870c-455c-993e-e9ae8cf0e75e%2F%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0_%EC%BA%90%EC%8B%9C.PNG)
            
            - 컴퓨터에서 4대 주요 기능(`기억`, `해석`, `연산`, `제어`)을 관할하는 장치
            - CPU는 자체적으로 데이터를 저장할 방법이 없으므로 메모리로 직접 데이터를 전송할 수 없음→ 연산을 위해서 반드시 레지스터를 거쳐야 하며, 이를 위해 레지스터는 특정 주소를 가리키거나 값을 읽어올 수 있음
    - 프로세서에 위치한 고속 메모리로, 프로세스가 바로 사용할 수 있는 데이터(소량의 데이터, 처리 중인 중간 결과 등)를 담고 있는 영역
- CPU 내부 레지스터 종류
    
    
    | 종류 | 설명 |
    | --- | --- |
    | 프로그램 계수기(PC, Program Counter) | 다음에 실행할 명령어(instruction)의 주소를가지고 있는 레지스터 |
    | 누산기(AC, ACcumulator) | 연산 결과 데이터를 일시적으로 저장하는 레지스터 |
    | 명령어 레지스터(IR, Instruction Register) | 현재 수행 중인 명령어를 가지고 있는 레지스터 |
    | 상태 레지스터(SR, Status Register) | 현재 CPU의 상태를 가지고 있는 레지스터 |
    | 메모리 주소 레지스터(MAR, Memory Address Register) | 메모리로부터 읽어오거나 메모리에 쓰기 위한주소를 가지고 있는 레지스터 |
    | 메모리 버퍼 레지스터(MBR, Memory Buffer Register) | 메모리로부터 읽어온 데이터 또는메모리에 써야할 데이터를 가지고 있는 레지스터 |
    | 입출력 주소 레지스터(I/O AR, I/O Address Register) | 입출력 장치에 따른 https://kr.mitsubishielectric.com/fa/ko/product.do?act=productList&parent_id=127&cate_id=1의 주소를가지고 있는 레지스터 |
    | 입출력 버퍼 레지스터(I/O BR, I/O Buffer Register) | 입출력 모듈과 프로세서 간의 데이터 교환을 위해사용되는 레지스터 |

### **✅ 캐시(Cache)**

- 개념
    - 데이터나 값을 미리 복사해 놓는 임시 장소
    - 시스템의 효율성을 위해 사용
        - 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우
        - 값을 다시 계산하는 시간을 절약하고 싶은 경우
    - 속도가 빠른 장치와 느린 장치 사이에서 속도차에 따른 병목 현상을 완화하기 위한 범용 메모리
    
    > 캐싱(Caching) : 캐시(Cache)라고 하는 좀 더 빠른 메모리 영역으로 데이터를 가져와서 접근하는 방식
    > 
- 종류
    - **CPU 캐시**
        - 대용량의 메인 메모리 접근을 빠르게 하기 위해 CPU 칩 내부나 바로 옆에 탑재하는 작은 메모리
        - 하드웨어를 통해 관리
        
        | 종류 | 설명 | CPU 성능에직접적인 영향 |
        | --- | --- | --- |
        | L1 캐시 | 일반적으로 CPU 칩안에 내장되어 데이터 사용 및참조에 가장 먼저 사용되는 캐시 메모리 | O |
        | L2 캐시 | - L1 캐시 메모리와 용도와 역할이 비슷- 속도 : L1 캐시 > L2 캐시 > 일반메모리(RAM) | O |
        | L3 캐시 | - L1 캐시, L2 캐시와 동일한 원리로 작동- 대부분 CPU가 아닌 메인보드에 내장 | X |
    - **디스크 캐시**(=디스크 버퍼) : 하드디스크에 내장된 '작은 컴퓨터'(기능 : 디스크 제어, 외부와의 인터페이스)가 소유한 '작은 메모리'(디스크에 입출력되는 데이터를 저장하는 작은 메모리)
        
        => 일종의 기법(하드디스크와 RAM 사이에 존재)
        
    - **그 외**
        - 소프트웨어적으로 관리
        - 페이지 캐시 : 운영 체제의 메인 메모리를 하드 디스크에 복사해 놓는 캐시 ex) 웹 브라우저의 웹 페이지 캐시
- 지역성
    - 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것
    - 캐시가 효율적으로 동작하기 위해서는 캐시가 저장할 데이터가 지역성을 가져야 함
    - 종류
        
        
        | 종류 | 설명 |
        | --- | --- |
        | 시간적 지역성 | 특정 데이터가 한 번 접근되었을 경우,가까운 미래에 또 한 번 데이터에 접근할 가능성이 높음 |
        | 공간적 지역성 | 액세스 된 기억장소와 인접한 기억장소가 액세스 될 가능성이 높음 |
- 캐시 히트
    
    : 캐시 컨트롤러에서 주소를 확인 후 다음 해당 데이터가 캐시 메모리에 존재하는 경우 캐시 히트가 발생하면서 캐시 메모리 컨트롤러는 데이터를 CPU에 전송
    
    ![img](https://prod-files-secure.s3.us-west-2.amazonaws.com/b0358e3f-9546-4e05-b941-84779d479fb3/634598b6-1814-4db6-87f2-49e9ab710d23/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.10.32.png)
    
- 캐시 미스
    
    : 캐시 메모리에 데이터가 존재하지 않는 경우 캐시 미스 발생
    
    ![img](https://prod-files-secure.s3.us-west-2.amazonaws.com/b0358e3f-9546-4e05-b941-84779d479fb3/96add962-1b86-4852-8a4d-e9f93883b298/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-08-12_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_11.11.44.png)
    
- 캐시 매핑
    
    ### 캐시메모리 매핑기법
    
    매핑기법에는 직접매핑/연관매핑/직접연관매핑이 있다. 이중 직접매핑을 위주로 나머지 매핑에 대하여 설명하겠다.
    
    ### **1. 직접매핑(Direct Mapping)**
    
    메모리 주소와 캐시의 순서를 일치시킨다. 메모리가 1~100까지 있고 캐시가 1~10까지 있다면 1~10까지의 메모리는 캐시의 1에 위치하고 11~20까지의 메모리는 캐시의 2에 위치시키는 것이다. 
    
    처리는 빠르지만 적중률이 낮고 성능이 낮은 단순한 방식이다.
    
    순서대로 블럭 하나 캐시 하나 매치한 것이 Direct Mapping이다
    
    즉 캐시 0라인에는 블럭 0을 캐시 1라인에는 블럭 1을 .... 캐시 3라인에는 블럭 3을, 캐시 4라인에는 블럭 0을.. 이렇게 1대1로 직접 매칭하기 때문에 Direct Mapping이다. 
    
    ### **2. 연관매핑(Associative Mapping)**
    
    순서를 일치시키지 않는다. 필요한 메모리값을 캐시의 어디든 편하게 저장 될 수 있다. 당연히 찾는 과정은 복잡하고 느릴 수 있지만 정말 필요한 캐시들 위주로 저장할 수 있기 때문에 적중률은 높다. 캐시가 일반 메모리보다 속도가 훨씬 빠르므로 캐시의 검색량을 신경쓰는 것 보단 적중률이 높은게 성능이 더 좋다.
    
    ### **3. 직접연관매핑(Set Associative Mapping)**
    
    연관매핑에 직접매핑을 합쳐 놓은 방식이다. 순서를 일치시키고 편하게 저장하되, 일정 그룹을 두어 그 그룹 내에서 편하게 저장시키는 것이다. 
    
    블록화가 되어 있기 때문에 검색은 좀 더 효율적으로 되고 직접매핑처럼 저장위치에 대한 큰 제약이 있는건 아니기 때문에 적중률이 많이 떨어지지도 않는다.
    

### **✅ 웹브라우저 캐시**

<aside>
💡 **쿠키(Cookie)**
서버와 클라이언트 간의 지속적인 데이터 교환을 위해 만들어진 Key-value 형식의 저장소

</aside>

<aside>
💡 **웹 스토리지(Web Storage)** 
웹 데이터를 클라이언트에 저장하기위해 만들어진 Key-value 형식의 저장소

</aside>

### **쿠키(Cookie)**

클라이언트(브라우저) 로컬에 저장하는 만료기간을 가진 작은 텍스트파일로, 서버와 클라이언트가 주고 받은 내용을 기억하고 불러올수 있는 역할을 수행합니다.

만료 기간을 정할 수 있어 사용자 인증이 유효한 시간을 명시할 수 있고, 브라우저가 종료되어도 만료 기간 내에는 클라이언트에 보관되어 인증이 유지된다는 특징이 있습니다.

### 🍪 쿠키의 목적

1. **세션 관리 :** 로그인, 사용자 정보, 접속 시간 등 서버가 알아야할 정보를 관리합니다.
2. **개인화 :** 언어환경, 다크/라이트 모드 등 사용자 맞춤형 페이지를 제공합니다.
3. **트래킹** : 사용자 행동 및 패턴을 분석합니다.

### 🍪 쿠키 동작 원리

1. 클라이언트가 서버에 HTTP 요청
2. 서버가 HTTP 응답 시 set-cookie로 쿠키를 생성해 전달
3. 클라이언트는 전달받은 쿠키를 HTTP 요청헤더에 담아 데이터 요청 및 응답 받는다. (이때 쿠키는 브라우저에 저장된다)
4. 이때 쿠키가 만료되었다면, 클라이언트는 서버에 쿠키 갱신 요청을 통해 새로 발급 받는다.

### 🍪 쿠키의 구성요소

- **이름(Name)** : 쿠키의 이름과 관련된 값
- **값(Value)** : 쿠키의 이름과 관련된 값
- **유효시간(Expires)** : 쿠키의 유지시간
- **도메인(Domain)** : 쿠키를 전송할 도메인
- **경로(Path) :** 쿠키를 전송할 요청 경로

### 🍪 쿠키의 종류

- **Session Cookie :** 메모리에만 저장되며, 만료기간이 있지만 브라우저 종료시 삭제되는 쿠키
- **Peristent Cookie :** 파일로 저장되며, Max-Age 설정을 통해 장기간 유지 가능하고 브라우저 종료와 관계없이 사용 가능한 쿠키
- **Secure Cookie :** HTTPS에서 사용되는 암호화된 쿠키로, 비교적 안전하지만 실질적 보안은 제공되지 않기에 민감한 데이터는 저장하지 않는 것이 좋다.
- **Third Party Cookie** : 다른 도메인에 요청이 필요할 때 생성하는 쿠키로, 주로 광고 목적으로 사용되며 유저 개인 개인정보 악용 문제가 발생할 수 있어 사용에 주의 해야 한다.

### 🍪 쿠키의 장점

1. 대부분의 브라우저에서 지원한다.
2. 데이터의 유효기간을 지정할 수 있다.
3. XSS(사이트간 악성 JS 코드를 심는 행위) 공격으로부터 안전하다
    - 서버에서 쿠키의 httpOnly 옵션을 설정하면, JS를 통해 쿠키에 접근하는 것을 막을 수 있다.

### 🍪 쿠키의 단점

1. 저장할 수 있는 데이터 용량이 매우 작다(최대 4kb)
2. 서버로 HTTP 요청시 매번 같이 전달되어야 해 서버와 네트워크 측면에 부담이 있다.
3. 쿠키 속 정보는 암호화되어 있지 않아 제 3자에게 탈취되어 악용될 수 있는 위험이 있다.
4. CSRF(사이트 간 요청 위조) 위협 존재하다.
    - CSRF : 제 3자가 사용자의 요청을 가로채 변조하여 부당 이익을 취하는 행위를 말한다.
5. 문자열만 저장 가능하다.

### 스토리지

window 객체의 프로퍼티로 존재하기도 하는 웹 스토리지는 클라이언트에 데이터를 저장할 수 있도록 HTML5부터 나온 새로운 방식의 데이터 저장소를 말합니다.

웹 스토리지로는 로컬 스토리지(Local Storage)와 세션 스토리지(Session Storage)가 있습니다.

### 📂 로컬 스토리지(Local Storage) vs 세션 스토리지(Session Storage)

두 스토리지는 영구성과 데이터 공유 범위로 구분됩니다. 먼저 로컬 스토리지는 브라우저를 종료해도 데이터가 영구적으로 보관됩니다. 반면 세션 스토리지는 브라우저 종료 시 데이터도 함께 삭제됩니다.

또한 로컬스토리지는 도메인이 같다면 전역적으로 데이터가 공유된다는 특성이 있으나, 세션 스토리지는 도메인이 같더라도 브라우저가 다르면(탭 브라우저, 다른 브라우저) 브라우저 컨텍스트가 다르기 때문에, 브라우저마다 각각의 세션 스토리지가 형성되어 데이터가 공유되지 않습니다.

|  | 로컬 스토리지 | 세션 스토리지 |
| --- | --- | --- |
| 데이터 유지 | 영구성(브라우저 종료 시 보관) | 비영구성(브라우저 종료 시 삭제) |
| 데이터 범위 | 동일한 도메인 전역 공유 | 브라우저간 공유 불가 |
| 접근 | window.localStorage | window.sessionStorage |

### 📂 웹 스토리지의 장점

1. 서버에 불필요하게 데이터를 저장하지 않아도 되어 서버 부담이 줄어듭니다.
2. 쿠키에 비해 데이터 용량이 큽니다.(모바일 : 2.5MB / 데스크탑 : 5~10MB)
3. 문자열은 물론 자바스크립트의 모든 원시형 데이터와 객체타입을 저장할 수 있습니다.
4. 도메인 단위로 접근이 제한되는 CORS 특성 덕에 CSRF위협으로부터 안전합니다.

### 📂 웹 스토리지의 단점

1. HTML5를 지원하는 브라우저에만 사용가능합니다.
2. JS코드를 통해 웹 스토리지에 쉽게 접근할 수 있어 XSS 공격에 취약합니다.

## 각 저장소는 언제 사용할까.

- **쿠키** : 일시적으로 필요한 가벼운 데이터를 저장할 때
    - e.g. `다시보지않음` 쿠키 팝업창, 로그인 자동 완성
- **로컬 스토리지** : 브라우저가 종료되어도 지속적인 데이터 저장이 필요할 때
    - e.g. 자동 로그인
- **세션 스토리지** : 브라우저가 종료되면 사라지는 일시적으로 데이터를 저장할 때
    - e.g. 일회성 로그인, 입력 폼 저장, 비로그인 장바구니
- **데이터베이스의 캐싱 계층**데이터베이스 시스템을 구축할 때도 메인 데이터베이스 위에 레디스(redis) 데이터 베이스 계층을 캐싱계층으로 두어 성능을 향상시키기도 한다.

![img](https://blog.kakaocdn.net/dn/lscSd/btsGH2hZVwz/NKpPFyfnpUVv4SNwHivkk1/img.png)

---

## 메모리 관리

### 1. 메모리 관리

운영체제의 메모리 관리 기능은 한정된 메모리 자원을 효율적으로 활용하도록 설계되어 있습니다. 이를 통해 사용자는 실제로 이용 가능한 메모리 자원을 크게 확장하여 사용할 수 있습니다.

### 2. **가상 메모리 (Virtual Memory)**

- **가상 메모리**: 실제 메모리 자원을 추상화하여 큰 메모리처럼 보이게 하는 메모리 관리 기법.
- **가상 주소 (Logical Address)**: 사용자에게 제공되는 가상의 주소.
- **실제 주소 (Physical Address)**: 실제 메모리상의 주소.
- **메모리관리장치 (MMU)**: 가상 주소를 실제 주소로 변환하는 장치.
- **페이지 테이블**: 가상 주소와 실제 주소를 매핑하여 관리.
- **TLB (Translation Lookaside Buffer)**: 페이지 테이블의 리스트를 캐시에 저장해 빠르게 주소 변환을 수행하도록 하는 캐시 계층.

### 3. **스와핑 (Swapping)**

- **스와핑**: 가상 메모리에 존재하지만 실제 메모리에 없는 데이터를 사용할 때, 당장 사용하지 않는 영역을 하드디스크로 옮기고 필요한 데이터를 메모리로 불러오는 과정.

### 4. **페이지 폴트 (Page Fault)**

- **페이지 폴트**: 프로세스가 필요한 데이터가 실제 메모리에 없는 경우 발생.
- **처리 과정**:
    1. CPU는 해당 페이지가 메모리에 없는 것을 감지하고 트랩을 발생시켜 운영체제에 알림.
    2. 운영체제는 CPU의 동작을 일시 중단.
    3. 운영체제가 페이지 테이블을 확인하고 필요 시 스와핑 수행.
    4. 페이지가 메모리에 로드되면 CPU 동작 재개.

### 5. **스레싱 (Thrashing)**

- **스레싱**: 페이지 폴트가 빈번히 발생하여 성능이 심각하게 저하되는 현상.
- **해결 방법**:
    - 메모리 증설.
    - SSD로 업그레이드.
    - 작업 세트와 PFF(Page Fault Frequency)를 통한 관리.

### 6. **메모리 할당**

- **연속 할당**: 메모리에 연속적인 공간을 할당.
    - **고정분할방식**: 미리 나눠진 메모리 공간에 프로그램을 할당.
    - **가변분할방식**: 프로그램 크기에 맞춰 동적으로 메모리를 할당.
        - **최초적합**: 공간을 위쪽이나 아래쪽부터 할당.
        - **최적적합**: 프로세스 크기에 가장 적합한 공간에 할당.
        - **최악적합**: 프로세스 크기와 가장 많이 차이 나는 공간에 할당.
        
        | 이름 | 설명 |
        | --- | --- |
        | 최초적합 (first fit) | 위쪽이나 아래쪽부터 시작해서 *홀을 찾으면 바로 할당한다. |
        | 최적적합 (best fit) | 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당한다. |
        | 최악적합 (worst fit) | 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당한다. |
- **불연속 할당**: 메모리를 연속적으로 할당하지 않는 방식.
    - **페이징**: 동일 크기의 페이지 단위로 나눠 메모리 할당.
    - **세그멘테이션**: 의미 단위로 메모리를 나눠 할당.
    - **페이지드 세그멘테이션**: 물리 메모리는 페이지로, 논리 메모리는 세그먼트로 나눔.

### 7. **페이지 교체 알고리즘**

- **오프라인 알고리즘**: 미래에 참조되는 페이지와 현재 페이지를 바꿈.
- **FIFO (First In First Out)**: 가장 먼저 들어온 페이지를 먼저 교체.
- **LRU (Least Recently Used)**: 가장 오래된 페이지를 교체.
- **NUR (Not Used Recently)**: 최근에 사용되지 않은 페이지를 교체.
- **LFU (Least Frequently Used)**: 가장 사용 빈도가 낮은 페이지를 교체.
