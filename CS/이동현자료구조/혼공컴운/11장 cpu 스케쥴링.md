# 혼자 공부하는 컴퓨터구조 + 운영체제

상태: 읽는 중
유형: 책

<aside>
💡 11장 : CPU 스케줄링

</aside>


## 1. CPU 스케줄링 개요

- CPU 스케줄링
    - 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것
    - 컴퓨터 성능과 직결되는 문제
    - 현명하게 배분하지 못하면 프로세스들이 실행되지 않거나, 무질서한 상태가 발생
- 프로세스 우선순위
    - 준비 상태인 프로세스들이 cpu 사용하고 싶다고 쫄라대면?
        
        → 차례대로 사용하게 한다 (X)
        
        ⇒ 프로세스 마다 우선순위가 있기 때문에 좋지 않는 방법!
        
    - 우선 순위가 높은 프로세스?
        - 빨리 처리해야 하는 프로세스
        - 우선순위⬆️ = 입출력 작업이 많은 프로세스
    - 입출력 작업이 많은 프로세스 먼저 하는 게 왜 효율적?
        
        → 프로세스 CPU와 입출력장치 모두 사용
        
        → 프로세스 실행 상태와 대기 상태를 반복 실행
        
        → 프로세스 종류마다 입출력장치를 이용하는 시간, CPU를 이용하는 시간의 양 차이 O
        
        <img width="568" alt="스크린샷 2023-08-30 오전 5 28 44" src="https://github.com/ssojungg/computer-architecture-and-operating-system/assets/126966126/16d75e63-270e-47b1-a6cc-df1e23aa023b">

        
    - 입출력 집중 프로세스
        - 실행 상태 < 입출력을 위한 대기 상태에 더 많이 머무르게 됨
    - CPU 집중 프로세스
        - 대기 상태 < 실행 상태 에 더 많이 머무르게 됨
    - CPU 버스트와 입출력 버스트
        - CPU 버스트 → CPU를 이용하는 작업
        - 입출력 버스트 → 입출력장치를 기다리는 작업
        - 프로세스 → 두 개 반복적으로 실행되는데 많이하는 쪽이 이름 붙는 것
    - 입출력과 CPU 동일한 빈도 가능(X) → 비합리적
        
        → 입출력을 먼저 사용하면 cpu를 한번에 처리해서 빨리 처리 할 수 있음
        
    
    ⇒  상황에 맞게 프로세스가 cpu 이용할 수 있게 하기 위해 프로세스 우선순위 부여함
    
    ⇒ PCB 우선순위 명시 → 기준으로 프로세스 처리 결정 
    
    ➡️ 자연스럽게 우선순위 높은 프로세스 더 많이 자주 실행
    

## 스케줄링 큐

- PCB 우선순위에 적힌 것부터 사용 → CPU 사용 끝 → 다음 프로세스 찾기 위해 운영체제가 일일이 프로세스 PCB 찾는 것 ➡️ 비효율
    
    운영체제 ⇒ 줄 서서 기다리길 원함
    
- 원하는 프로세스끼리 구현하고 관리해 줌
- 스케줄링은 무조건 선입선출 필요 X

⇒ 운영체제 → 메모리, 입출력장치 생성되는 프로세스 큐 삽입 (줄 세움) 

- 큐 → 운영체제 관리 ⇒ 다양한 종류 O
    - 준비 큐
        - CPU를 이용하고 싶은 프로세스들이 서는 줄
    - 대기 큐
        - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄
- 준비 상태 프로세스들의 PCB → 준비 큐 마지막 삽입 → CPU 사용할 차례 기다림
- 우선순위가 높은 프로세스 → 먼저 큐 삽입

<img width="602" alt="스크린샷 2023-08-31 오전 5 31 34" src="https://github.com/ssojungg/computer-architecture-and-operating-system/assets/126966126/ef644b3d-8fae-46c2-aa63-f434351acabb">


<img width="729" alt="스크린샷 2023-08-31 오전 5 43 49" src="https://github.com/ssojungg/computer-architecture-and-operating-system/assets/126966126/bf264ca9-c686-4b6a-8b81-4f1ff3bea5cd">


1. 입출력 완료
2. 대기 상태에서 작업 완료된 PCB 찾음
3. 준비된 상태로 바뀜(준비 큐 이동)
4. 대기 큐 삭제

<img width="636" alt="스크린샷 2023-08-31 오전 5 45 41" src="https://github.com/ssojungg/computer-architecture-and-operating-system/assets/126966126/123792a3-a822-48db-9d42-2aa1a57d350c">

프로세스 상태 다이어그램을 이용해 상세하게 만들 수 있음

## 선점형과 비선점형 스케줄링

- 실행중인 프로세스가 있는데 다른 프로세스가 급하게 요청한다면?
    1. 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당 → 선점형 스케줄링
    2. 끝날 때까지 기다리게 하기 → 비선점형 스케줄링
- 선점형 스케줄링
    - CPU를 비롯한 자원을 사용하고 있더라도 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식
    - 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
- 비선점형 스케줄링
    - 자원을 사용하고 있다면 그 프로세스가 종료, 스스로 대기 상태에 접어들기 전 다른 프로세스가 끼어들 수 없는 스케줄링 방식

운영체제 ⇒ 선점형 스케줄링 > 비선점형 스케줄링


| 스케줄링 종류 | 선점형 스케줄링                          | 비선점형 스케줄링                   |
| ------------ | -------------------------------------- | ---------------------------------- |
| 장점          | - 자원 독점 X<br>- 골고루 자원 배분 가능  | - 오버헤드 발생 적음                 |
| 단점          | - 문맥 교환 과정에서 오버헤드 발생<br>- 오버헤드(문맥 교환하는 중에는 다른 작업 X) | - 기약없는 기다림<br>- 골고루 자원 사용 X |
## 2. CPU 스케줄링 알고리즘

- 종류는 매우 다양하고 운영체제 저마다 서로 다른 스케줄링 알고리즘을 이용
- 용어 X 아이디어 O

| 알고리즘 종류 | 선입 선처리 스케줄링 | 최단 작업 우선 스케줄링 | 라운드 로빈 스케줄링 | 최소 잔여 시간 우선 스케줄링 | 우선순위 스케줄링 | 다단계 큐 스케줄링 | 다단계 큐 피드백 스케줄링 |
| ------------- | -------------------- | ---------------------- | -------------------- | ---------------------------- | ---------------- | ------------------ | ------------------------ |
| 스케줄링 이름 | FCFS 스케줄링<br>(비선점형 스케줄링) | SJF 스케줄링<br>(비선점형 스케줄링 알고리즘) | 선입 선처리 스케줄링 + 타임 슬레드(정해진 시간)<br>선점형 스케줄링 | SRT 스케줄링<br>최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링 | 우선순위 부여<br>높은 우선순위 프로세스 실행 | 우선순위 스케줄링 발전된 형태 | 다단계 큐 스케줄링 발전된 형태<br>(기아현상 발생 보안) |
| 스케줄링 내용 | 순서대로 프로세스들을 처리 | 길이가 짧은 프로세스부터 실행 | 정해진 타임 슬라이드만큼의 시간 동안 돌아가며 CPU 사용 | 프로세스들은 정해진 타임 슬레이드만큼 CPU를 사용함<br>CPU 사용할 다음 프로세스는 남아있는 작업 시간이 가장 적은 프로세스 선택 | 최단 작업 우선 스케줄링<br>작업 시간 짧은 프로세스에 높은 우선순위<br>최소 잔여 시간 우선 스케줄링<br>남은 시간이 짧은 프로세스에 높은 우선순위 | 우선순위별로 준비 큐에 있는 프로세스들을 먼저 처리<br>우선순위가 가장 높은 큐가 비어있으면 다음 우선순위 큐 프로세스 처리 | 우선순위 높은 큐 삽입<br>일정 시간 동안 실행<br>일정 시간 안에 끝내지 못하면?<br>→ 다음 우선순위 큐 삽입 실행<br>→ CPU 오래 사용할수록 점점 우선순위 낮아짐(에이징 기법)<br>⇒ CPU 사용량에 따라 우선순위 달라짐(에이징 기법) |
| 장 단점       | 공정함<br>기다리는 시간 길어짐 |  | 정해진 시간내로 끝내지 못했다면?<br>→ 문맥 교환 발생<br>타임 슬레이드 중요<br>많으면 호위 효과<br>없으면 문맥 교환 |  | 기아 현상<br>우선순위가 낮은 프로세스는 무기한 연기<br>에이징(기아 현상 방지)<br>오랫동안 대기한 프로세스의 우선순위를 점차 높임 | 유형별로 우선순위 구분 편리


<img width="663" alt="스크린샷 2023-08-31 오후 3 53 26" src="https://github.com/ssojungg/computer-architecture-and-operating-system/assets/126966126/f97c8d76-7b75-4b12-9834-1e4f5bad1c80">

라운드 로빈 스케줄링 예시

## 요약

- CPU 스케줄링 개요
    - CPU 스케줄링은 공정하고 합리적으로 CPU 자원을 배분하는 방법을 의미
    - 프로세스는 우선순위를 가지고 있고, 이는 PCB에 명시
    - 운영체제는 효율적인 스케줄링을 위해 스케줄링 큐를 사용
    - 준비 큐는 CPU 할당을 기다리는 프로세스들을 위한 큐 의미
    - 대기 큐는 입출력장치를 기다리는 프로세스들을 위한 큐를 의미
    - 선점형 스케줄링은 프로세스가 이용중인 자원을 빼앗을 수 있음
    - 비선점형 스케줄링은 프로세스가 이용중인 자원을 뺴앗을 수 없음
- CPU 스케줄링 알고리즘
    - 선입 선처리 스케줄링 알고리즘은 준비 큐에 삽인된 순서대로 CPU를 할당함
    - 최단 작업 우선 스케줄링 알고리즘은 준비 큐에 삽인된 프로세스들 중 CPU 사용 기간의 길이가 가장 짧은 프로세스부터 CPU 할당
    - 라운드 로빈 스케줄링 알고리즘은 장해진 시간만큼만 돌아가며 CPU를 할당
    - 우선순위 스케줄링 알로기름은 가장 높은 우선순위를 가진 프로세스에 CPU를 할당
    - 다단계 피드백 큐 스케줄링 알고리즘은 프로세스들이 큐 사이를 이동할 수 있는 다단계 큐 스케줄링
