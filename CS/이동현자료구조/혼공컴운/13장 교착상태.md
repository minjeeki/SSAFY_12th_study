### 교착상태
<hr>
일어나지 않을 사건을 기다리며 진행이 멈춰 버리는 현상을 교착 상태라고 한다.

### 자원할당 그래프
<hr>
프로세스가 사용하고 있는 자원가 어떤 자원을 기다리고 있는지 표현하는 그래프

1. 프로세스는 원으로, 자원의 종류는 사각형으로 표현

2. 가용 자원 개수는 사각형 내 점으로 표현

3. 프로세스가 어떤 자원을 받아 할당 중이면 자원에서 프로세스를 향해 화살표 표시

4. 프로세스가 어떤 자원을 기다리면 프로세스에서 자원으로 화살표 표기

#### 교착상태가 발생한 상황은 그래프가 원의 형태를 띈다.
<hr>

상호 배제, 점유와 대기, 비선점, 원형 대기 네 가지 조건이 있다. 

상호 배제 : 한 프로세스가 사용 중인 자원을 다른 프로세스가 사용할 수 없을때

점유와 대기 : 자원을 할당 받은 상태에서 다른 자원을 할당 받기 기다리는 상태

비선점 : 다른 프로세스의 자원을 강제로 빼앗지 못했기 때문에 교착 발생

원형 대기 : 자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 수 있따. 

## 교착 상태 해결 방법
예방, 회피, 검출, 회복 4가지 방법이 있다.

#### 예방
<hr>
상호배제를 없앤다는 것은 현실 적용이 힘들다. <br>
점유 대기 없애는 것은 이론상 가능하지만 자원의 활용률이 낮아지는 등 문제 발생.자원 많이 활용하는 프로세스의 기아 현상 발생<br>
비선점 없애기. 프린터기는 동시에 작업할 수 없는데 자원을 뺏어 이용하기란 어렵다. 다소 범용성 떨어지는 방법<br>
원형 대기 조건 없애기. 자원에 번호 할당 후 오름차운 대기 시 원형 대기가 발생하지 않는다. but 수많은 자원에 번호를붙이는 일이 간단하지 않고 어떤 번
호를 붙이는지에 따라 자원의 활용률이 떨어질 수 있다.

#### 회피
<hr>
자원 할당을 조심하는 방식
프로세스들에 할당할 수 있는 자원의 양을 고려해 교착 상태 발생을 막는다.
안전 상태 : 교착 상태가 발생하지 않고 모든 프로세스가 정상 자원 할당 받고 종료될 수 있는 상태
불안정 상태 : 교착 상태가 발생할 수 있는 상황
안전 순서열 : 교착 상태 없이 안전하게 프로세스들에 자원을 할당할 수 있는 순서를 의미한다. 

#### 검출 후 회복
교착 상태 발생을 인정하고 사후 조치하는 방식 
선점으로 회복 : 교착 상태 해결될 때까지 한 프로세스에 자원 몰아주는 방식 
프로세스 강제 종료 회복 : 모두, 또는 하나씩 강제종료해서 해결 그러나 작업 내역 잃을 수 있고 교착상태 해결 여부 파악에 오버헤드 야기

<hr>

## 가상, 메모리
<hr>
외부 단편화 여러 프로세스들이 적재되었다가 몇 개가 메모리를 떠나 빈 공간이 생긴다. 이 때 총 공간이 띄엄띄엄 50mb 가 있고 새로 올 프로세스
가 50mb라면 프로세스가 적재될 수 없다. -> 메모리 낭비 이것이 외부 단편화
-> 외부 단편화 해결 방안 압축
흩어져 있는 빈공간을 하나로 모으는 방식 but, 이 작업 동안 시스템은 일을 중지해야하고, 옮기는 작업은 많은 오버헤드가 발생되고, 최적의 움직임을
결정하기 어렵다. 외부 단편화를 없앨 수 있는게 가상 메모리 기법, 그 중에서 페이징 기법이다. 

## 페이징이란
<hr>
메모리와 프로세스를 일정한 단위로 자르고 불연속적으로 할당하면 외부단편화 발생하지 않는다. 
프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 
페이지를 프레임에 할당하는 가상 메모리 관리 기법이다. 
가장 실행에 필요하지 않은 페이지는 보조기억장치에 남겨둘 수 있다.

문제 -> 불연속적 배치면 cpu 입장에서 순차적 실행이 불가. 물리 주소는 불연속적, 논리 주소는 연속적으로 배치되더록 페이지 테이블을 이용 

 cpu 내 페이지 테이블 베이스 레지스터는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
 메모리의 접근 해야하는 횟수가 증가하는 문제는 TLB라는 페이지 테이블의 캐시 메모리를 둔다. 참조 지역성에 근거해 최근에 사용된 페이지
 위주로 가져와 저장한다.
 CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있으면 TLB 히트 -> 메모리 접근 한 번만 하면 된다.
 없으면 TLB 미스 -> 접근 두번해야함 

 페이징 시스템에서 논리 주소는 페이지 번호와 변위로 이루어져있다. -> 페이지테이블 -> 물리주소(프레임 번호, 변위)로 변환

 #### 페이지 폴트
 <hr>

 CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면 페이지 폴트라는 예외가 발생한다. 
 보호 비트로 페이지가 읽고 쓰기 가능한지, 읽기만 가능한지 등을 실행과 더불어 나타낸다. 
 참조 비트로 페이지에 접근한 적이 있는지 여부를 나타낸다. 적재 이후 한 번도 읽거나 쓰지 않으면 0으로 유지
 수정(더티) 비트 해당 페이지에 데이터를 쓴 적이 있는지의 유무
 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야하는지의 필요 유무 판단위해 존재한다. 
 CPU가 쓰기 작업을 하면 페이지 내용과 메모리 내용이 다른 값을 가지게 되고 이를 위해 스왑 아웃 상황을 대비해 보조기억장치에 기록한다.
 -> 메모리 관리와 성능 최적화 기여 

## 페이지 교체와 프레임 할당
<hr>
요구 페이징
프로세스를 메모리에 적재할 때부터 처음부터 필요한 페이지만들 메모리에 적재하는 방법 

#### 페이지 교체 알고리즘
좋은 알고리즘 기준 페이지 폴트를 많이 발생시키지 않는 알고리즘 

### fifo 페이지 교체 알고리즘. 단순하다 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
장점 : 구현과 아이디어가 간단하다.
단점 : 초기 적재된 페이지 속에는 프로그램 실행 내내 사용될 내용을 포함하고 있을 수 있는데 이를 쫓아낼 수도 있다.

### fifo 개선 ->  2차 기회 페이지 교체 알고리즘
기본적으로는 fifo와 비슷하지만 참조 비트가 1이면 사용했었따는 것이므로 내보낼 페이지 선별시 참조 비트를 0으로 바꾸고 내보내지 않는다.
기회를 하나 더 주는 것임. 참조 비트가 0 이면 내보내는 것

### 최적 페이지 교체 알고리즘
사용 빈도가 낮은 페이지를 교체하는 것이 가장 합리적이므로 그렇게 내보낼 페이지를 선별한다. 
장점 : 페이지 폴트 비율이 fifo 알고리즘보다 낮다.
단점 : 실제 구현이 어렵다. 앞으로 오랫동아 사용되지 않을 페이지 예측이 너무 어렵고 현실적으로 불가능합니다. 

### LRU 페이지 교체 알고리즘
최적 페이지 교체가 오랫동안 사용되지 '않을' 이라면 이는 않은 페이지를 교체하는 알고리즘이다.
폴트 비율이 최적보다는 높다.

이를 넘어, 프로세스가 사용할 수 있는 프레임 수가 많으면 페이지 폴트 빈도는 감소한다. 
#### 스레싱
프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저하되는 문제
메모리에서 동시에 실행되는 프로세스의 수를 멀티프로그래밍의 정도이다. 이게 높으면 동시에 많은 프로세스가 실행 중이라는 뜻

### 프레임 할당 방식
균등 할당과 비례 할당
균등은 모든 프로세스에 균등하게, 비례는 프로세스 크기에 따라 나눠주는 방식

#### 작업 집합 모델과 페이지  폴트 빈도 이용 방식
둘 다 프로세스의 실행을 보고 할당할 프레임 수를 정해서 동적 할당 방식이다.
작업 집합 모델 방식은 프로세스가 일정 기간 동안 참조한 페이지를 기억해 페이지 교체를 방지한다.

페이지 폴트 빈도 기반 프레임 할당 방식
1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다.
2. 페이지 폴트율이 너무 낮으면 그 프로세스가 너무 많은 프레임을 갖고 있따.
폴트율 상한선과 하한선을 정하고 이 범위 안에서만 프레임을 할당하는 방식이다. 
