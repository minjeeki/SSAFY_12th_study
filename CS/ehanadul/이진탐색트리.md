## 트리

- 노드들이 나무 가지처럼 연결된 **비선형**(non-linear), **계층적** 자료구조
    - 한 노드가 여러 노드를 가리킬 수 있음
- 그래프(Graph)의 일종이며 데이터 구조의 상하 개념 계층의 구조적 속성을 표현

## 이진 트리**(Binary Tree)**

- **모든 노드의 최대 차수를 2로 제한한 것**
- 각 노드는 **자식노드를 최대 2개까지 가질 수 있음**

### 이진트리(Binary Tree)의 종류

- **정 이진트리(Full Binary Tree) or** 엄격한 이진트리(Strcit Binary Tree)
    - 모든 노드가 2개의 자식을 가지거나 자식이 없는 경우(자식이 한 개인 경우x)

- **포화 이진트리(Perfect Binary Tree)**
    - 모든 노드가 2개의 자식을 가지고 leaf노드가 모두 같은 레벨
    - 모든 레벨의 노드가 꽉차있기 때문에 자식노드의 개수가 2의 제곱수만큼 증가
        - (높이가 h일 때) 노드 개수 :  2k+1 - 1 ,  Leaf 노드의 개수 : 2h
        
- **완전이진트리(Complete binary tree)**
    - 마지막 레벨을 제외한 모든 노드가 채워져 있어야함
    - 노드는 왼쪽에서 오른쪽 방향으로 채워져야 함
    - 어느 노드에 오른쪽 자식이 존재한다면 왼쪽 자식도 가지고 있어야 완전이진트리
    - 포화이진트리(Perfect binary tree)도 완전이진트리(Complete binary tree)의 조건을 모두 충족하므로 완전이진트리에 속함

---

# 이진검색트리**(Binary Search Tree : BST)**

## **이진 탐색 트리 특징**

- 이진 탐색 트리도 **이진 트리** 구조로 이루어져 있음
- 노드의 왼쪽 서브 트리에는 루트 노드보다 작은 값
- 노드의 오른쪽 서브 트리에는 루트 노드보다 큰 값
- 서브 트리도 **이진 탐색 트리 구조**
- 중복된 값 없음

### **이진 탐색 트리 예시**

- **이진 탐색 트리**는 중위 탐색(Inorder)을 하면 **오름 차순으로 인덱스를 탐색 할 수 있음**
    
    (1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9)
    
- 트리의 최솟값 - 가장 왼쪽
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/301c69f8-7720-41af-8034-3c5d81a34e6a/Untitled.png)
    
- 트리의 최댓값 - 가장 오른쪽
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/b9aaec98-f3c8-4645-93f9-54c6ce2cfd5c/Untitled.png)
    

## **이진 탐색 트리의 삽입**

- 중복된 데이터 삽입X
    - **삽입 시 탐색 과정에서 같은 숫자가 있는 것을 발견**하면 삽입하지 않고 그대로 종료
- 추가된 노드는 트리의 **leaf 노드**에 삽입

**이진 탐색 트리의 삽입 - 예시**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/848e2930-c603-4e47-9a5d-d50a55702a27/Untitled.png)

1. 먼저 **루트 노드**인 8과 비교
2. 1은 루트 노드 8보다 더 더 작기 때문에 왼쪽 노드인 5와 다시 비교
3. 5와 비교했을 때도 더 작기 때문에 또 왼쪽 노드로 이동하여 2와 비교
4. 2와 비교했을 때도 더 작은데 왼쪽 노드가 비어있기 때문에 2의 왼쪽 노드에 삽입

## **이진 탐색 트리의 삭제**

- 삭제 데이터의 위치를 찾아야 함
    - 삭제할 데이터가 leaf인 경우
    - 한 개의 자식 노드를 가질 경우
    - 두 개의 자식 노드를 가질 경우

### **이진 탐색 트리의 삭제 - 예시**

- **삭제 할 노드가 leaf 노드인 경우** (2, 8)
    - null을 부모 노드에게 리턴시켜 자신을 가리키던 자식 포인터를 null로 바꿈
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/e10385f3-afa9-420f-8613-23648f4a0b83/Untitled.png)
        
    
- **삭제 할 노드가 한 개의 자식 노드를 가질 경우** (1)
    - 해당 노드의 자식 노드를 1의 부모 노드였던 3의 자식 노드를 가리키던 포인터와 연결 시킴
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/aca5577c-831f-44c6-b1bf-e221252715e1/Untitled.png)
        

- **삭제 할 노드 두 개의 자식 노드를 가질 경우(7)**
    - 오른쪽 서브 트리의 최솟값과 교체 (왼쪽 서브 트리의 최댓값과 교체)
    - 7의 오른쪽 서브 트리에는 8과 9가 존재하여 이 중 최솟값인 8(successor 노드)과 삭제하고자 하는 노드 7을 교체
    - 8이라는 데이터가 중복되기 때문에 leaf 노드의 8 삭제
    - 이때 8은 leaf 노드이기 때문에 첫번째  **방법**으로 null을 대입하여 삭제
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/8aa7a03b-d547-45e1-aef7-1d01c2c63d57/Untitled.png)
        

## **이진 탐색 트리 검색**

: 이진 탐색 트리에서 특정 요소의 위치를 찾는 연산

- 과정
    1. 루트에서 출발
    2. 검색 값과 루트 노드 비교
        - 루트보다 작으면 왼쪽에 대해 재귀 호출 진행, 크다면 오른쪽에 대해 재귀 호출 진행
    3. 일치하는 값을 찾을 때까지 절차 반복
    4. 만약 검색 값이 없다면 null을 반환