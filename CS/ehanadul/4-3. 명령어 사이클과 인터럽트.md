# Chapter4-3. CPU의 작동원리-명령어 사이클과 인터럽트

# 04-3. 명령어 사이클과 인터럽트

CPU가 하나의 명령어를 처리하는 흐름인 명령어 사이클과 그 흐름을 방해하는 인터럽트

CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고,
CPU는 그 흐름을 반복하며 명령어를 처리해 나감

- 하나의 명령어를 처리하는 정형화된 흐름을 `명령어 싸이클` 이라고 함
- CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 간혹 이 흐름이 끊어지는 상황이 발생하는데

  이를 `인터럽트` 하고 함


## 명령어 사이클

- 우리가 실행하는 프로그램은 수많은 명령어로 이루어져 있고, CPU는 이 명령어를 하나씩 실행함
- 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데 이 주기를 `명령어 사이클(instruction cycle)` 이라고 함
- 즉, 각각의 명령어들은 명령어 사이클이 반복되어 실행됨
- 메모리에 저장된 명령어를 하나를 실행한다고 가정했을 때 가장 먼저 해야 할 것은
  명령어를 메모리에서 CPU로 가져와야 함 ⇒ 명령어의 첫 번째 과정
    - 메모리에 있는 명령어를 CPU로 가져오는 단계를 `인출 사이클(fetch cycle)` 이라고 함
    - 2)~ 6) 단계가 인출 사이클의 과정임
        - **인출 사이클 과정**

            2) 프로그램을 처음부터 실행하기 위해, 프로그램 카운터에는 1000이 저장됨
               ⇒ 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미함

          ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/ab4c3dce-49c0-4f83-a90d-ac788c86f6c3/Untitled.png)

            3) 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 함

          이를 위해 메모리 주소 레지스터는 1000이 저장됨

          ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/3257de67-0581-4c16-bf71-0785928fcb0f/Untitled.png)

            4) ‘메모리 읽기’ 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐

          ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/9817bb06-9c1b-46a5-a772-b070c7ee0dbb/Untitled.png)

            5) 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고,
               프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 함

          ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/08f24c57-4b44-4c33-bc48-074b92aaac97/Untitled.png)

            6) 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동함

          ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/758d0735-7645-4a2c-ba45-2cdb5d181e05/Untitled.png)

- CPU로 명령어를 인출했다면 명령어를 실행함 ⇒ 명령어 사이클의 두 번째 과정
    - CPU로 가져온 명령어를 실행하는 단계를 `실행 사이클(execution cycle)`
    - 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
- 프로그램을 이루는 수많은 명령어는 일반적으로 인출과 실행 사이클을 반복하면서 실행됨
- 즉, CPU는 프로그램 속 명령어를 가져오고 실행하고, 또 가져오고 실행하고를 반복함



                                 [인출 사이클]    ↔    [실행 사이클]


**명령어 사이클** : 하나의 명령어가 처리되는 주기

- 하지만 모든 명령어가 간단히 실행되는 것은 아님

  : 명령어를 인출하여 CPU로 가져와도, 곧바로 실행할 수 없는 경우가 있음

    - 간접 주소 지정 방식을 예를 들자면, 간접 주소 지정 방식은 오퍼랜드 필드에 유효 주소의 주소를 명시하므로, 명령어를 인출하여 CPU로 가져왔다 하더라도 실행 사이클에 돌입할 수 없음 → 명령어를 실행하기 위해서 메모리 접근을 한 번 더 해야함 : `간접 사이클(indirect cycle)`
- 어떤 명령어는 인출과 실행 사이클만으로 실행되지만, 어떤 명령어는 **인출, 간접, 실행사이클**을 거쳐 실행

## 인터럽트

`인터럽트(interrupt)` 는 ‘방해하다, 중단시키다’를 의미함

- CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데, 이렇게 **CPU의 신호를 방해하는 신호**를 인터럽트 라고 함

예) ‘이 업무가 더 급하므로, 지금 하던 일 멈추고 이것부터 처리해 줘’ 라는 상황이 인터럽트

- CPU가 작업을 잠시 중단해야 할 정도라면 인터럽트는 ‘CPU가 꼭 주목해야 할 때’ 혹은 ‘CPU가 얼른 처리해야 하는 다른 작업이 생겼을 때’ 발생함
- **즉, 인터럽트는 CPU의 정상적인 작업을 방해하는 신호**
- 인터럽트의 종류는 크게 **`[1] 동기 이터럽트`** 와 **`[2] 비동기 인터럽트`** 가 있음

> **동기 인터럽트**(synchronous interrupts)
>

---

CPU에 의해 발생하는 인터럽트

- CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때,
  예를 들어 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
- 동기 인터럽트는 예외(exception)라고 부름

> **비동기 인터럽트(asynchronous interrupts)**
>

---

주로 입출력장치에 의해 발생하는 인터럽트

입출력장치에 의해 의한 비동기 인터럽트는 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 알림 역할

- CPU가 프린터와 같은 입출력장치에 입출력 작업을 ㅂ탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)를 보냄
- 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)를 보냄
- 일반적으로 비동기 인터럽트를 **인터럽트**라고 함, 그러나 아래로 쭉 `하드웨어 인터럽트` 용어 사용

**인터럽트는 [1] 동기 인터럽트(예외) [2] 비동기 인터럽트(하드웨어 인터럽트)** 가 있음

> **하드웨어 인터럽트**
>

---

하드웨어 인터럽트는 알림과 같은 인터럽트

- CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 알림과 같은 하드웨어 인터럽트를 사용함

  예를 들어, CPU가 프린터에 출력을 명령했다고 가정
  입출력장치는 CPU보다 속도가 현저히 느리기 때문에, CPU는 입출력 작업의 결과를 바로 받아볼 수 없음. 하드웨어 인터럽트를 사용하지 않으면 CPU는 프린터가 언제 프린트를 끝낼지 모르기 때문에 주기적으로 프린터의 완료 여부를 확인해야 하고, 이것은 CPU 사이클 낭비임

- 하드웨어 인터럽트를 이용하면 CPU는 주기적으로 프린트 완료 여부를 확인할 필요가 없음
- CPU는 프린터로부터 프린트 완료 인터럽트를 받을 때 까지 다른 작업을 처리할 수 있음
- 하드웨어 인터럽트는 입출력 작업 중에도 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 함

> **하드웨어 인터럽트 처리 순서**
>

---

CPU가 인터럽트를 처리하는 방식은 종류를 막론하고 대동소이함

<CPU가 하드웨어 인터럽트를 처리하는 순서>

(1) 입출력장치는 CPU에  **인터럽트 요청 신호** 를 보냄

(2) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함

(3) CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인

(4) 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업함

(5) CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행함

(6) 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해둔 작업을 복구하여 실행을 재개함

`인터럽트 요청 신호`, `인터럽트 플래그`, `인터럽트 벡터`, `인터럽트 서비스 루틴`

- 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기에 다른 누군가가 인터럽트하기 전에는
  ”지금 끼어들어도 되나요?” 하고 CPU에 물어봐야 함 ⇒ **`인터럽트 요청 신호`**
- 이 때, CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터의 **`인터럽트 플래그(interrupt flag)`**가 활성화되어 있어야 함
    - 인터럽트 플래그는 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
    - CPU가 중요한 작업을 처리해야 하거나 어떤 방해도 받지 않아야 할 때 인터럽트 플래그는 불가능으로 설정됨
    - 인터럽트 플래그가 ‘불가능’ 으로 설정되어 있다면 CPU는 인터럽트 요청이 오더라도 해당 요청 무시
    - 인터럽트 플래그가 ‘가능’ 으로 설정되어 있다면 CPU는 인터럽트 요청 신호를 받아들이고 인터럽트 처리

  | 부호 플래그 | 제로 플래그 | 캐리 플래그 | 오버플로우 플래그 | 인터럽트 플로그 | 슈퍼바이저 플래그 |
      | --- | --- | --- | --- | --- | --- |
    - 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아님
    - 인터럽트 플래그가 불가능으로 설정되어 있어도, 무시할 수 없는 인터럽트 요청이 있음

      ⇒ 정전이나 하드웨어 고장으로 인한 인터럽트

- **인터럽트**는 **[1] 동기 인터럽트(예외)** 와 **[2] 비동기 인터럽트(하드웨어 인터럽트)** 로 나뉘고,
  비동기 인터럽트(하드웨어 인터럽트)는 (a)**막을 수 있는 인터럽트**와 (b)**막을 수 없는 인터럽트**로 나뉨
- CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 **`인터럽트 서비스 루틴`**이라는 프로그램 실행
    - **인터럽트 서비스 루틴(ISR; interrupt Service Routine)**은 인터럽트를 처리하기 위한 프로그램으로, **인터럽트 핸들러(interrupt handler)** 라고도 불림

      ⇒ 인터럽트 서비스 루틴은 ‘키보드가 어떤 인터럽트 요청을 보냈을 때는 어떻게 작동한다’

      ‘마우스가 어떤 인터럽트 요청을 보냈을 때는 어떻게 장동한다’

      ‘프로그램에 어떤 문제가 생겼을 때는 어떻게 작동한다’

      라는 어떤 인터럽트가 발생했을 때 해당 인터럽트를 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어진 프로그램

- **CPU가 인터럽트를 처리한다** 라는 말은 ‘**인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다’** 라는 말과 같음

- 인터럽트를 처리하는 방법은 입출력장치마다 다르므로 각기 다른 인터럽트 서비스 루틴을 가지고 있음
- 메모리에는 여러 개의 인터럽트 서비스 루틴이 저장되어 있고, 이들 하나하나가 ‘인터럽트가 발생하면 어떻게 행동해야 할지를 아려주는 프로그램’ 이라고 보면됨
- CPU는 각기 다른 인터럽트 서비스 루틴을 구분하기 위해 `인터럽트 벡터`(interrupt vector) 를 이용
    - 인터럽트 벡터는 인터럽트 서비스 루틴을 식별하기 위한 정보
    - 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있어 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있음

  **CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받음**

  예를 들어, CPU가 작업을 수행하는 도중 키보드 인터럽트가 발생한 경우라면,
  CPU는 인터럽트 벡터를 참조하여 키보드 인터럽트 서비스 루틴의 시작 주소를 알아내고,
  이 시작 주소로부터 실행해 나가며 키보드 인터럽트 서비스 루틴을 실행함

  다시 정리하면,
  **CPU가 인터럽트를 처리한다** 라는 말은

  ‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다’ 는 말이며
  CPU가 인터럽트 서비스 루틴을 실행하려면 인터럽트 서비스 루틴의 시작 주소를 알아야 하는데,
  이를 인터럽트 벡터를 통해 알 수 있다는 것

- 인터럽트 서비스 루틴은 다른 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있음

  ⇒ 인터럽트 서비스 루틴도 프로그램 카운터를 비롯한 레지스터를 사용하며 실행됨

  이 때, 인터럽트가 발생하기 전까지 레지스터에 저장되어 있던 값들은?

  예를 들어, CPU의 프로그램 카운터에 1500이 저장되어 있을 때, 이 CPU에 하드웨어 인터럽트가 발생하여 10번지에 있는 인터럽트 서비스 루틴을 실행해야 한다고 가정하면 기존에 프로그램 카운터에 저장되어 있던 1500은 10으로 덮어쓰지 않음 ⇒ 인터럽트 요청을 받기 전까지 CPU가 수행하고 있었던 일은 인터럽트 서비스 루틴이 끝나면 되돌아와서 마저 수행을 해야 하기 때문에 지금까지의 작업 내역을 어디에 백업을 해두어야 함

  ⇒ CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위한 필요한 모든 내용을 **스택에 백업함** 그리고 나서 인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터 값을 갱신하고 인터럽트 서비스 루틴을 실행함

  ⇒ 인터럽트 서비스 루틴을 모두 실행하면(인터럽트를 처리하고 나면), 스택에 저장된 값을 불러와 이전 까지 수행하던 작업을 재개함


`인터럽트 요청 신호` : **CPU의 작업을 방해하는 인터럽트에 대한 요청**

`인터럽트 플래그` : **인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트**

`인터럽트 벡터` : **인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보**

`인터럽트 서비스 루틴` : **인터럽트를 처리하는 프로그램**

**명령어 사이클은 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있음**

<aside>
💡 **예외의 종류

- 예외의 종류에는 `폴트`, `트랩`, `중단`, `소프트웨어 인터럽트` 가 있음**

- 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리함
  예외를 처리하고 나면 CPU는 본래 하던 직업으로 되돌아와 실행을 재개함

- 여기서, CPU가 본래 하던 작업으로 되돌아 왔을 때
  [**1] 예외가 발생한 명령어부터 실행하느냐** , [**2] 예외가 발생한 명령어의 다음 명령어부터 실행하느냐** 에 따라서 `폴트` 와 `트랩` 으로 나뉨

**폴트(fault) 는 예외를 처리한 직후 예외 처리가 발생한 명령어부터 실행을 재개하는 예외**
예를 들어, CPU가 한 명령어를 실행하려 할 때, 이 명령어를 실행하기 위해 꼭 필요한 데이터가 메모리가 아닌 보조기억장치에 있다고 가정해본다면 프로그램이 실행되기 위해서는 반드시 메모리에 저장되어 있어야 하기에 CPU는 폴트를 발생시키고 보조기억장치부터 필요한 데이터를 메모리로 가져와 저장함
보조기억장치로부터 필요한 데이터를 메모리로 가지고 왔으면 CPU는 다시 실행을 재개하고, CPU는 폴트가 발생한 그 명령어부터 실행함
⇒ 이렇게 예외 발생 직후 예외가 발생한 명령어부터 실행해 나가는 예외를 폴트

**트랩(trap)** 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
주로, 디버깅(debugging, 프로그램 개발 중 발생한 문제를 진단하고 해결하기 위한 작업) 할 때 사용함
예를 들어, 디버깅 할 때 특정 코드가 실행되는 순간 프로그램을 실행을 멈추게 할 수 있음
CPU에 ‘이 코드가 실행된 그 순간의 프로그램 상태를 보고 시픙니, 이 코드가 실행되는 순간 잠시 실행을 멈춰라’ 라고 명령함
트랩을 처리하고 나면(프로그램을 주단시키고 디버깅이 끝나면), 프로그램은 다음 명령어부터 실행을 이어나가면 됨
⇒ 트랩은 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외

**중단(abort)은 CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

소프트웨어 인터럽트(softwar interrupt)는 시스템 호출이 발생했을 때 나타남**

</aside>

명령어 사이클 : 하나의 명령어를 처리하는 정형화된 흐름

인터럽트 : CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 간혹 이 흐름이 끊어지는 상황

## 명령어 사이클(instruction cycle)

= 프로그램 속 각각의 명령어들이 일정하게 실행되는 주기

1. 인출 사이클(fetch cycle) :메모리에 있는 명령어를 CPU로 가져오는 단계
    1. IF. 명령어를 인출하여 CPU로 가져와도, 곧바로 실행할 수 없는 경우 → `간접 사이클(indirect cycle)`
2. `실행 사이클(execution cycle)` : CPU로 가져온 명령어를 실행하는 단계
    1. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호 발생
3. 1,2번 반복

## 인터럽트(interrupt)

= **CPU의 신호를 방해하는 신호**

- 동기 이터럽트
- 비동기 인터럽트
    - 막을 수 있는 인터럽트
    - 막을 수 없는 인터럽트

- 인터럽트 요청 신호 : **CPU의 작업을 방해하는 인터럽트에 대한 요청**
- 인터럽트 플래그 : **인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트**
- 인터럽트 벡터 : **인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보**
- 인터럽트 서비스 루틴 : **인터럽트를 처리하는 프로그램**

> **동기 인터럽트**(synchronous interrupts)
>

---

CPU에 의해 발생하는 인터럽트

- CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때,
  예를 들어 CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
- 동기 인터럽트는 예외(exception)라고 부름

> **비동기 인터럽트(asynchronous interrupts)**
>

---

주로 입출력장치에 의해 발생하는 인터럽트

입출력장치에 의해 의한 비동기 인터럽트는 세탁기 완료 알림, 전자레인지 조리 완료 알림과 같은 알림 역할

- CPU가 프린터와 같은 입출력장치에 입출력 작업을 ㅂ탁하면 작업을 끝낸 입출력장치가 CPU에 완료 알림(인터럽트)를 보냄
- 키보드, 마우스와 같은 입출력장치가 어떠한 입력을 받아들였을 때 이를 처리하기 위해 CPU에 입력 알림(인터럽트)를 보냄
- 일반적으로 비동기 인터럽트를 **인터럽트**라고 함, 그러나 아래로 쭉 `하드웨어 인터럽트` 용어 사용

---

> **하드웨어 인터럽트**
>

---

알림과 같은 인터럽트

- CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 알림과 같은 하드웨어 인터럽트를 사용함
- 하드웨어 인터럽트를 이용하면 CPU는 주기적으로 입출력장치(프린트) 완료 여부를 확인할 필요가 없음
- CPU는 입출력장치(프린트)로부터 완료 인터럽트를 받을 때 까지 다른 작업을 처리할 수 있음
- 하드웨어 인터럽트는 입출력 작업 중에도 CPU로 하여금 효율적으로 명령어를 처리할 수 있게 함

- CPU가 하드웨어 인터럽트를 처리하는 순서

  (1) 입출력장치는 CPU에  **인터럽트 요청 신호** 를 보냄

  (2) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함

  (3) CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인

  (4) 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업함

  (5) CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행함

  (6) 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해둔 작업을 복구하여 실행을 재개함


---

### 예외

- 폴트 : 예외를 처리한 직후 예외 처리가 발생한 명령어부터 실행을 재개하는 예외
- 트랩 : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
    - ex) 디버깅
        - 특정 코드가 실행되는 순간 프로그램을 실행을 멈추게 할 수 있음

          → 예외가 발생한 명령어의 다음 명령어부터 실행을 재개

- 중단 : CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
- 소프트웨어 인터럽트 : 시스템 호출이 발생했을 때