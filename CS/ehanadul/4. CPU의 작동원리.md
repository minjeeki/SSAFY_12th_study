# 04-1.  ALU와 제어장치

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/586a5b54-9c18-4f2c-a619-cf273e397ea5/ebc3207e-7b10-42cc-ab1c-3d216f292d6a.png)

- CPU :  **메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치**
- CPU 내부에는 계산을 담당하는 `ALU`, 명령어를 읽어 들이고 해석하는 `제어 장치`, 작은 임시 저장 장치인 `레지스터` 라는 구성 요소가 있음

## ALU

---

- ALU는 계산하는 부품
    - 예 ) 1+2 →  1과 2라는 피연산자와 더하기 라는 수행할 연산이 필요함
    ⇒ 즉, ALU가 계산을 하기 위해서는 `피연산자` 와 `수행할 연산` 이 필요함

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/8bb83aa5-93ca-440f-9f30-c6f94b2409d2/Untitled.png)

- 레지스터를 통해 **피연산자** 를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 **제어 신호** 를 받아들임
- 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산 수행
- ALU가 내보내는 정보는  바로 메모리에 저장되지 않고 일시적으로 **레지스터에 저장**
    - CPU가 메모리에 접근하는 속도는 레지스터에 접근하는 속도보다 훨씬 느림
    → ALU가 연산할 때마다 결과를 메모리에 저장한다면 CPU는 메모리에 자주 접근하게 되고, 프로그램 실행 속도를 늦출 수 있음. 그래서 ALU의 결과값을 **레지스터에 우선 저장**
    
- **플래그**
    - 연산 결과에 대한 추가적인 상태 정보(결과값 외에 ALU가 내보내는 또 다른 정보)
    - 플래그는 `플래그 레지스터` 라는 레지스터에 저장됨
    ⇒ **플래그 레지스터** 는 플래그 값들을 저장하는 레지스터
    - CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 참고 정보
        - 예)  이진수 → 음수인지 양수인지 판단 어려움,
            
             음수와 양수를 구분하기 위해 플래그를 사용함
            
            ⇒ 이처럼 결과값뿐 아니라 연산 결과에 대한 **추가적인 정보를 내보내야 할 때가 있음**
            
        - 연산 결과가 연산 결과를 담을 레지스터보다 클 때 ALU는 ‘결괏값이 너무 크다’ 라는 추가 정보를 내보냄
         ⇒ 연산 결과가 연산 결고를 담을 레지스터보다 큰 상황 : **`오버플로우(overflow)`**
    - 참고
        
        <ALU가 내보내는 대표적인 플래그>
        
        | 플래그 종류 | 의미 | 사용 예시 |
        | --- | --- | --- |
        | 부호 플래그 | 연산한 결과의 부호를 나타냄 | 부호 플래그가 1일 경우 계산 결과는 음수, 
        0일 경우 계산 결과는 양수 의미 |
        | 제로 플래그 | 연산 결과가 0인지 여부 나타냄 | 제로 플래그 1인 경우 연산 결과는 0,
        0인 경우 연산결과는 0이 아님 |
        | 캐리 플래그 | 연산 결과 올림수나 빌림수가 발생했는지 나타냄 | 캐리 플래그가 1인 경우 올림수나 빌림수가 발생,
        0인 경우 발생하지 않음 |
        | 오버플로우
        플래그 | 오버플로우가 발생했는지 나타냄 | 오버플로우 플래그가 1인 경우 오버플로우 발생,
        0인 경우 발생하지 않음 |
        | 인터럽트
        플래그 | 인터럽트가 가능한지 나타냄 | 인터럽트 플래그가 1인 경우 인터럽트 가능
        0인 경우 인터럽트 불가능 |
        | 슈퍼바이저
        플래그 | 커널 모드로 실행 중인지,
        사용자 모드로 실행중인지 나타냄 | 슈퍼바이저 플래그가 1인 경우 커널 모드로 실행 중
        0인 경우 사용자 모드 |

## 제어장치

---

- 제어 신호를 내보내고, 명령어를 해석
- **제어 신호 →**  컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/0e867e6a-b7a5-4447-ab0c-f7ce895fc913/Untitled.png)

### 제어 장치가 받아들이는 정보

- **클럭 신호**
    - `클럭(clock)` : 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위
        
                                 클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나,
                                 ALU에서 계산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어들임
        
        ⇒ 다만, ‘컴퓨터의 모든 부품이 클럭 신호에 맞춰 작동한다’ 라는 말은
        ’컴퓨터의 모든 부품이 한 클럭마다 작동한다’ 는 말이 아님
        **컴퓨터 부품은 클럭이라는 박자에 맞춰 작동할 뿐, 한 박자 마다 작동하는 것은 아님**
        
        아래의 그림 처럼, 하나의 명령어가 여러 클럭에 걸쳐 실행될 수 있음
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/41b71eb3-1a24-4a7d-a873-c925b5d42c66/Untitled.png)
        
        ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/797f0556-052c-4ddd-bcd7-cd2416e6a7a4/Untitled.png)
        

- **해석해야 할 명령어**
    - CPU가 해석해야 할 명령어는 `명령어 레지스터` 라는 특별한 레지스터에 저장됨
    - 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려줌
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/7d5b9e29-85de-46a6-bea3-6e8426758c13/Untitled.png)
    

- **플래그 레지스터 속 플래그 값**
    - 제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킴
    - 제어장치가 제어 신호를 통해 컴퓨터 부품들을 제어할 때, 이 사항을 무시하면 안됨
        
        (플래그는 ALU 연산에 대한 추가적인 상태 정보)
        
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/243a0a59-8d3a-45b9-a126-b057c9a2c8da/Untitled.png)
    
- **제어 버스로 전달된 제어 신호**
    - 제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있음
    - 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들임
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/a9cd508b-9586-4ab5-b1c8-713ee91ad1fa/Untitled.png)
    

### 제어 장치가 내보내는 정보

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/5863f767-63cc-4ed1-a8ee-cdbaec2ad862/Untitled.png)

- **CPU 외부에 전달하는 제어 신호**
    - **CPU 외부에 전달하는 제어 신호 =** **제어 버스로 보내는 제어 신호**
        - **메모리에 전달하는 제어 신호**
        - **입출력장치(보조기억장치 포함)에 전달하는 제어 신호**
    - 제어장치가 메모리에 저장된 값을 읽거나 메모리에 새로운 값을 쓰고 싶다면 메모리에 제어 신호를 보냄
    - 제어장치가 입출력장치의 값을 읽거나 입출력장치에 새로운 값을 쓰고 싶다면 입출력장치로 제어 신호 보냄
- **CPU 내부에 전달하는 제어 신호**
    - **ALU에 전달하는 제어 신호**
    - **레지스터에 전달하는 제어 신호**
    - ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 내보냄
    

---

### **정리**

- ALU는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들임
- ALU는 연산 결과와 플래그를 내보냄
- 제어장치는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들임
- 제어장치는 CPU 내부와 외부로 제어 신호를 내보냄

# 04-2. 레지스터

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/186f9cb5-aa52-4c7b-913e-4005df6d1dd6/Untitled.png)

- 프로그램 속 명령어와 데이터는 실행 전후로 반드시 레지스터에 저장됨
- 레지스터에 저장된 값만 잘 관찰해도 프로그램의 실행 흐름을 파악할 수 있음
    - 프로그램을 실행할 때 CPU 내에서 무슨 일이 벌어지고 있는지,
        
        어떤 명령어가 수행되는지
        
- CPU 안에는 다양한 레지스터들이 있고, 각기 다른 역할을 함

## 반드시 알아야 할 레지스터

---

상용화된 CPU 속 레지스터들은 CPU 마다 이름, 크기, 종류가 매우 다양함

많은 CPU가 공통으로 포함하고 있는 **8개**의 레지스터 

1. `프로그램 카운터`
2. `명령어 레지스터`
3. `메모리 주소 레지스터`
4. `메모리 버퍼 레지스터`
5. `플래그 레지스터`
6. `범용 레지스터`
7. `스택 포인터`
8. `베이스 레지스터`

### **프로그램 카운터**

---

**프로그램 카운터(PC; Program Counter)**는 메모리에서 가져올 **명령어의 주소**, 즉 메모리에서 읽어 들일 명령어의 주소를 저장함

- 프로그램 카운터를 `명령어 포인터(IP; Instruction Pointer)` 라고 부르는 CPU도 있음

### **명령어 레지스터**

---

**명령어 레지스터(IR; Instruction Register)**는 해석할 명령어, 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터

- 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보냄

### **메모리 주소 레지스터**

---

**메모리 주소 레지스터(MAR; Memory Address Register)** 는 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터

- 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거침
- CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거침

++ 메모리 버퍼 레지스터는 `메모리 데이터 레지스터( MDR; Memory Data Register) 라고 불림

- 메모리에 저장된 프로그램을 실행되는 과정
    
    <메모리에 저장된 프로그램을 실행되는 과정에서
    **프로그램 카운터**, **명령어 레지스터**, **메모리 주소 레지스터**, **메모리 버퍼 레지스터에 담기는 값>**
    
    1) CPU로 실행할 프로그램이 1000번지에서 1500번지까지 저장되어 있다고 가정,
    또한 1000번지에는 1101(2)이 저장되어 있다고 가정
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/419104cc-3379-4e07-b018-a1cbfcc38a6b/Untitled.png)
    
    2) 프로그램을 처음부터 실행하기 위해, 프로그램 카운터에는 1000이 저장됨
    ⇒ 메모리에서 가져올 명령어가 1000번지에 있다는 것을 의미함
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/ab4c3dce-49c0-4f83-a90d-ac788c86f6c3/Untitled.png)
    
    3) 1000번지를 읽어 들이기 위해서는 주소 버스로 1000번지를 내보내야 함
    
    이를 위해 메모리 주소 레지스터는 1000이 저장됨
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/3257de67-0581-4c16-bf71-0785928fcb0f/Untitled.png)
    
    4) ‘메모리 읽기’ 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내짐
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/9817bb06-9c1b-46a5-a772-b070c7ee0dbb/Untitled.png)
    
    5) 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고,
    프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 함
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/08f24c57-4b44-4c33-bc48-074b92aaac97/Untitled.png)
    
    6) 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동함
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/758d0735-7645-4a2c-ba45-2cdb5d181e05/Untitled.png)
    
    7) 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킴
    
     ⇒ 5) 단계에서 프로그램 카운터 값이 증가한 것을 확인함
    프로그램 카운터 값이 증가했으니, 1000번지 명령어가 끝나면  CPU는 다음 명령어(1001번지)를 읽어들임
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/67eb94fd-a3b6-443a-be38-ea82d53830e4/Untitled.png)
    
         : 프로그램 카운터는 지속적으로 증가하여 계속해서 다음 명령어를 읽어 들일 준비를 하며,
    이 과정이 반복되면서 CPU 는 프로그램을 차례대로 실행해 나감
    즉, CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나가는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문
    

<aside>
💡 **순차적인 실행 흐름이 끊기는 경우**

- 일반적으로 프로그램 카운터는 꾸준히 증가하며 프로그램을 차례대로 실행함
종종 프로그램 카운터가 실행 중, 명령어의 다음 번지 주소가 아닌 전혀 다른 값으로 업데이트 되는 경우가 있음

이런 상황은 명령어 중 JUMP, CONDITIONAL JUMP, CALL, RET 과 같이
특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되었을 때 프로그램은 차례대로 실행되지 않음 → 이런 경우 프로그램 카운터에는 변경된 주소가 저장됨

예) 1200번지를 실행하는 도중 JUMP 2500 이라는 명령어를 만났다고 가정하면,
이 명령어는 ‘2500번지로 점프하라’, ‘2500번지부터 실행하라’ 라는 명령어임
이 명령어를 실행한 다음에는 1201번지가 아닌 2500번지를 실행해야 하기 때문에
프로그램 카운터에는 1201번지가 아닌 2500번지가 저장됨

또한, 인터럽트가 발생해도 프로그램의 순차적인 실행 흐름이 끊어짐

</aside>

### **범용 레지스터**

---

**범용 레지스터(general purpose register)**는 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터

- 메모리 버퍼 레지스터는 데이터 버스로 주고받을 값만 저장하고,
메모리 주소 레지스터는 주소 버스로 내보낼 주소값만 저장
그러나, 범용레지스터는 데이터와 주소를 모두 저장할 수 있음
- CPU 안에는 여러 개의 범용 레지스터들이 있고, 현재 대다수 CPU는 범용 레지스터를 가지고 있음

### **플래그 레지스터**

---

**플래그 레지스터**는 ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장함

플래그 레지스터(flag register)는 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터

## 특정 레지스터를 이용한 주소 지정 방식(1) : 스택 주소 지정 방식

`프로그램 카운터`, `스택 포인터`, `베이스 레지스터`는 **주소 지정에 사용할 수 있는 특별한 레지스터**

**스택 포인터(stack pointer)는 스택 주소 지정 방식** 이라는 주소 지정 방식에 사용

**프로그램 카운터**와 **베이스 레지스터**는 **변위 주소 지정 방식** 이라는 주소 지정 방식에 사용

- **스택 주소 지정 방식**
    - 스택과 스택 포인터를 이용한 주소 지정 방식
    - 스택은 한쪽 끝이 막혀 있는 통과 같은 저장 공간으로, 가장 최근에 저장하는 값부터 꺼낼 수 있음

- **스택 포인터**
    - 스택 포인터는 스택의 꼭대기를 가르키는 레지스터
    - 스택 포인터는 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
    
    예) 위에서 부터 주소가 매겨져 있고, 아래로부터 차곡차곡 데이터가 저장되어 있는 스택이 있다고 가정하면
    
    이 때 스택 포인터는 스택의 제일 꼭대기 주소인 제 4번지를 저장하고 있음
    
    ⇒ ‘스택 포인터가 스택의 꼭대기를 가르키고 있음’ 
    
    스택 포인터는 **스택의 어디까지 데이터가 채워져 있는지에 대한 표시**임
    

|       <스택>  |       <번지> |
| --- | --- |
|  |         1번지 |
|  |         2번지 |
|  |         3번지 |
|           1 |         4번지 |
|           2 |         5번지 |
|           3 |         6번지 |

|                             <cpu> |
| --- |
|                          스택 포인터
                          < 4번지 > |

 - 이 스택에서 데이터를 꺼낼 때는 1→2→3 순**서대로 꺼낼 수 있음**
하나의 데이터를 꺼내면 2와 3이 남고, 스택의 꼭대기 주소가 달라져서 스택의 포인터는 5번지를 가리킴

여기서 반대로 스택에 데이터를 추가한다면, 현재 스택에 4라는 데이터가 저장되어 있으면
스택의 꼭대기에 4가 저장되고, 스택의 꼭대기 주소가 달라졌기 때문에 스택의 포인터는 4번지를 가리킴

- 스택은 메모리 안에 있음
⇒ 정확히는 메모리 안에 스택처럼 사용할 영역이 정해져 있음 `스택 영역`
- `스택 영역` 은 다른 주소 공간과 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/1be3fcde-24b1-47ad-ad70-fd218d7b71ce/Untitled.png)
    

## 특정 레지스터를 이용한 주소 지정 방식(2) : 변위 주소 지정방식

명령어는 연산 코드와 오퍼랜드로 이루어져 있고, 오퍼랜드 필드에는 메모리 주소가 담길 때도 있음

- `변위 주소 지정 방식(displacement addressing mode)` 은
    
    **오퍼랜드 필드의 값(변위)**와 **특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식**임
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/2050a16c-2e27-4be4-8bc7-0915bc315851/Untitled.png)
    
- 변위 주소 지정 방식을 사용하는 명령어는 다음과 같이 `연산 코드 필드` , `레지스터 필드`, `오퍼랜드 필드`

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/38c7f1e8-1532-4bcb-81a4-b1345d19b3a0/Untitled.png)

- 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라

`상대 주소 지정 방식`, `베이스 레지스터 주소 지정 방식` 으로 나뉨

### **상대 주소 지정 방식(relative addressing mode)**

---

**오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식**

- 프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있음
만약, 오퍼랜드가 음수인 -3 이라고 한다면 CPU는 읽어 들이기로 한 명령어로부터 ‘세 번째 이전’ 번지로 접근 ⇒ 실행하려는 명령어의 세 칸 이전 번지 명령어를 실행

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/e8cbdaab-d1a3-457a-beb2-1c736c43714f/Untitled.png)

   반면, 오퍼랜드가 양수인 3이라고 한다면 CPU는 읽어들이기로 했던 명령어의 ‘세 번째 이후’ 번지로 접근함
   ⇒ 즉, 실행하려는 명령어에서 세 칸 건너뛴 번지를 실행함

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/80922a21-9d48-488e-a5c7-c4dbd344f81a/Untitled.png)

- 상대 주소 지정 방식은 프로그래밍 언어의 if문과 유사하게 모든 코드를 실행하는 것이 아닌,
분기하여 특정 주소의 코드를 실행할 때 사용됨

### **베이스 레지스터 주소 지정 방식(base-register addressing mode)**

---

베이스 레지스터 주소 지정 방식은 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

- 베이스 레지스터는 ‘기준 주소’, 오퍼랜드는 ‘기준 주소로부터 떨어진 거리’로서의 역할을 함
- 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식임
    
     예를 들어, 베이스 레지스터에 200이라는 값이 있고, 오퍼랜드가 40이라면 
    ’기준 주소 200번지로부터 40만큼 떨어진 240번지로 접근하라’ 라는 의미임
    
    또 베이스 레지스터에 550이라는 값이 담겨 있고 오퍼랜드가 50이라면
    ’기준 주소 550번지로부터 50만큼 떨어진 600번지로 접근하라’ 를 의미하는 명령어
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/7dec9e0b-3d54-45f5-a846-7f1738a418c3/a0d5ebc1-8a5b-4e72-b3ea-3fd831f5fc33/Untitled.png)
    

### 정리

- 프로그램 카운터는 “메모리에서 가져올 명령어의 주소”
 명령어 레지스터는 “해석할 명령어”를 저장
 메모리 주소 레지스터는 “메모리의 주소” 저장
 메모리 버퍼 레지스터는 “메모리와 주고 받을 데이터” 저장

범용 레지스터는 “데이터와 주소” 모두 저장
플래그 레지스터는 “연산 결과 혹은 CPU 상태에 대한 부가 정보” 저장

스택 포인터는 “스택 최상단의 위치 저장”
베이스 레지스터에 저장된 주소는 “기준 주소로서의 역할”