# 11-1. CPU 스케줄링 개요


**CPU 스케줄링(CPU scheduling)** 

운영체제가 프로세스들에게 합리적으로 CPU 자원을 배분하는 것 → 컴퓨터 성능 직결


## 프로세스 우선순위



- 상황과 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 운영체제는 프로세스마다 우선순위(priority) 을 부여함
- 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정함
    
    → 우선순위가 높은 프로세스는 더 빨리, 더 자주 실행
    
    **→** 입출력 작업이 많은 프로세스가 높은 우선 순위를 가짐
    
- 프로세스는 일반적으로 cpu 버스트와 입출력 버스트를 반복하며 실행
    - **CPU 버스트(CPU burst)**
        
        : 프로세스가 CPU에서 연속적으로 작업을 수행하는 시간
        
    - **입출력 버스트(I/O burst)**
        
        : 프로세스가 입출력 장치와 데이터를 주고받는 시간
        
        (CPU가 아닌 I/O 작업이 이루어지는 시간)
        

- **입출력 집중 프로세스(I/O bound process)**
    - 입출력 작업이 많은 프로세스 (입출력 버스트 多)
    - 실행 상태보다는 입출력을 위한 대기 상태에 더 많이 머무름
- **CPU 집중 프로세스(CPU bound process)**
    - CPU 작업이 많은 프로세스(CPU 버스트 多)
    - 대기 상태보다 실행 상태에 더 많이 머무름
    

## 스케줄링 큐



- **PCB (프로세스 제어 블록)**
    - 운영체제가 각 프로세스의 상태를 관리하기 위해 사용하는 데이터 구조
    - 매번 CPU가 PCB를 통해 프로세스 우선순위를 결정한다면? → 비효율

- **스케줄링 큐(scheduling queue)**
    - 운영체제가 큐를 통해 자원을 관리
    - CPU를 이용하는 프로세스, 메모리에 적재되는 프로세스, 특정 입출력장치를 이용하는 프로세스 등 유형에 따라 모두 줄을 세우는 것
    - 일반적으로 큐는 선입선출 방식이지만 스케줄링 큐는 반드시 선입선출 X
        
        (우선순위 등을 고려)
        
        - 준비 큐(ready queue) : CPU를 사용하고자 하는 프로세스들이 대기하는 줄
        - 대기 큐(waiting queue) : 입출력 장치를 사용하기 위해 대기 중인 프로세스들이 서는 줄
        
    - 운영체제는 준비 큐에 있는 프로세스들의 PCB(프로세스 제어 블록)를 참고하여 CPU를 사용할 차례를 결정
    - 기본적으로 큐에 삽입된 순서대로 프로세스를 실행
    - 각 프로세스의 우선순위에 따라 우선순위가 높은 프로세스가 먼저 실행


### **선점형과 비선점형 스케줄링**



- CPU 스케줄링
    
    → CPU 스케줄링은 공정하고 합리적으로 CPU 자원을 배분하는 방법
    
- 프로세스 우선순위
    
    → 프로세스는 우선순위를 가지고 있으며, 이는 PCB(프로세스 제어 블록)에 명시됨
    
- 스케줄링 큐
    
    → 운영체제는 효율적인 스케줄링을 위해 스케줄링 큐를 사용준비 큐: CPU 할당을 기다리는 프로세스들을 위한 큐대기 큐: 입출력 장치를 기다리는 프로세스들을 위한 큐
    
- 스케줄링 방식
    
    → 선점형 스케줄링: 프로세스가 이용 중인 자원을 빼앗을 수 있음비선점형 스케줄링: 프로세스가 이용 중인 자원을 빼앗을 수 없음
    
    


# 11-2. CPU 스케줄링 알고리즘


### 선입 선처리 스케줄링 (FCFS :  **First Come First Scheduling**)

- 준비 큐에 삽입된 순서대로 프로세스를 처리하는 비선점형 스케줄링
- CPU를 먼저 요청한 프로세스부터 할당
- 공정하지만 대기 시간이 길어질 수 있음
- **호위 효과**: CPU를 오래 사용하는 프로세스가 먼저 도착 시 짧은 프로세스가 긴 대기시간을 겪음

### 최단 작업 우선 스케줄링 (SJF)

- 준비 큐에 삽입된 프로세스 중 CPU 사용 시간이 짧은 프로세스부터 실행
- 비선점형이지만 선점형으로 구현 가능 (최소 잔여 시간 우선 스케줄링)
- **호위 효과 방지**: CPU 사용 시간이 긴 프로세스는 나중에 실행

### 라운드 로빈 스케줄링

- 선입 선처리 스케줄링에 타임 슬라이스 개념 추가
- 정해진 시간만큼 돌아가며 CPU 이용
- 문맥 교환 발생
- 타임 슬라이스 : 크면 호위 효과, 작으면 문맥 교환 비용 증가

### 최소 잔여 시간 우선 스케줄링 (SRT)

- 최단 작업 우선 스케줄링과 라운드 로빈의 조합
- CPU 사용 시 남아있는 작업 시간이 가장 적은 프로세스가 선택됨

### 우선순위 스케줄링

- 프로세스에 우선순위 부여, 높은 우선순위부터 실행
- 우선순위가 같은 프로세스는 선입 선처리
- **기아 현상**: 우선순위가 낮은 프로세스가 계속 대기
- **에이징**: 오랫동안 대기한 프로세스의 우선순위를 점차 높임

### 다단계 큐 스케줄링

- 우선순위별로 여러 준비 큐 사용
- 가장 높은 우선순위 큐의 프로세스부터 처리
- 프로세스 유형별로 우선순위 구분 가능

### 다단계 피드백 큐 스케줄링

- 다단계 큐 스케줄링의 발전형
- 프로세스가 큐 사이를 이동할 수 있음
- CPU 이용 시간이 긴 프로세스는 낮은 우선순위 큐로 이동
- 낮은 우선순위 프로세스가 오래 대기하면 높은 우선순위 큐로 이동
- 구현이 복잡하지만 일반적인 CPU 스케줄링 알고리즘


## 질문


- **입출력 집중 프로세스와 CPU 집중 프로세스의 차이를 설명해 주세요.**
    - 입출력 집중 프로세스(I/O bound process)는 입출력 작업이 많아 대기 상태에 더 많이 머무르며, CPU 집중 프로세스(CPU bound process)는 CPU에서의 작업이 많고 실행 상태에 더 많이 머무릅니다.
    - CPU 집중 프로세스는 CPU 자원을 많이 소모하므로 스케줄링 시 우선적으로 고려해야 하며, 입출력 집중 프로세스는 대기 시간 동안 다른 프로세스에 CPU를 양보할 수 있어 효율적인 자원 활용이 가능합니다.


- **입출력 작업이 많은 프로세스를 먼저 실행하는 것이 효율적인 이유는 무엇인가요?**
    - 대기 시간 감소: I/O 작업이 많은 프로세스는 CPU를 사용하지 않는 시간이 길어, 먼저 실행함으로써 CPU 대기 시간을 줄일 수 있습니다.
    - 자원 활용 최적화: I/O 작업이 진행되는 동안 CPU는 다른 프로세스를 실행할 수 있어, CPU와 I/O 장치의 자원을 동시에 활용할 수 있습니다.
    - 기아 현상 방지: 입출력 집중 프로세스를 우선 처리하면 CPU 집중 프로세스에 의해 대기하는 시간을 줄여, 모든 프로세스가 공정하게 자원을 사용할 수 있도록 합니다.


- **라운드 로빈 스케줄링에서 타임 슬라이스의 크기가 중요한 이유는 무엇인가요?**
    - 타임 슬라이스는 각 프로세스가 CPU를 사용할 수 있는 시간입니다. 너무 크면 FCFS와 유사하게 동작하여 호위 효과가 발생할 수 있고, 너무 작으면 문맥 교환이 잦아져 CPU 자원의 낭비가 발생할 수 있습니다. 따라서 적절한 크기의 타임 슬라이스를 설정하는 것이 중요합니다.