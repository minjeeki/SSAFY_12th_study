# 10-1. 프로세스 개요



## 프로세스 관리

- 운영체제의 핵심 서비스
- 실행 중인 프로그램을 프로세스(process)라고 함

## 프로세스 직접 확인하기

- 컴퓨터 부팅 순간부터 수많은 프로세스 실행
- 윈도우: 작업 관리자의 [프로세스] 탭
- 유닉스: ps 명령어 (ps -ef)
- **포그라운드 프로세스**: 사용자가 보는 프로세스
- **백그라운드 프로세스**: 사용자가 보지 못하는 프로세스
    - **데몬(daemon)**: 유닉스에서의 백그라운드 프로세스
    - **서비스(service)**: 윈도우에서의 백그라운드 프로세스

## 프로세스 제어 블록 (PCB)

- CPU는 한정되어 있어 동시에 여러 프로세스 실행 불가
- 프로세스는 차례대로 CPU를 이용
- **타이머 인터럽트**: CPU 사용 시간 종료 시 발생
- 운영체제는 PCB를 통해 프로세스 관리

### PCB의 정보

- **프로세스 ID (PID)**: 고유한 번호
- **레지스터 값**: 이전 사용했던 레지스터의 중간값
- **프로세스 상태**: 현재 상태 (대기, 실행 등)
- **CPU 스케줄링 정보**: CPU 할당 정보
- **메모리 관리 정보**: 프로세스 메모리 주소 정보
- **사용한 파일과 입출력 장치 목록**: 사용된 자원 정보

## 문맥 교환

- **문맥(context)**: 프로세스 수행을 재개하기 위해 기억해야 할 정보
- PCB에 기록된 문맥을 백업하고, 새로운 프로세스 실행을 위한 복구
- 문맥 교환: 프로세스 간 실행 전환

## 프로세스의 메모리 영역

- 프로세스 생성 시 커널 영역에 PCB 생성
- 사용자 영역:
    - **코드 영역**: 실행 가능한 코드 저장
    - **데이터 영역**: 전역 변수 저장
    - **힙 영역**: 동적으로 할당 가능한 메모리
    - **스택 영역**: 일시적인 데이터 저장 (매개변수, 지역 변수)

### 메모리 영역 특징

- **코드 영역**: 읽기 전용
- **데이터 영역**: 크기 고정
- **힙 영역**: 동적 할당, 메모리 누수 가능
- **스택 영역**: 일시적 데이터 저장, 실시간 크기 변동

---

**프로세스**: 실행 중인 프로그램. **종류**: 포그라운드 프로세스, 백그라운드 프로세스.

**운영체제**: 프로세스 제어 블록을 통해 프로세스 관리.

**문맥 교환**: 프로세스 간 실행 전환.

**메모리 영역**: 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 구분.
<br>
<br>
# 10-2. 프로세스 상태와 계층 구조



## 프로세스 상태

- 여러 프로세스가 빠르게 번갈아 실행
- 프로세스는 여러 상태를 거쳐 실행
- 운영체제는 PCB를 통해 프로세스 상태 인식 및 관리
- 대표적인 프로세스 상태:
    - **생성 상태 (new)**: 프로세스 생성 중, 메모리에 적재되고 PCB 할당
    - **준비 상태 (ready)**: CPU를 할당받을 준비가 완료된 상태, 차례를 기다림
        - **디스패치(dispatch)**: 준비 상태에서 실행 상태로 전환
    - **실행 상태 (running)**: CPU를 할당받아 실행 중, 타이머 인터럽트 발생 시 준비 상태로 전환 또는 대기 상태로 전환
    - **대기 상태 (blocked)**: 입출력 작업을 기다리는 상태, 입출력 완료 인터럽트를 받을 때까지 대기
    - **종료 상태 (terminated)**: 프로세스 종료, PCB 및 메모리 정리

### 프로세스 상태 다이어그램

- 프로세스는 생성, 준비, 실행, 대기, 종료 상태를 거치며 실행
- 상태 변화는 PCB에 기록되어 운영체제가 관리

### 대기 상태의 일반적인 정의

- 특정 이벤트가 일어나길 기다리는 상태
- 대부분의 경우 입출력 작업으로 대기 상태가 됨

## 프로세스 계층 구조

- 프로세스는 시스템 호출을 통해 다른 프로세스를 생성 가능
- **부모 프로세스 (parent process)**: 다른 프로세스를 생성한 프로세스
- **자식 프로세스 (child process)**: 부모 프로세스에 의해 생성된 프로세스
- 부모와 자식 프로세스는 PID가 다름
- 일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(PPID) 기록
- 최초의 프로세스가 자식 프로세스를 생성, 트리 구조를 형성

### 최초의 프로세스

- 유닉스: init
- 리눅스: systemd
- macOS: launchd
- 최초의 프로세스 PID는 항상 1

### 프로세스 계층 보기

- **pstree** 명령어: 프로세스 계층을 보여주는 명령어

## 프로세스 생성 기법

- 자식 프로세스는 복제와 옷 갈아입기를 통해 실행
- **fork**: 부모 프로세스의 복사본 생성
    - 자식 프로세스는 부모의 자원 상속
- **exec**: 자식 프로세스의 메모리 공간을 새로운 프로그램으로 교체
    - 코드 영역과 데이터 영역 내용이 새로운 프로그램으로 변경, 나머지 영역 초기화

---

**프로세스 상태**: 생성, 준비, 실행, 대기, 종료

**부모 프로세스**: 다른 프로세스를 생성한 프로세스

**자식 프로세스**: 부모 프로세스에 의해 생성된 프로세스

**프로세스 계층 구조**: 프로세스가 프로세스를 생성하는 구조
<br><br>
# 10-3. 스레드



## 스레드

- 프로세스를 구성하는 실행의 흐름 단위
- 스레드(thread): 실행의 단위

## 프로세스와 스레드

- 전통적으로 하나의 프로세스는 하나의 실행 흐름만 처리
    - 예: 웹 브라우저, 게임, 워드 프로세서
- 단일 스레드 프로세스: 실행 흐름 단위가 하나
- 스레드 개념 도입 후, 하나의 프로세스가 여러 일을 동시에 처리 가능
    - 멀티스레드 프로세스: 여러 명령어를 동시에 실행
- 스레드는 프로세스 내에서 스레드 ID, 프로그램 카운터 값, 레지스터 값, 스택으로 구성
- 프로세스 자원을 공유하며 실행, 실행에 필요한 최소한의 정보만 유지

### 리눅스 운영체제에서 프로세스 vs 스레드

- 프로세스와 스레드를 구분하지 않고 태스크(task)로 통일하여 명명

## 멀티프로세스와 멀티스레드

- 여러 프로세스가 동시에 실행: 멀티프로세스(multiprocess)
- 여러 스레드로 프로세스를 동시에 실행: 멀티스레드(multithread)
- 프로세스끼리는 자원을 공유하지 않지만, 스레드끼리는 같은 프로세스 내의 자원을 공유

### 쓰기 시 복사 (Copy on Write)

- 프로세스끼리 자원을 공유하지 않으면서 메모리 중복 저장하지 않음

## 스레드 특성

- 각기 다른 스레드 ID, 프로그램 카운터 값, 레지스터 값, 스택을 가짐
- 모든 스레드는 프로세스 자원을 공유
- 하나의 스레드에 문제가 생기면 다른 스레드도 영향을 받음

### 프로세스 간 통신 (IPC)

- 프로세스끼리는 기본적으로 자원을 공유하지 않음
- 자원을 공유하고 데이터를 주고받는 것: 프로세스 간 통신(IPC)
- 예: 파일을 통한 프로세스 간 통신
- 공유 메모리: 프로세스들이 데이터를 주고받기 위한 공유 영역
<br>
---

**스레드**: 프로세스 내의 실행 흐름 단위

**멀티프로세스**: 여러 프로세스를 동시에 실행

**멀티스레드**: 여러 스레드로 프로세스를 동시에 실행

<br>
<br>

# 질문

- **프로세스와 스레드의 차이점은 무엇인가요?**
    - 프로세스는 실행 중인 프로그램의 인스턴스를 의미하며, 독립적인 메모리 공간을 가지며 서로 자원을 공유하지 않습니다. 반면, 스레드는 프로세스 내에서 실행되는 흐름의 단위로, 같은 프로세스 내에서 메모리와 자원을 공유합니다. 스레드는 더 가벼운 작업 단위로, 프로세스보다 생성과 종료가 빠르고, 문맥 교환이 더 효율적입니다.

- **프로세스 간 통신(IPC)의 방법에는 어떤 것들이 있나요?**
    - IPC의 주요 방법에는 공유 메모리, 메시지 큐, 파이프, 소켓 등이 있습니다. 공유 메모리는 여러 프로세스가 같은 메모리 공간을 공유하여 데이터를 주고받는 방식입니다. 메시지 큐와 파이프는 프로세스 간에 데이터를 전송하는 큐를 사용하며, 소켓은 네트워크를 통해 다른 프로세스와 통신하는 방법입니다.

- **리눅스에서 프로세스와 스레드를 어떻게 구분하나요?**
    - 리눅스에서는 프로세스와 스레드를 명확히 구분하지 않고, 둘 다 실행의 문맥(context of execution)으로 간주합니다. 리눅스에서는 태스크(task)라는 용어를 사용하여 프로세스와 스레드를 통합적으로 관리합니다. 모든 태스크는 PID를 갖고 있으며, 스레드는 동일한 PID 내에서 실행됩니다.