# Chapter 14. 가상 메모리

## 14-1. 연속 메모리 할당

### 스와핑

- 메모리에서 사용되지 않는 일부 프로세스를 보조기억장치로 내보내고 실행할 프로세스를 메모리로 들여보내는 메모리 관리 기법
- 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스를 동시 실행할 수 있음
    - 스왑 영역(swap space) : 프로세스들이 쫓겨나는 보조기억장치의 일부
    - 스왑 아웃(swap-out) : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
    - 스왑 인(swap-in) : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것
- 스왑 아웃되었던 프로세스가 다시 스왑 인 될 때는 스왑 아웃이되기 전의 물리주소와는 다른 주소에 적재될 수 있음

### 메모리 할당

- 메모리 내에 빈 공간이 여러개 있을 때, 비어 있는 메모리 공간에 프로세스를 연속적으로 할당
    - 최초 적합(first fit)
        - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
        - 검색을 최소화 할 수 있고 결과적으로 빠른 할당이 가능
            - 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리 할당
    - 최적 적합(best fit)
        - 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치
    - 최악 적합(worst fit)
        - 운영체제가 빈 공간을 모두 검색한 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치함

### 외부 단편화(external fragmentation)

- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생김 → 메모리 낭비
    - 프로세스 바깥에 생기는 빈 공간은 그 공간보다 큰 프로세스를 적재하기 어려운 상황

- 압축(compaction)
    - 메모리 조각모음 (외부 단편화 해결 방안)
        - 흩어져 있는 빈 공간들을 하나로 모으는 방식
    - 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지해야 하고, 메모리에 있는 내용을 옮기는 작업 → 많은 오버헤드
    - → 다른 외부 단편화 해결방안은 가상 메모리 기법인 **`페이징 기법`**

## 14-2. 페이징을 통한 가상 메모리 관리

가상 메모리(virtual memory)

실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술

### 페이징(paging)

프로세스의 논리 주소 공간을 **페이지(page)** 라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 **프레임(frame)** 이라는 페이지와 동일한 크기의 일정 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법

- 물리 메모리보다 큰 프로세스를 실행할 수 있고, 외부 단편화도 해결 가능
- 연속 메모리 할당 방식에서 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문임
    - 메모리와 프로세스를 일정한 단위로 자르고, 이를 메모리에 불연속적으로 할당할 수 있으면 외부 단편화는 발생하지 않음

- 페이징 시스템에서의 스와핑
    - 프로세스 전체가 스왑 아웃/스왑 인 되는 것이 아닌 페이지 단위로 스왑 아웃/스왑인 됨
    - 한 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요가 없다
        - 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있음
          → 물리 메모리보다 더 큰 프로세스 실행 가능
    - 페이지 아웃(page out)
        - 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 **스왑 아웃**
    - 페이지 인(page in)
        - 실행에 필요한 페이지들은 메모리로 **스왑 인**


### 페이지 테이블(page table)

페이지 번호와 프레임 번호를 짝지어주는 일종의 이정표 (현재 어떤 페이지가 어떤 프레임에 할당되었는지 알려줌)

- CPU로 하여금 페이지 번호만 보고 해당 페이지가 적재된 프레임을 찾을 수 있게 함
- 프로세스가 메모리에 불연속적으로 배치되면 CPU 입장에서 ‘다음 실행할 명령어 위치’를 찾기 어려움
- 페이징 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용

- **내부 단편화(internal fragmentation)**

  페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 크기로 자르지만, 모든 프로세스가 페이지 크기에 딱 맞게 잘리는 것은 아님 → 내부 단편화 발생

    - 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생함

      하나의 페이지 크기가 작다면 발생하는 내부 단편화 크기도 작아지지만 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기가 커져서 페이지 테이블이 차지하는 공간이 낭비됨
        - 내부 단편화를 적당히 방지하면서, 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요

    - 페이징은 외부 단편화 문제를 해결할 수 있지만, 내부 단편화 문제를 야기

- 페이지 테이블 베이스 레지스터(PTBR : Page Table Base Register )
    - CPU내 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴
        - 프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재됨
        - **각 프로세스들의 페이지 테이블 정보들은 각 프로세스의 PCB에 기록됨**
        - **프로세스의 문맥 교환이 일어날 때 다른 레지스터와 마찬가지로 함께 변경됨**

  → 메모리 접근 두 번 해야함(접근 시간 2배)


- **TLB(Translation Lookaside Buffer)**

  페이지 테이블 캐시 메모리 → 페이지 테이블의 일부 내용을 저장함

  → 참조 지역성에 근거해 주로 최근에 사용된 페이지 위주로 가져와 저장

    - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 → TLB 히트(TLB hit)
        - 이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요가 없어, 메모리 접근을 한 번만 하면 됨
    - 페이지 번호가 TLB에 없으면 페이지가 적재된 프레임을 알기 위해 메모리 내의 페이지 테이블에 접근해야 함 → TLB 미스(TLB miss)

### 페이징에서의 주소 변환

페이징 시스템에서 모든 논리 주소 → 페이지 번호 + 변위

- 페이지 번호 : 접근하고자 하는 페이지 번호
    - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지 알 수 있음
- 변위 : 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지 알기 위한 정보

→ 논리 주소 <페이지 번호, 변위> 는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위> 로 변환

### 테이블 페이지 엔트리(PTE:Page Table Entry)

- **유효 비트(vaild bit)**

  : 현재 해당 페이지에 접근 가능한지 여부

  : 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려주는 비트

    - 페이지가 메모리에 적재되어 있다면 → 유효 비트 1

      페이지가 메모리에 적재되어 있지 않으면 → 유효 비트 0

        - 만약, CPU가 유효 비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 하면?→ 페이지 폴트(page falut) 라는 예외(Exception) 발생

- **보호 비트(protection bit)**
    - 페이지 보호 기능을 위해 존재하는 비트
    - 보호 비트를 통해 해당 페이지가 읽고 쓰기가 모두 가능한 페이지 인지, 혹은 읽기만 가능한 페이지인지를 나타냄
    - 0 → 이 페이지는 읽기만 가능한 페이지

      1 → 읽고 쓰기가 모두 가능한 페이지

        - 읽기 전용 페이지에 쓰기를 시도하면 이와 같은 방식으로 페이지를 보호(프로세스의 코드 영역- 읽기 전용)
    - 보호비트 구현
        - **r : 읽기(Read)**
        - w :  **쓰기(Write)**
        - **x : 실행(eXecute)**
            - 보호비트가 110이면 페이지는 읽고 쓰기 가능 실행 불가능

              보호비트가 111이면 읽기, 쓰기, 실행 모두 가능


- **참조 비트(reference bit)**

  CPU가 이 페이지에 접근한 적이 있는지 여부를 나타냄

    - 1 → 적재 이후 CPU가 읽거나 쓴 페이지
    - 0 → 적재 이후 한 번도 읽거나 쓴 적이 없는 페이지

- **수정 비트(modified bit)**

  해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 알려줌 == 더티 비트(dirty bit)

    - 1 → 변경된 적이 있는 페이지

      0 → 변경된 적이 없는 페이지(한 번도 접근한 적 없거나 읽기만 했던 페이지)

    - 수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지 ,할 필요가 없는지를 판단
        - 수정 비트가 0인 페이지→ 보조기억장치에 저장된 해당 페이지의 내용과 메모리에 저장된 페이지의 내용은 서로 같은 값을 가지고 있음
            - 한 번도 수정된 적이 없는 페이지가 스왑 아웃될 경우 추가 작업 없이 새로 적재된 페이지를 덮어쓰기만 하면됨
        - 수정 비트가 1인 페이지 → 보조기억장치에 적재된 페이지의 내용과 메모리에 저장된 페이지의 내용은 서로 다른 값을 갖게 됨
            - 수정된 적이 있는 페이지가 스왑 아웃될 경우 변경된 값을 보조기억장치에 기록하는 작업이 추가됨

              → 추가 작업 필요 여부를 확인하기 위해 페이지 테이블 엔트리에 수정비트를 둔다


### 14-3. 페이지 교체와 프레임 할당

- FIFO 페이지 교체 알고리즘 : First-In First-Out Page Replacement Algorithm
    - 가장 먼저 들어온 페이지를 교체
- **최적 페이지 교체 알고리즘 :** optimal page replacement algorithm
    - CPU에 의해 참조되는 횟수를 고려하여 페이지 교체
    - 보조기억장치로 내보내야 할 페이지는 사용 빈도가 가장 낮은 페이지로, 사용 빈도가 가장 낮은 페이지를 교체
- **LRU 페이지 교체 알고리즘 : Least Recently Used Page Replacement Algorithm**
    - 가장 오랫동안 사용되지 않은 페이지를 교체

+

- LFU(Least *Frequently* Used) - 참조 횟수가 가장 낮은 페이지를 교체
- MFU(Most Frequently used) - 참조 횟수가 가장 많은 페이지 교체
- NUR = NRU(Not Used Recently, Not Recently Used), 클럭 알고리즘